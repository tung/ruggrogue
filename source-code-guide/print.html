<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RuggRogue Source Code Guide</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Design and source code breakdown of a simple roguelike">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="book/outlink.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="dependencies.html"><strong aria-hidden="true">1.</strong> Dependencies</a></li><li class="chapter-item expanded "><a href="source-code-layout.html"><strong aria-hidden="true">2.</strong> Source Code Layout</a></li><li class="chapter-item expanded "><a href="overall-game-flow.html"><strong aria-hidden="true">3.</strong> Overall Game Flow</a></li><li class="chapter-item expanded "><a href="event-handling.html"><strong aria-hidden="true">4.</strong> Event Handling</a></li><li class="chapter-item expanded "><a href="rendering.html"><strong aria-hidden="true">5.</strong> Rendering</a></li><li class="chapter-item expanded "><a href="user-interface.html"><strong aria-hidden="true">6.</strong> User Interface</a></li><li class="chapter-item expanded "><a href="options.html"><strong aria-hidden="true">7.</strong> Options</a></li><li class="chapter-item expanded "><a href="word-wrapping.html"><strong aria-hidden="true">8.</strong> Word Wrapping</a></li><li class="chapter-item expanded "><a href="entity-component-system.html"><strong aria-hidden="true">9.</strong> Entity Component System</a></li><li class="chapter-item expanded "><a href="game-data.html"><strong aria-hidden="true">10.</strong> Game Data</a></li><li class="chapter-item expanded "><a href="saving-and-loading.html"><strong aria-hidden="true">11.</strong> Saving and Loading</a></li><li class="chapter-item expanded "><a href="field-of-view.html"><strong aria-hidden="true">12.</strong> Field of View</a></li><li class="chapter-item expanded "><a href="pathfinding.html"><strong aria-hidden="true">13.</strong> Pathfinding</a></li><li class="chapter-item expanded "><a href="randomness.html"><strong aria-hidden="true">14.</strong> Randomness</a></li><li class="chapter-item expanded "><a href="map-generation.html"><strong aria-hidden="true">15.</strong> Map Generation</a></li><li class="chapter-item expanded "><a href="map-population.html"><strong aria-hidden="true">16.</strong> Map Population</a></li><li class="chapter-item expanded "><a href="auto-run.html"><strong aria-hidden="true">17.</strong> Auto-Run</a></li><li class="chapter-item expanded "><a href="turn-order-and-combat.html"><strong aria-hidden="true">18.</strong> Turn Order and Combat</a></li><li class="chapter-item expanded "><a href="items.html"><strong aria-hidden="true">19.</strong> Items</a></li><li class="chapter-item expanded "><a href="hunger-and-regeneration.html"><strong aria-hidden="true">20.</strong> Hunger and Regeneration</a></li><li class="chapter-item expanded "><a href="experience-and-difficulty.html"><strong aria-hidden="true">21.</strong> Experience and Difficulty</a></li><li class="chapter-item expanded "><a href="monsters.html"><strong aria-hidden="true">22.</strong> Monsters</a></li><li class="chapter-item expanded "><a href="new-game-plus.html"><strong aria-hidden="true">23.</strong> New Game Plus</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">RuggRogue Source Code Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to the <em>RuggRogue Source Code Guide</em>!
This is a web book describing the internal workings of <a href="https://tung.github.io/ruggrogue/">RuggRogue</a>: a simple, complete roguelike inspired by the first part of the <a href="https://bfnightly.bracketproductions.com">Rust Roguelike Tutorial</a>.
Unlike that tutorial, however, it's made without the help of any game engine or roguelike helper libraries, instead relying on <a href="https://libsdl.org">SDL2</a>, with <a href="https://emscripten.org">Emscripten</a> for the web port.</p>
<p>RuggRogue itself plays out like many other roguelikes: You fight your way down a procedurally generated dungeon through ever-stronger monsters.
Along the way you'll find weapons, armor and magical items that will aid you in your quest.</p>
<p>The source code of RuggRogue can be found at <a href="https://github.com/tung/ruggrogue">its GitHub repository</a>.
It consists of thirteen thousand lines of Rust code across forty four files.
How does it all fit together?
Read on and find out!</p>
<h2 id="about-this-book"><a class="header" href="#about-this-book">About this Book</a></h2>
<p>RuggRogue is a relatively small open source game, so in theory everything about how it works could be learned by simply reading its source code.
However, the code is arranged for the computer to run first and foremost, so broad ideas are obscured by a vast sea of details.
The aim of this book is to highlight these ideas, from a high-level perspective all the way down to how they translate into functions and variables.</p>
<p>Studying the code architecture of RuggRogue is interesting for a few reasons.
The game is directly inspired by the numerous roguelike tutorials that can found across the Internet, but it goes beyond them in a number of ways.
It directly implements algorithms that tutorials typically provide canned solutions to, such as field of view and pathfinding.
It also answers questions that such tutorials typically leave as an exercise to the reader, such as game balance, word wrapping and auto-run.</p>
<p>At the same time, RuggRogue is a complete game with a limited scope that doesn't go too much further than those roguelike tutorials.
A person who has followed one of them has a realistic chance of learning from the RuggRogue source code without being overwhelmed.</p>
<p>Finally, RuggRogue's source code architecture differs quite a bit from most roguelike tutorials.
RuggRogue arranges a lot of its logic into <em>game states</em> with an explicit <em>game state stack</em> (internally referred to as <em>&quot;modes&quot;</em> and <em>&quot;the mode stack&quot;</em>).
This allows different screens and menus to keep their data and the code very close together.
This technique is hard to find in roguelike tutorials, but it's described in this book.</p>
<h2 id="who-is-this-book-for"><a class="header" href="#who-is-this-book-for">Who is this Book for?</a></h2>
<p>This book is written for programmers, so prior knowledge is assumed for things like variables, branches, loops, functions and basic data structures such as stacks, vectors and hash maps.</p>
<p>The game is written in the Rust programming language, but I try to keep it simple, so Rust knowledge is helpful to follow along but not mandatory.
Readers coming from other programming languages may want to look up Rust topics such as <a href="https://doc.rust-lang.org/book/ch10-02-traits.html"><em>traits</em></a> (like interfaces in other languages), <a href="https://doc.rust-lang.org/book/ch07-05-separating-modules-into-different-files.html"><em>modules</em></a>, <a href="https://doc.rust-lang.org/book/ch06-00-enums.html"><em>pattern matching</em></a> and <a href="https://doc.rust-lang.org/book/ch13-02-iterators.html"><em>iterators</em></a>.</p>
<p>If you're an aspiring roguelike developer, this book will give you broad idea of the scope of a roguelike.
Reading a chapter in detail should serve as useful guidance as to how to implement features yourself.</p>
<p>If you're developing a roguelike yourself already, this book should serve as an interesting case study to compare and contrast your existing approaches to various features.
You may stumble across ideas you hadn't thought of to enhance the game you're working on.</p>
<p>If you're a programmer that's curious about game development in general, this book will shed some light on how a game functions under the hood.
Everything game-related must be handled by the source code, since there's no game engine for anything to hide in.</p>
<h2 id="how-to-read-this-book"><a class="header" href="#how-to-read-this-book">How to Read this Book</a></h2>
<p>Each chapter of the book is more or less standalone, so they can mostly be read in any order.
There are a few cross-references, most of which point backwards.</p>
<p>Chapters vary in balance between describing high-level ideas and fine-grained technical details.
Unfortunately, the early chapters are fairly detail-heavy due to establishing the technical base upon which all of the (hopefully) fun gameplay is built upon.
If it becomes too much to bear, feel free to skip the chapter and come back later.</p>
<p>In all of the chapters, there are many references to the names of files, functions, variables and other code-specific things.
You'll get the most out of this book with the source code handy in another window.</p>
<p>On the other hand, if you're not interested in juggling the game's source code while reading the book, you can still skim the chapters just for the ideas and skip over the source code references.</p>
<h2 id="chapter-overview"><a class="header" href="#chapter-overview">Chapter Overview</a></h2>
<p><a href="dependencies.html"><strong>Dependencies</strong></a>: The technology, libraries and tools used to create the game.</p>
<p><a href="source-code-layout.html"><strong>Source Code Layout</strong></a>: The location and purpose of each file and directory of the source code.</p>
<p><a href="overall-game-flow.html"><strong>Overall Game Flow</strong></a>: Game initialization, game loop and mode (game state) stack.</p>
<p><a href="event-handling.html"><strong>Event Handling</strong></a>: Handling of external events such as player input, window resizing and closing.</p>
<p><a href="rendering.html"><strong>Rendering</strong></a>: Drawing grids of tiles onto the screen and performance-improving techniques.</p>
<p><a href="user-interface.html"><strong>User Interface</strong></a>: How menus work and screens are laid out.</p>
<p><a href="options.html"><strong>Options</strong></a>: The options menu and how option changes are reflected in real-time.</p>
<p><a href="word-wrapping.html"><strong>Word Wrapping</strong></a>: How long lines of text are broken up to fit inside a limited space.</p>
<p><a href="entity-component-system.html"><strong>Entity Component System</strong></a>: How data is stored, retrieved and modified.</p>
<p><a href="game-data.html"><strong>Game Data</strong></a>: The different types of data components and how entities are created and destroyed.</p>
<p><a href="saving-and-loading.html"><strong>Saving and Loading</strong></a>: What save files look like and how they work.</p>
<p><a href="field-of-view.html"><strong>Field of View</strong></a>: Determining which tiles the player and monsters can see using shadow casting.</p>
<p><a href="pathfinding.html"><strong>Pathfinding</strong></a>: A* search algorithm for finding paths between points, its uses and subtleties.</p>
<p><a href="randomness.html"><strong>Randomness</strong></a>: Pseudo-random number generation, seeds and reproducibility of results.</p>
<p><a href="map-generation.html"><strong>Map Generation</strong></a>: Data structures and logic for randomly laying out rooms, corridors and stairs.</p>
<p><a href="map-population.html"><strong>Map Population</strong></a>: Placement of the player, monsters and items in freshly-generated maps.</p>
<p><a href="auto-run.html"><strong>Auto-Run</strong></a>: Implementing the smart directional &quot;auto-run&quot; movement command that follows corridors and crosses open space.</p>
<p><a href="turn-order-and-combat.html"><strong>Turn Order and Combat</strong></a>: Monster turns, melee combat, damage formula and death handling.</p>
<p><a href="items.html"><strong>Items</strong></a>: List of items, spawn rates, item-related data structures, menus and usage logic.</p>
<p><a href="hunger-and-regeneration.html"><strong>Hunger and Regeneration</strong></a>: How hunger fits into the rest of the game and its link to regeneration.</p>
<p><a href="experience-and-difficulty.html"><strong>Experience and Difficulty</strong></a>: Game balance, numeric progression and pacing the flow of new monsters, weapons and armor.</p>
<p><a href="monsters.html"><strong>Monsters</strong></a>: Mini-chapter with a list of monsters and cross-references to other chapters about how they work.</p>
<p><a href="new-game-plus.html"><strong>New Game Plus</strong></a>: Gameplay and implementation details of how successive wins change play-throughs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h1>
<p>RuggRogue doesn't use any roguelike helper libraries, but that doesn't mean it was made from scratch.
In order to complete the game in a reasonable time frame, I had to make use of some external tools and libraries.</p>
<h2 id="the-language-rust"><a class="header" href="#the-language-rust">The Language: Rust</a></h2>
<p>A lot has been said about the benefits of Rust as a programming language, so I'll stick to general points on how it relates to RuggRogue.
When I was starting out, there were two things I wanted out of whatever I was going to build the game out of: correctness and performance, and I was willing to take the extra time to make them happen.
In those ways, Rust was a perfect fit for the project.</p>
<p>On correctness, Rust's strong type system provided a robust foundation for structuring the game.
It also allowed for bold code improvements that I would never have attempted without it; code that would otherwise needed whole rewrites or been left in a sub-par state.
My attitude towards bugs is to catch and eliminate them early, and Rust's type and safety checks detect most low-level bugs pretty much as early as possible.</p>
<p>As for performance, I dislike any software that uses more CPU or memory than it needs to do its job.
There's lots of software like that nowadays everywhere due to developers working under time pressure, but it still feels disrespectful to waste the time and resources of so many users to save some time for a few developers.
But thanks to Rust, RuggRogue doesn't have to join their ranks.
It still takes time and effort to improve performance, but the result is a game that doesn't feel awful to have open.
I don't know if anybody else cares, even most of the players, but that's very satisfying to me.</p>
<p>Aside from correctness and performance, Rust's tooling and standard library served the creation of RuggRogue very well.</p>
<h2 id="the-libraries"><a class="header" href="#the-libraries">The Libraries</a></h2>
<p>Rust refers to libraries as <em>crates</em>, so if I use the word &quot;crate&quot; anywhere, it's safe to mentally substitute it with &quot;library&quot;.
RuggRogue uses the following crates to do handle various things it doesn't already handle itself:</p>
<h3 id="bitflags"><a class="header" href="#bitflags">bitflags</a></h3>
<p><a href="https://crates.io/crates/bitflags">bitflags</a> enables the creation of compact bitmask values with symbolic names.
RuggRogue uses it to encode the state of the Shift, Ctrl and Alt modifier keys in a single value that the game logic can check later.</p>
<h3 id="bitvec"><a class="header" href="#bitvec">bitvec</a></h3>
<p><a href="https://crates.io/crates/bitvec">bitvec</a> provides a memory-dense representation of what would otherwise be a vector of booleans that would be each be a byte and thus be eight times larger in memory.
Reducing memory usage improves cache utilization, which makes the game faster in general.
RuggRogue uses bitvecs to keep track of which map tiles the player has seen on the current dungeon level, as well as the tiles within each entity's field of view.</p>
<h3 id="rand-rand_xoshiro"><a class="header" href="#rand-rand_xoshiro">rand, rand_xoshiro</a></h3>
<p><a href="https://crates.io/crates/rand">rand</a> provides convenient APIs for extracting and using numbers from a backing random number generator.
<a href="https://crates.io/crates/rand_xoshiro">rand_xoshiro</a> is one such backing whose implementation is simple, fast and high quality for non-cryptographic needs, like games.
RuggRogue uses these crates to generate random numbers for level generation, item and monster spawning and combat calculations.</p>
<h3 id="sdl2"><a class="header" href="#sdl2">sdl2</a></h3>
<p><a href="https://crates.io/crates/sdl2">sdl2</a> or &quot;Rust-SDL2&quot; as the crate refers to itself provides access to <a href="https://libsdl.org/">SDL</a>.
SDL itself is a library that provides access to windows, input events and display in a cross-platform manner.
RuggRogue enables the <code>image</code> feature to load PNG files for tiles and ASCII symbols.</p>
<p>SDL is the only non-Rust external dependency of RuggRogue, which has interesting implications.
By choosing SDL instead of pure Rust alternatives, RuggRogue is able to avoid having to compile literally dozens of additional dependent crates, which drastically saves on initial compile times and final binary size.
On top of that, it means that unoptimized debug builds of RuggRogue run almost as fast as optimized release builds; for reference, the performance difference between debug and release builds of the pure Rust approach can be as high as 5x to 10x!</p>
<p>There is one big downside to using a non-Rust dependency in a Rust project, which is that it forces other developers who want to build the game to install SDL themselves; a task that requires some specialized platform-specific knowledge.
It's easiest on Linux, which is what I developed RuggRogue on: a package manager installs SDL2 and SDL2_image in a standard location, Rust knows how to look in that standard location, and everything is flowers and sunshine.
It's hardest on Windows, which is used by almost 90% of people with a computer, since there's no standard location for development packages, so tools have no idea how to cooperate without messing with paths and deciphering cryptic error messages when you inevitably screw it up.</p>
<h3 id="serde-serde_json"><a class="header" href="#serde-serde_json">serde, serde_json</a></h3>
<p><a href="https://crates.io/crates/serde">serde</a> provides plumbing and infrastructure to enable serialization and deserialization of data structures.
<a href="https://crates.io/crates/serde_json">serde_json</a> uses that plumbing to convert data to and from the JSON text-based data format.
RuggRogue uses these crates to convert its data structures into JSON when saving the game to a file, and convert them back out when loading a saved game from a file.</p>
<h3 id="shipyard"><a class="header" href="#shipyard">shipyard</a></h3>
<p><a href="https://crates.io/crates/shipyard">shipyard</a> is an Entity Component System (or &quot;ECS&quot;) crate that provides:</p>
<ol>
<li>data storage in the form of entities with data components attached,</li>
<li>systems that are functions that run on subsets of entities based on which components they have, and</li>
<li>workloads that are bundles of ordered systems that are to be executed repeatedly.</li>
</ol>
<p>However, RuggRogue only uses the entity-and-component data storage of Shipyard, and mostly uses conventional functions, reaching for systems only when convenient and avoiding workloads entirely.
This avoids having lots of message queues to do cross-system communication, and thus a lot of red tape, since systems can't directly call other systems in the classic ECS arrangement.
On the other hand, I have to carefully handle every function call, every branch and every loop to make sure everything runs at exactly the right time, and the right number of times, which the flat and linear model of system-based workloads sidesteps entirely.
My &quot;EC-only&quot; approach isn't necessarily better than the full ECS approach, but it makes it very different to what it otherwise would have been.</p>
<h3 id="wyhash"><a class="header" href="#wyhash">wyhash</a></h3>
<p><a href="https://crates.io/crates/wyhash">wyhash</a> is a hashing crate; it ingests some data and calculates a hash value for that data.
Remember rand and rand_xoshiro?
There's more to the random number story in RuggRogue.
RuggRogue uses wyhash to create seeds for temporary random number generators that it uses.</p>
<h2 id="the-web-support-emscripten"><a class="header" href="#the-web-support-emscripten">The Web Support: Emscripten</a></h2>
<p>The way that RuggRogue runs on the web is by telling Cargo (Rust's main build tool) to build for the <code>wasm32-unknown-emscripten</code> target.
If we ignore the <code>unknown</code>, <code>wasm32</code> is the target architecture (this would be something like <code>x86_64</code> for native), while <code>emscripten</code> is the target OS (that's <code>linux</code> if I build the game natively for myself).
<code>wasm32</code> is the 32-bit flavor of <a href="https://webassembly.org/">WebAssembly</a>, which is a machine-code-like binary format that web browsers can run in a sandbox as an alternative to JavaScript.
But WebAssembly can only muck about with memory and numbers; it has to call <em>host functions</em> to do interesting things, e.g. JavaScript functions in a web browser.</p>
<p>This is where <a href="https://emscripten.org/">Emscripten</a> comes in.
Emscripten provides a whole bunch of host functions that make a WebAssembly blob believe it's running in a classic desktop-like environment.
For example, Emscripten provides POSIX-like file system APIs that enable the same file system code to compile and run unmodified in a web browser as it does natively.
Critically for RuggRogue, Emscripten implements the SDL API, so the windowing, input event handling and rendering all work in a web browser with minimal changes.
When Emscripten works, it's like magic.</p>
<p>But Emscripten's magic is imperfect.
A part of it is differences imposed by the browser environment that Emscripten operates in.
In a native application, processes automatically share access to the CPU due to pre-emptive multi-processing managed by the operating system.
In a browser, a tab has a single main thread, and if, say, a game runs its own main loop that never yields control back to the tab, that tab will just lock up.
A game that wants to run in a tab can't have a real main loop.
Instead, it has to be adapted to run just a single iteration of its main loop, and have Emscripten yield control to the browser.
Emscripten then runs this loop at around 60 FPS on the game's behalf.
So everything is good, right?</p>
<p>Unfortunately, RuggRogue has a special requirement for its own game loop.
When RuggRogue isn't handling an input event or animating something, it waits for an event, acting more like a GUI program than a game.
I pored over a lot of documentation, but for the life of me I could not find a good way to get Emscripten to support this kind of execution flow.
In order for RuggRogue to keep its own game loop while running in a browser tab without locking it up, I had to reach for a transformation known as <a href="https://emscripten.org/docs/porting/asyncify.html">Asyncify</a>.
The link explains what it does better than I can here.
Sadly, it's a pretty invasive transformation with a high CPU cost, but it allows CPU savings to occur when the player is idle, so it's still a net win.</p>
<p>Asyncify saves CPU by substituting <code>sleep</code> calls that RuggRogue makes during its main loop with the browser's <a href="https://developer.mozilla.org/en-US/docs/Web/API/setTimeout">setTimeout</a> JavaScript function.
But there's a problem: RuggRogue relies on fine-grained <code>sleep</code> calls for smooth gameplay, but <a href="https://developer.mozilla.org/en-US/docs/Web/API/setTimeout#reasons_for_delays_longer_than_specified">setTimeout has delays</a> when called repeatedly in a deep call stack.
It just so happens that the Asyncify transformation leads to very deep call stacks.
The result?
RuggRogue suffers unavoidable stutter in the web version.
There's no way around it without redoing its approach to web support entirely.</p>
<p>As well as the stutter, Emscripten is tricky to use with Rust in general.
In particular, it relies on the output format of <a href="https://llvm.org/">LLVM</a> tools.
These formats are <em>not</em> stable across versions, so Emscripten relies on the most recent revision of LLVM at the time of development.
Meanwhile, Rust runs its own version of LLVM which is <em>not</em> the most recent revision of LLVM at any given time.
In order to correctly build a program with Rust and Emscripten, they usually have to use matching LLVM versions.
The LLVM version used by Rust can be found using <code>rustc --version --verbose</code>, but I couldn't find how to do the same for Emscripten anywhere I searched.
The use of version <strong>1.39.20</strong> is from <a href="https://web.archive.org/web/20210618192808/https://blog.therocode.net/2020/10/a-guide-to-rust-sdl2-emscripten">Therocode's blog</a>, who I can only assume did a deep dive into the release histories of Emscripten and LLVM to discover the version number.
Using the newest version of Emscripten with Rust will likely not work.</p>
<p>I would strongly consider taking the extra time to learn <a href="https://rustwasm.github.io/docs.html">Rust and WebAssembly</a> without the Emscripten bit in the future.
I don't know if it would have gained results any quicker, but it seems like it would have dodged a lot of the headaches mentioned above.</p>
<h2 id="the-migrated-off-of-piston"><a class="header" href="#the-migrated-off-of-piston">The Migrated Off Of: Piston</a></h2>
<p>RuggRogue did not begin life as an SDL game; it began life as a Piston game.
<a href="https://crates.io/crates/piston">Piston</a> is one of the earliest Rust game engines that existed, if not the earliest.
I initially chose it because it seemed like the only game engine that would let me write my own game loop, and because I didn't know any better.</p>
<p>RuggRogue no longer uses Piston.
Using Piston to draw a grid of characters onto the screen in the most obvious way led to extremely poor performance.
Trawling through documentation spread out across Piston's many sub-crates did not reveal any way to improve performance, so eventually it was just dropped entirely.
Switching from Piston to plain SDL both drastically dropped the compile time and boosted the performance of RuggRogue by <em>a lot</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="source-code-layout"><a class="header" href="#source-code-layout">Source Code Layout</a></h1>
<p>RuggRogue comes to about 13,000 lines of source code.
In Rust terms, the entire RuggRogue source code comprises a <em>package</em> made up of two <em>crates</em>: a <em>library crate</em> and a <em>binary crate</em>.
The library crate contains things that RuggRogue needs to function that aren't specific to it as a game.
The binary crate has the game-specific stuff and makes use of the library crate to form the complete game when built.</p>
<h2 id="the-library-crate"><a class="header" href="#the-library-crate">The Library Crate</a></h2>
<p>Some people consider SDL to be a game engine, but what it provides is so low-level that it's really more of a layer to build a game engine on top of.
RuggRogue's library crate is effectively a small, custom game engine for RuggRogue the game.
It also has some utilities that are useful to RuggRogue as a roguelike, but are otherwise independent of the game itself.</p>
<p>The library crate lives in <code>src/lib/</code>, and is made up of the following files:</p>
<ul>
<li><code>src/lib/lib.rs</code> - The &quot;crate root&quot; of the library crate, in Rust terms, that pulls together all of the other files that make up the library crate.</li>
<li><code>src/lib/field_of_view.rs</code> - Field of view calculation.</li>
<li><code>src/lib/input_buffer.rs</code> - A first-in-first-out queue of simplified input events translated from SDL input events, consumed by the game proper.</li>
<li><code>src/lib/path_find.rs</code> - A* path finding algorithm that monsters use to pursue the player.</li>
<li><code>src/lib/run.rs</code> - Window initialization and the main game loop.</li>
<li><code>src/lib/tilegrid.rs</code> - A pixel-perfect tile grid implementation, used to render everything that shows up on screen; this is the biggest source code file in the game!</li>
<li><code>src/lib/util.rs</code> - Contains small utility structs, namely <code>Color</code>, <code>Position</code> and <code>Size</code>.</li>
<li><code>src/lib/word_wrap.rs</code> - Word wrapping algorithm that splits a long string into lines of at most a given number of characters.</li>
</ul>
<p>In theory, the existence of this library crate means that other Rust projects could make use of it.
In practice, it might be tricky, since I only included enough features to make RuggRogue functional.
Faced with the task of writing my own game engine, my guiding principle was to never write code I didn't have an immediate use for.
Unused code is untested code, and untested code is buggy code.</p>
<h2 id="the-binary-crate"><a class="header" href="#the-binary-crate">The Binary Crate</a></h2>
<p>The binary crate contains all of the logic that is specific to RuggRogue as a game.
The top-level <code>src/</code> directory is a melting pot of different things:</p>
<ul>
<li><code>src/main.rs</code> - The crate root of the binary crate that pulls together the rest of the files listed below, with the entry point of the game that sets everything up and launches the game loop.</li>
<li><code>src/bitgrid.rs</code> - Holds <code>BitGrid</code>, a struct used to track map tiles revealed by the player, as well as which tiles are contained in the fields of view of entities.</li>
<li><code>src/chunked.rs</code> - Holds <code>ChunkedMapGrid</code>, a struct that handles a <a href="https://wiki.c2.com/?DirtyRectangles">dirty rectangles</a> drawing scheme to avoid having to repeatedly redraw large portions of the map on screen.</li>
<li><code>src/components.rs</code> - Definitions of component structs, which are data associated with entities.</li>
<li><code>src/damage.rs</code> - Damage calculations and handling of dead entities.</li>
<li><code>src/experience.rs</code> - Experience and difficulty tracking, as well as the definition of how combat stats relate to experience level values.</li>
<li><code>src/gamekey.rs</code> - Translation of SDL key values into game-specific action keys.</li>
<li><code>src/gamesym.rs</code> - Symbolic representation of tile appearances and their ASCII equivalents, as well as a hard-coded mapping for the tileset used by the game.</li>
<li><code>src/hunger.rs</code> - Hunger and regeneration tracking.</li>
<li><code>src/item.rs</code> - All item-related functionality and book-keeping, along with handling of item-inflicted status effects.</li>
<li><code>src/magicnum.rs</code> - Arbitrary values used to help seed the different random number generators created in other places in the source code.</li>
<li><code>src/map.rs</code> - Holds the <code>Tile</code> and <code>Map</code> structs, handles map generation and maintenance of a tile-based spatial cache for performance.</li>
<li><code>src/menu_memory.rs</code> - Holds a <code>MenuMemory</code> struct that remembers the last position of the cursor in various menus.</li>
<li><code>src/message.rs</code> - The message buffer.</li>
<li><code>src/monster.rs</code> - Monster turn handling and AI.</li>
<li><code>src/player.rs</code> - Player input and turn handling, as well as auto-run logic.</li>
<li><code>src/render.rs</code> - Drawing of entities on the map.</li>
<li><code>src/saveload.rs</code> - Everything to do with saving the game to and loading a game from a save file.</li>
<li><code>src/spawn.rs</code> - Spawning and despawning of all entities, including filling map rooms with spawns, along with monster, weapon and armor appearances.</li>
<li><code>src/ui.rs</code> - Arrangement and drawing of the main game interface, i.e. the map, sidebar and messages.</li>
<li><code>src/vision.rs</code> - Updates fields of view for entities that have one and need it updated.</li>
</ul>
<p>You'll also notice the <code>src/modes/</code> directory.
This is the home of what I call the <em>mode stack</em> as well as the <em>modes</em> that go on it.
There'll be more on this later on, but modes represent screens, menus and dialogs, while the mode stack determines what modes appear on screen and which one updates at any given time.
The files in <code>src/modes/</code> consist of:</p>
<ul>
<li><code>src/modes/mod.rs</code> - The Rust sub-module that pulls together the individual mode files, as well as holding the mode stack logic.</li>
<li><code>src/modes/app_quit_dialog.rs</code> - Confirmation dialog when the player tries to close the window in the native build of the game.</li>
<li><code>src/modes/dungeon.rs</code> - The main gameplay screen that drives the core gameplay loop and pulls all of the game logic together.</li>
<li><code>src/modes/equipment_action.rs</code> - Menu of actions that can be performed when selecting an equipped item.</li>
<li><code>src/modes/equipment_shortcut.rs</code> - Quick hotkey-reachable menu to remove or drop an equipped item without having to go through the inventory.</li>
<li><code>src/modes/game_over.rs</code> - The game over and victory screens.</li>
<li><code>src/modes/inventory.rs</code> - The inventory menu.</li>
<li><code>src/modes/inventory_action.rs</code> - Menu of actions that can be performed when selecting an inventory item.</li>
<li><code>src/modes/inventory_shortcut.rs</code> - Quick hotkey-reachable menu to perform an action on an item without having to go through the inventory.</li>
<li><code>src/modes/message_box.rs</code> - A simple message box.</li>
<li><code>src/modes/options_menu.rs</code> - The options menu where settings can be changed.</li>
<li><code>src/modes/pick_up_menu.rs</code> - Menu of items that the player can pick up at their current map position.</li>
<li><code>src/modes/target.rs</code> - A screen that allows the player to choose a target position when they use an item that needs a target.</li>
<li><code>src/modes/title.rs</code> - The title screen.</li>
<li><code>src/modes/view_map.rs</code> - A screen that lets the player move the camera around and describe map positions.</li>
<li><code>src/modes/yes_no_dialog.rs</code> - A simple yes-or-no dialog.</li>
</ul>
<h2 id="assets"><a class="header" href="#assets">Assets</a></h2>
<p>The <code>assets/</code> directory has files loaded by the game at runtime:</p>
<ul>
<li><code>assets/gohufont-8x14.png</code> - A PNG of <a href="https://en.wikipedia.org/wiki/Code_page_437">IBM Code Page 437</a> rendered with <a href="https://font.gohu.org/">GohuFont</a>, the default font of the game.</li>
<li><code>assets/terminal-8x8.png</code> - A PNG of IBM Code Page 437 rendered with a smaller 8-by-8 pixel font that came from the <code>resources.zip</code> of the <a href="https://bfnightly.bracketproductions.com/chapter_1.html#hello-rust---rltk-style">Rust Roguelike Tutorial</a>.</li>
<li><code>assets/urizen/urizen-onebit-tileset-mono.png</code> - A custom black-and-white version of one of the tileset images from the <a href="https://vurmux.itch.io/urizen-onebit-tilesets">Urizen 1Bit Tilesets by vurmux</a>.</li>
<li><code>assets/urizen/readme.txt</code> - Description of my changes to the Urizen tileset image.</li>
<li><code>assets/urizen/LICENSE</code> - License text for Urizen 1Bit Tilesets.</li>
</ul>
<h2 id="everything-else"><a class="header" href="#everything-else">Everything Else</a></h2>
<p>There's a bunch of non-Rust or not-quite-Rust files that can also be found in the source code:</p>
<ul>
<li><code>BUILD.md</code> - Instructions for building RuggRogue from source.</li>
<li><code>Cargo.toml</code> - RuggRogue's package metadata that describes the source code structure and dependencies and is used by Cargo to build the game.</li>
<li><code>.cargo/config.toml</code> - Extra Cargo configuration for building the web version of the game.</li>
<li><code>clippy.toml</code> - Settings for Clippy, Rust's source code linter.</li>
<li><code>index.html</code> - HTML page that hosts the web version of the game.</li>
<li><code>LICENSE.md</code> - License text for RuggRogue.</li>
<li><code>README.md</code> - Basic information about RuggRogue.</li>
<li><code>ruggrogue.js</code> - Support JavaScript needed for the web version of the game.</li>
</ul>
<p>Finally, there's <code>book.toml</code> and the <code>book/</code> directory, which is the very book you are reading right now!
If you have the RuggRogue source code, you can install <a href="https://crates.io/crates/mdbook">mdbook</a> and run <code>mdbook build --open</code> for your very own local copy.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overall-game-flow"><a class="header" href="#overall-game-flow">Overall Game Flow</a></h1>
<p>The overall flow of the game can be divided into three main parts:</p>
<ol>
<li>initialization</li>
<li>the main game loop</li>
<li>the mode stack that the main game loop continuously updates</li>
</ol>
<p>We'll look at each of these in turn.</p>
<h2 id="initialization"><a class="header" href="#initialization">Initialization</a></h2>
<p>The <code>main</code> function in <code>src/main.rs</code> is where it all begins.
One of the most important things initialized is the <em>world</em>, courtesy of the Shipyard crate, whose sole purpose is to store and provide access to all game-related data.
There's a bunch of calls to <code>world.add_unique</code> to add <em>uniques</em>, which are the closest thing the game has to global variables.
&quot;Uniques&quot; are Shipyard's term for &quot;resources&quot;, which is the term used by other Rust ECS crates such as <a href="https://crates.io/crates/specs">Specs</a>, <a href="https://crates.io/crates/legion">Legion</a> and <a href="https://crates.io/crates/bevy_ecs">bevy_ecs</a>.
In any case, the uniques that RuggRogue adds to its world are a mix of essential and dummy data.
Inserting dummy data now means it can be replaced unconditionally later, simplifying that code.</p>
<p>The most important thing initialized is the <em>mode stack</em>, which is initialized with a mode representing the title screen.
The mode stack deserves its own section, so that will be covered later; just keep it in mind for now.</p>
<p>The final bit of initialization in the <code>main</code> function is <code>RunSettings</code>, which controls the behavior of the <code>ruggrogue::run</code> function that launches the main loop of the game.
Alongside the basic window settings and frames per second is the <code>tileset_infos</code> field.
If you want to add new tilesets and fonts, this is where they're added.
The game's option menu assumes that fonts come before tilesets.
Note that if you add or remove fonts, you'll want to change the <code>NUM_FONTS</code> constant in <code>src/modes/options_menu.rs</code> to match your changes.
If you want to add a tileset, check out the <code>urizen_tileset_info</code> function in <code>src/gamesym.rs</code> for an example of how to map display symbols to tiles.</p>
<p>At the end of the <code>main</code> function is a call to <code>ruggrogue::run</code> that launches the main game loop with a callback that continuously updates the aforementioned mode stack.</p>
<h2 id="the-main-game-loop"><a class="header" href="#the-main-game-loop">The Main Game Loop</a></h2>
<p>The main game loop lives in the <code>run</code> function that can be found in <code>src/lib/run.rs</code>.
Note that we've gone from the binary crate to the library crate at this point.
We can start the game loop now, right?</p>
<p>I lied, there's more initialization.
This initialization is a lot more technical than the stuff that <code>main</code> was setting up before.
Most of the initialization here is to use SDL to prepare a window, a canvas representing the drawable area of that window and an event pump, which is how the game can react to player inputs and window resizing.</p>
<p>Beyond SDL, the <code>layers</code> variable is noteworthy.
It's a vector of <code>TileGridLayer</code>s, which in turn are vectors of <code>TileGrid</code>s.
Everything that appears on screen does so via this structure; it can be thought of as a hand-rolled scene graph.
<code>TileGrid</code>s and <code>TileGridLayer</code>s will be covered in more detail in a later chapter.</p>
<p>Alright, we can finally move onto the game loop proper, that is, everything inside <code>while !done { ... }</code>.
The game loop is modelled directly from the one described under &quot;Play catch up&quot; in the <a href="https://gameprogrammingpatterns.com/game-loop.html#play-catch-up">Game Programming Patterns book</a>.
The idea of this kind of game loop is that you think of wall clock time as producing a resource that is repeatedly consumed in fixed amounts by running the update logic.
However, it's heavily adapted to the needs of RuggRogue, which are kind of unusual compared to a conventional video game.</p>
<p>The biggest thing I wanted to avoid with RuggRogue was constantly spending CPU time running update logic when there was nothing to update.
I didn't want RuggRogue to turn the player's laptop into a hand warmer because they left the game window open while doing something else.
In this respect, RuggRogue's game loop is closer to that of a GUI program than a video game.
This sole requirement unfortunately rules out the use of almost every single Rust game engine, including <a href="https://crates.io/crates/bracket-lib">bracket-lib</a> and <a href="https://bevyengine.org/">Bevy</a> (at least in its current pre-editor state).
Virtually all of the Rust game engines out there have their own game loop that they want you to use, with no way to tell it to wait for an event before updating again.
To be honest, I wasn't intending to write my own game engine for RuggRogue, but this one requirement kind of forced me into it, and the rest is history.</p>
<p>There are two parts to making RuggRogue wait for input when needed: the <code>active_update</code> flag and the <code>RunControl</code> enum.
When <code>active_update</code> is true, updates are continuously requested at the desired FPS rate, and when it's <code>false</code> it'll wait for an event before updating instead.
The <code>active_update</code> flag is initially set, since the game needs to update at least once in order to draw the title screen.
The <code>RunControl</code> enum found at the top of <code>src/lib/run.rs</code> is how updates tell the game loop to set the <code>active_update</code> flag.
Every update function from the main gameplay to the smallest dialog returns one of the variants of <code>RunControl</code>.
Anything that finishes its work in a single frame returns <code>RunControl::WaitForEvent</code>, such as the player moving a single step or moving a menu cursor.
Things that require repeated updates instead return <code>RunControl::Update</code>, such as the player auto-running along a corridor or resting until healed.
<code>RunControl::Quit</code> is only returned when the mode stack empties out, which means there's nothing left to update or show on screen.</p>
<p>If you're reading the code, you may wonder why there's a big <code>if</code> with two whole branches that run the <code>update</code> callback.
This is to ensure correct time book-keeping when going back and forth between active and and inactive updating.
For example, say that there's an update, then the player waits for ten seconds before pressing a key that triggers active updates.
If the game is set to run at 30 FPS with active updates, this would trigger 300 catch-up updates without special handling!</p>
<h2 id="the-mode-stack"><a class="header" href="#the-mode-stack">The Mode Stack</a></h2>
<p>I've hinted at this idea of a &quot;mode stack&quot; before, so it's time to go into it in more detail.
The idea of a <em>mode</em> is a unit of state with associated update and drawing logic that has exclusive, or <em>modal</em> (hence the name), access to update and control logic at any given time.
The game has a single <em>mode stack</em> that houses all of the modes, drawing all of the modes in their stacked order while updating only the top mode.</p>
<p>At this point, you might be thinking,
&quot;Hey, wait a minute, isn't this just a <em>game state stack</em>?
Why come up with a different name for something everybody else has already settled on?&quot;
Indeed, you'll get a lot more useful results from search engines if you type &quot;game state stack&quot; instead of whatever the heck I'm calling it.
However, I didn't come up with a different name for no reason.
There is a dizzying amount of writing about game development on the Internet that goes over how to do different things, but in very similar and easy-to-confuse terms.
&quot;State&quot; is one of those words that means slightly different things to different people.
&quot;State&quot; refers to the pattern of bits in memory and allocated resources, but &quot;state&quot; is also a computer science concept for finite state machines.
Using different names for different ideas makes thinking about complex problems easier, and I refer to &quot;modes&quot; instead of &quot;states&quot; here for this reason.
My original inspiration for this approach comes from <a href="https://web.archive.org/web/20160306054512/http://director-online.dasdeck.com/buildArticle.php?id=1134">&quot;The <em>Interface</em> Stack Model&quot;</a> (emphasis mine), but &quot;interface&quot; is unfortunately already a term used in object-oriented programming.
This approach is also somewhat similar to <a href="https://gameprogrammingpatterns.com/state.html#pushdown-automata">&quot;Pushdown Automata&quot;</a> from the Game Programming Patterns book.
Anyway, enough about names, you can substitute &quot;mode&quot; with &quot;state&quot; and everything here should still make sense.</p>
<p>If RuggRogue is a living being, the main game loop would be its heart, pumping updates, while the mode stack would be its brain, deciding how to react to inputs and what gets drawn on screen.
The mode stack can be found near the bottom of <code>src/modes/mod.rs</code>, which is back in the binary crate.
This might seem strange; surely something as general as this mode stack belongs in the library crate instead, right?
However, my experience on this game says otherwise.
The original mode stack was much simpler than the one that exists in the game code now.
I treated it as a living, breathing thing and evolved it to suit the needs of the game, and you can't really put something that constantly evolves into a library that presents a stable interface.
The mode stack must be game code, not library code.</p>
<p>The mode stack is represented by the <code>ModeStack</code> struct (surprise), which is just a vector of <code>Mode</code> structs, along with a single <code>ModeStack::update</code> function.
The <code>ModeStack::update</code> function more or less does the following:</p>
<ol>
<li>Call <code>Mode::prepare_grids</code> on all of the modes in the stack to create and position tile grids that the modes draw onto.</li>
<li>Call <code>Mode::update</code> on the top mode and catch its result.</li>
<li>React to the returned result if needed, e.g. to push a new mode or pop the top mode.</li>
<li>Call <code>Mode::draw</code> on all of the modes in the stack to fill in the contents of tile grids that will later be displayed on screen.</li>
</ol>
<p>These mode-related functions exist just above the mode stack code inside the <code>impl Mode</code> block.
The purpose of these functions is to dispatch to the function of the same name in each mode according to its type.
For example, if there's a <code>YesNoDialogMode</code> at the top of the mode stack, <code>ModeStack::update</code> would call <code>Mode::update</code> which in turn would call <code>YesNoDialogMode::update</code>, which can be found in <code>src/modes/yes_no_dialog.rs</code>.
You'll notice that the dispatching code is mostly a copy-paste job; there are a couple of alternatives that would have been much more concise, but I decided against using.
Idiomatic Rust code would have made a <code>Mode</code> trait instead of an enum and relied on dynamic dispatch using <code>Box&lt;dyn Mode&gt;</code>, but having every mode living in different parts of heap memory was something I wanted to avoid for performance reasons.
There's also an <a href="https://crates.io/crates/enum_dispatch">enum_dispatch</a> crate that does what I did by hand automatically, but I didn't want to pull in dependencies for things I could easily write myself.</p>
<p><code>Mode::update</code> returns a 2-tuple of <code>ModeControl</code> and <code>ModeUpdate</code>, whose definitions are just above <code>impl Mode</code> in <code>src/modes/mod.rs</code>.
<code>ModeControl</code> represents what the <code>update</code> function of any given mode wants to have done to the stack, like <code>ModeControl::Switch</code>, <code>ModeControl::Push</code> or <code>ModeControl::Pop</code>.
Note the <code>ModeResult</code> in <code>ModeControl::Pop</code>: every mode is accompanied by a corresponding <em>mode result</em>, e.g. <code>YesNoDialogMode</code> can pop itself off the stack and return either <code>YesNoDialogModeResult::Yes</code> or <code>YesNoDialogModeResult::No</code>.
The next mode whose <code>update</code> function is called will receive this result via its <code>pop_result</code> parameter.
Rust's expressive type system is invaluable for dispatch logic based on types like this.
A lot of articles written about game state stacks gloss over result handling, but it's the difference between a dialog returning something meaningful and just vanishing into thin air, so if you want proper dialogs and not just inert windows, it's crucial.</p>
<p><code>ModeUpdate</code> determines what should happen after <code>ModeStack::update</code> is done.
<code>ModeUpdate::Update</code> and <code>ModeUpdate::WaitForEvent</code> correspond to active and inactive-style of main game loop updating described earlier.
You may have noticed the <code>while</code> loop surrounding most of the code in <code>ModeStack::update</code>; <code>ModeUpdate::Immediate</code> exists solely as a fallthrough case to repeat that loop.
<code>ModeUpdate::Immediate</code> is used to make the next mode's <code>update</code> function run in the <em>current</em> frame instead of the next.
This is useful to handle the result of a dialog straight away when it closes instead of lagging for a frame.</p>
<p>One last detail I left out is <code>Mode::draw_behind</code>.
Remember how modes represent screens as well as menus and dialogs?
There's no need to draw behind a mode that covers the entire screen, so <code>Mode::prepare_grids</code> and <code>Mode::draw</code> are skipped for other modes behind fullscreen modes like this, and <code>Mode::draw_behind</code> is what decides if a mode is fullscreen.</p>
<p>If you want an example of a simple mode, the simplest one can be found in <code>src/modes/yes_no_dialog.rs</code>.
The most important mode is probably <code>DungeonMode</code>, which represents the main gameplay screen and handles player and monster turn distribution; this can be found in <code>src/modes/dungeon.rs</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event-handling"><a class="header" href="#event-handling">Event Handling</a></h1>
<p>As a game, it's crucial for RuggRogue to react to <em>events</em>.
The most important events are the key presses of the player playing the game, but there are other kinds that need to be handled too, like window resizing, mouse inputs and attempts to close the game window.
This chapter will talk about where events come from and how the game responds to them.</p>
<h2 id="receiving-events"><a class="header" href="#receiving-events">Receiving Events</a></h2>
<p>Our journey begins in the <code>ruggrogue::run</code> function in the <code>src/lib/run.rs</code> file.
The <code>sdl2</code> crate provides what's called an <em>event pump</em>, which is the source of all events that the game will see.
This event pump is stored in the aptly-named <code>event_pump</code> variable so that the main game loop can pull events out of it with its <code>wait_event</code> and <code>poll_iter</code> methods.</p>
<p>Each event from the event pump is handled in two phases:</p>
<ol>
<li>Do things that need to be handled straight away.</li>
<li>Enqueue the event in an input buffer so that it can be handled later during a proper game tick.</li>
</ol>
<p>Some events are directly handled only and aren't enqueued, such as window resizing and mouse inputs.
On the other hand, key press events have a little bit of direct handling before being enqueued for the game logic to handle them properly later.
Events that the game doesn't care about are simply ignored.</p>
<h2 id="direct-event-handling"><a class="header" href="#direct-event-handling">Direct Event Handling</a></h2>
<p>There are three kinds of events that are handled directly in the game's main loop: window resizing, mouse inputs and a couple of rendering-related events.</p>
<p>Window resize events update the <code>window_size</code> variable in the main loop with the new window size.
This is later sent into the <code>update</code> callback that was given to the <code>ruggrogue::run</code> function so that the updating and drawing logic are always aware of the size of the game window.
The updating logic in particular needs this info so that menus know how far to scroll when pressing the page up and page down keys.</p>
<p>The game hides the mouse cursor in response to key presses; mouse input events reveal it again.
These include mouse movement, mouse button presses and mouse wheel movement.</p>
<p>The two rendering-related events that need direct handling are both things that can happen on Windows with DirectX being used as the graphics backend for SDL:</p>
<ul>
<li><code>sdl2::event::Event::RenderTargetsReset</code> happens when graphical texture data needs to be updated.</li>
<li><code>sdl2::event::Event::RenderDeviceReset</code> happens when textures have been lost and need to be recreated entirely.</li>
</ul>
<p>In both cases the game will flag its graphics-related data to do the right thing the next time that they need to be drawn to the screen.</p>
<h2 id="the-input-buffer"><a class="header" href="#the-input-buffer">The Input Buffer</a></h2>
<p>Once any direct handling is done, the event may be added to the <em>input buffer</em>.
The game logic will almost always run less often than the main loop, so the purpose of the input buffer is to save events from the main loop so that the game logic can react to them later.</p>
<p>The <code>inputs</code> variable in the <code>ruggrogue::run</code> function holds the input buffer.
This is an <code>InputBuffer</code> struct that enqueues mainly keyboard events when its <code>InputBuffer::handle_event</code> function is called with an event.</p>
<p>The <code>InputBuffer</code> struct is defined in the <code>src/lib/input_buffer.rs</code> file.
When the game logic wishes to check for input events, it follows these steps:</p>
<ol>
<li>The game logic calls the <code>InputBuffer::prepare_input</code> function to retrieve a single input event from the buffer.</li>
<li>The game logic calls the <code>InputBuffer::get_input</code> function to check the prepared input event.</li>
<li>The end of the game loop calls the <code>InputBuffer::clear_input</code> function to make way for the next call to the <code>InputBuffer::prepare_input</code> function.</li>
</ol>
<p>The events stored in the <code>InputBuffer</code> struct are a stripped-down form of SDL's events in the form of small <code>InputEvent</code> enums that mainly hold SDL key codes that are unique for each keyboard key.
As <code>InputEvent</code>s are pulled from the <code>InputBuffer</code>, the <code>InputBuffer</code> tracks the press state of the <em>modifier keys</em> (i.e. <code>Shift</code>, <code>Ctrl</code> and <code>Alt</code>) that the game logic can read using the <code>InputBuffer::get_mods</code> function.</p>
<p>The game logic will typically combine the prepared input and modifier key state into a logical <em>game key</em>, represented by the <code>GameKey</code> enum defined in the <code>src/gamekey.rs</code> file.
The <code>gamekey::from_keycode</code> function in that file translates the SDL key code values into logical game key values.
Note that multiple key codes can translate into a single game key, e.g. the up cursor key, <code>8</code> on the number pad and <code>k</code> all translate into the <code>GameKey::Up</code> value.</p>
<h2 id="player-input-logic"><a class="header" href="#player-input-logic">Player Input Logic</a></h2>
<p>Every game mode pulls inputs from the input buffer, but the most important of these modes is <code>DungeonMode</code>.
The <code>DungeonMode::update</code> function defined in the <code>src/modes/dungeon.rs</code> file is the central place that drives player and monster turns.
Player inputs are handed off from this function to the <code>player::player_input</code> function defined near the bottom of the <code>src/player.rs</code> file.</p>
<p>Under normal circumstances, where the player is not asleep or auto-running, the <code>player::player_input</code> function will prepare, retrieve and translate an input event into a game key.
How each game key is handled falls into one of three categories:</p>
<ol>
<li><em>Movement</em> - Move the player or melee attack an adjacent enemy with the <code>try_move_player</code> helper function.</li>
<li><em>Wait in place</em> - Cause the player to wait a single turn with the <code>wait_player</code> helper function.</li>
<li><em>Anything else</em> - Return a value that the <code>DungeonMode::update</code> function should handle instead, usually by manipulating the mode stack to show a dialog or menu.</li>
</ol>
<p>The return value of the <code>player::player_input</code> function is a <code>PlayerInputResult</code> enum variant whose definition is found near the top of the <code>src/player.rs</code> file.
The most important values are <code>PlayerInputResult::NoResult</code> and <code>PlayerInputResult::TurnDone</code>, which control whether or not the <code>DungeonMode::update</code> function should finish the player's turn and advance time.
Valid player actions will typically alter the world state during the <code>player::player_input</code> function call and then cause it to return the <code>PlayerInputResult::TurnDone</code> value.</p>
<h2 id="the-appquit-event"><a class="header" href="#the-appquit-event">The <code>AppQuit</code> Event</a></h2>
<p>In the native build of RuggRogue, when the player attempts to close the game window, the <code>sdl2</code> crate emits the <code>sdl2::event::Event::Quit</code> event.
This is translated into an <code>InputEvent::AppQuit</code> event that gets inserted into the <code>InputBuffer</code> in the <code>InputBuffer::handle_event</code> function.
This means that every place in the game logic that checks for input must also respond to this <code>InputEvent::AppQuit</code> event.
Responses fall into one of three categories:</p>
<ol>
<li>Most modes pop themselves off the mode stack and return an <code>AppQuit</code> result, e.g. a <code>FooMode::update</code> function returns a <code>FooModeResult::AppQuit</code> result.</li>
<li><code>DungeonMode</code> pushes an instance of <code>AppQuitDialogMode</code> (defined in the <code>src/modes/app_quit_dialog.rs</code> file) to show a save-and-exit confirm dialog; it also does this if any mode on top of it in the mode stack returns its own <code>AppQuit</code> result.</li>
<li><code>AppQuitDialogMode</code> ignores <code>AppQuit</code> events while waiting for the player to pick a response.</li>
</ol>
<p>The combined effect of these responses will either quit the game outright (by emptying out the mode stack) or show a save-and-exit confirm dialog if the player is in the middle of playing the game (the <code>DungeonMode</code> catches <code>AppQuit</code> events and mode results to show the dialog).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rendering"><a class="header" href="#rendering">Rendering</a></h1>
<p>This chapter is about how RuggRogue uses SDL to display things on the screen.
This will cover the game's overall rendering strategy, the use of tile grids to organize what's displayed, tilesets, the overarching phases involved in displaying things and finally a couple of strategies to improve drawing performance.</p>
<h2 id="rendering-strategy"><a class="header" href="#rendering-strategy">Rendering Strategy</a></h2>
<p>For a 2D tile-based roguelike game such as RuggRogue, there are two common strategies to getting pixels onto the screen when considering modern video hardware.
There's <em>software rendering</em>, where the CPU decides what each pixel on screen should look like, then uploads the whole screen as a texture for the GPU to ultimately display.
This is simple, but slow, especially considering that the CPU also has to deal with game logic.
On the other hand, there's the <em>hardware rendering</em> approach using <em>texture atlasses</em>, where tilesets are uploaded for the GPU in advance and the CPU feeds data buffers that describe where said tiles should be displayed on screen for the GPU.
This is much faster than the software approach, but a fair bit more complex, on top of of requiring an API that can create graphics pipelines with custom shaders.</p>
<p>Instead of either of those things, RuggRogue adopts a <em>hybrid rendering</em> strategy that combines elements of both software and hardware rendering.
The game breaks down what it wants to display on screen into tile grids whose contents are rendered by the CPU in a software rendering fashion.
It then uses SDL's drawing API to arrange those tile grids on screen, which is aware of video hardware and thus makes up the hardware rendering portion of the strategy.</p>
<p>So why hybrid rendering?
Early in development, RuggRogue rendered its grids by drawing the background of each cell as a colored rectangle, followed by the contents of the cell in the foreground color.
This approach was unplayably slow, to the point that transitioning to pure software rendering was a noticeable performance improvement.
The source of this slowness is the approach to drawing used by many 2D graphics libraries and game engines that advertise &quot;hardware-accelerated graphics&quot;.
These libraries and engines provide ad-hoc drawing APIs where, at any time, the CPU can tell the GPU to draw something.
This approach is known as <em>immediate mode drawing</em>, which is impossible for accelerated graphics hardware to handle quickly.
Any 2D drawing API that doesn't use or allow the creation of a graphics pipeline to feed data into shaders will be slow in this way.
SDL's bundled drawing API, like many others, falls in this performance pit.
SDL provides an OpenGL escape hatch, but OpenGL is its own can of worms that I didn't feel like dealing with when I just wanted to get things on screen fast.</p>
<p>SDL's immediate mode drawing approach isn't useless though.
SDL's drawing API in general avoids the complexity of graphics APIs that require the creation of full-blown graphics pipelines, shader compilation and linking.
It also only really suffers performance issues when it's used to draw a lot of small things; it's actually quite fast when drawing a few large things instead.
In RuggRogue, these large things are tile grids, and this is how the hybrid rendering strategy came to be.
It's probably not as fast as a proper graphics pipeline, but it's much simpler to put together.
It also separates the drawing of the contents of a tile grid from where and how it's shown on screen, which makes drawing and arranging tile grids on screen easier.</p>
<p>Just before diving into the rest of this, there a couple of SDL-specific things to keep in mind.
SDL's drawing API stores image data in two ways: surfaces and textures.
An SDL surface is an image buffer in RAM that the CPU can render into.
An SDL texture is image data that exists in video hardware that the GPU can sample from and display on screen.
RuggRogue uses both of these things, typically by rendering into an SDL surface and uploading its contents into an SDL texture for display.</p>
<h2 id="tile-grids"><a class="header" href="#tile-grids">Tile Grids</a></h2>
<p>As you may have guessed, a tile grid is a grid of tiles (surprise).
Everything that RuggRogue displays is a tile grid, from the main gameplay screen and sidebar to the smallest dialog.
There are three parts to the tile grid system: tile grid layers that hold tile grids, tilesets and the tile grids themselves.</p>
<h3 id="tile-grid-layers"><a class="header" href="#tile-grid-layers">Tile Grid Layers</a></h3>
<p><code>TileGridLayer</code> can be found at the bottom of <code>src/lib/tilegrid.rs</code>.
Its definition is rather boring: a vector of tile grids along with a drawing-related flag.
What matters more is its purpose and usage.
A <code>TileGridLayer</code> represents all of the tile grids that belong to a specific mode in the mode stack.
The main game loop (in the <code>run</code> function in <code>src/lib/run.rs</code>) composes tile grid layers into a vector stored in the <code>layers</code> variable.
The mode stack (at the bottom of <code>src/modes/mod.rs</code>) receives the <code>layers</code> vector and is responsible for ensuring that each of its modes gets a corresponding <code>TileGridLayer</code>.
The mode stack also sets the <code>draw_behind</code> flag that the main game loop later uses to determine the bottom-most visible <code>TileGridLayer</code> whose tile grids should be displayed on screen.
In this way, the <code>layers</code> variable in the main game loop is effectively the game's scene graph.</p>
<h3 id="tilesets"><a class="header" href="#tilesets">Tilesets</a></h3>
<p>Tilesets are represented by the appropriately-named <code>Tileset</code> struct that can be found towards the top of <code>src/lib/tilegrid.rs</code>.
Tilesets hold image data representing individual tiles that are drawn into tile grid buffers.
Tilesets perform three main tasks:</p>
<ol>
<li>Loading and storing tile image data for quick rendering later.</li>
<li>Converting tile image data into grayscale to enable recoloring.</li>
<li>Rendering tile image data onto surfaces provided by tile grids themselves.</li>
</ol>
<p>Loading of a tileset is controlled by the <code>TilesetInfo</code> struct near the top of <code>src/lib/tilegrid.rs</code>.
They can be seen in action in the <code>main</code> function in <code>src/main.rs</code>, where they define basic font and tileset information for loading.
The definition of <code>TilesetInfo</code> is well-commented, but the <code>font_map</code> and <code>symbol_map</code> are worth mentioning.
They hold the information needed for tilesets to translate their logical grid cell contents into tile images.</p>
<p>Tile image data is prepared specifically to facilitate fast rendering.
The tileset image is reduced down to only the tiles that the <code>font_map</code> and <code>symbol_map</code> refer to; all other tile image data is discarded after the loading process is done.
In addition, the surviving tile images are arranged as a one-tile-wide surface.
Image data is stored in row-major order, so this arrangement ensures that the different pixel rows of each tile image are as closely packed as possible to minimize cache misses while rendering.</p>
<p>To support recoloring, tile image data is stored in grayscale.
The grayscaling process occurs in the <code>Tileset::transfer_tiles</code> function.
A &quot;grayness&quot; value is calculated from the input image data.
A &quot;grayness&quot; of zero is set to transparent black, while anything else is set to white with &quot;grayness&quot; serving as alpha.</p>
<p>The job of rendering tile image data onto a surface is done by the <code>Tileset::draw_tile_to</code> function.
If you read the source code of this function, you'll notice references to <code>CellSym</code> and <code>text_fallback</code>.
<code>CellSym</code> will be covered in the next section.
<code>text_fallback</code> refers to the <code>Symbol::text_fallback</code> function all the way at the top of <code>src/lib/tilegrid.rs</code>.
<code>Symbol</code> itself is a Rust trait, and the purpose of <code>text_fallback</code> is to provide a font alternative to a game symbol if it doesn't define a graphical tile image.
RuggRogue's fallbacks can be found in the <code>GameSym::text_fallback</code> function in <code>src/gamesym.rs</code>, which is the <code>text_fallback</code> function inside the <code>impl Symbol for GameSym</code> block if you're not used to reading Rust syntax.
Apart from symbol fallback handling, <code>Tileset::draw_tile_to</code> recolors tiles using the SDL-provided <code>set_color_mod</code> function that multiplies the foreground color with the grayscaled tile image data from before.
The rendering proper is handled by calling the SDL-provided <code>blit</code> function, which performs surface-to-surface software rendering.</p>
<h3 id="tile-grids-1"><a class="header" href="#tile-grids-1">Tile Grids</a></h3>
<p>The <code>TileGrid</code> struct defined around the middle of <code>src/lib/tilegrid.rs</code> covers a lot of different responsibilities.
It probably has too many responsibilities and I'd consider splitting it up if I were to do this again, but endless refactoring also means endless game development cycles.
So keep in mind that what I'm about to describe is the state I left it in when I decided that the game eventually needed to be finished and is not necessarily an ideal design.
I'll briefly touch on all of the key players involved before covering how stuff works.</p>
<p>A <code>TileGrid</code> consists of a few major parts:</p>
<ul>
<li>Two <code>RawTileGrid</code> structs: one holds the logical contents of the grid, while the other is the same data from the previous frame.</li>
<li>An SDL surface <code>buffer</code> that holds the grid contents rendered with the tile grid's associated tileset.</li>
<li>An SDL texture that serves as the GPU-side destination of the contents of that buffer.</li>
<li>A <code>TileGridView</code> that describes where and how the tile grid should appear on the screen.</li>
<li>A bunch of dirty flags to avoid redoing work that isn't needed.</li>
</ul>
<p>The <code>RawTileGrid</code> is defined above the <code>TileGrid</code> struct in <code>src/lib/tilegrid.rs</code>.
It holds a grid of <code>Cell</code>s (itself defined above <code>RawTileGrid</code> and not to be confused with the Rust standard library struct) that consist of a <code>CellSym</code>, a foreground color and a background color.
The role of <code>CellSym</code> (defined above <code>Cell</code>) is to hold either a character or a symbol.
This symbol is a non-library type that implements the <code>Symbol</code> trait whose definition is a the top of <code>src/lib/tilegrid.rs</code>.
The <code>Symbol</code> trait is implemented on the game side by the <code>GameSym</code> enum that can be found in <code>src/gamesym.rs</code>.
The purpose of <code>GameSym</code> is to provide distinct symbolic names to tile appearances, such as &quot;Player&quot;, &quot;Ration&quot;, &quot;DownStairs&quot; or &quot;WallNe&quot; (north-east wall corner).
This allows drawing code to use these symbolic names to represent tile appearances in a flexible manner.</p>
<p><code>TileGridView</code> is defined just above <code>TileGrid</code> in <code>src/lib/tilegrid.rs</code>.
It holds the position, size and offset within a bounding box in which its <code>TileGrid</code> owner will be clipped.
The <code>color_mod</code> field alters the color of the whole tile grid at display time, which is mainly used to dim tile grids associated with inactive background modes.
It also holds an integer zoom factor that the options menu can alter to zoom the map and the user interface.</p>
<h2 id="the-rendering-process"><a class="header" href="#the-rendering-process">The Rendering Process</a></h2>
<p>Up until now, I've been using the terms &quot;draw&quot;, &quot;display&quot; and &quot;render&quot; rather loosely.
To make this process easier to understand, I'll switch to these specific terms that describe how a tile goes from being drawn to displayed on screen, in this order:</p>
<ol>
<li><strong>Draw</strong>: Plotting of a character or symbol into a tile grid cell with foreground and background colors.</li>
<li><strong>Render</strong>: Combining tile grid cells and colors with tileset data to produce a pixel appearance in a tile grid's buffer.</li>
<li><strong>Upload</strong>: Uploading a tile grid's rendered buffer into the GPU-accessible texture associated with the tile grid.</li>
<li><strong>Display</strong>: Putting the tile grid on the screen using the information in the <code>TileGridView</code>.</li>
</ol>
<p><strong>Drawing</strong> is the first thing that happens when the game wants something to appear on screen.
Drawing happens through the public functions of <code>TileGrid</code>, such as <code>TileGrid::print</code> and <code>TileGrid::put_sym_color</code>.
These functions are called from the <code>draw</code> functions of modes that can typically be found at the bottom of any of the files in the <code>src/modes/</code> directory.
Map drawing specifically occurs near the bottom of <code>src/chunked.rs</code>; a file that is covered in its own section a bit later.
Entity drawing happens in the deceptively-named <code>src/render.rs</code> file that, despite its name, only handles entity 'drawing' and not 'rendering' in these terms.
The <code>TileGrid</code> drawing functions dispatch to similar functions in <code>RawTileGrid</code> that perform the actual drawing by setting the cell (a character or symbol) along with its foreground and background colors.</p>
<p><strong>Rendering</strong> is how cells are turned into pixel data.
This happens in the <code>TileGrid::render</code> function that is called near the top of <code>TileGrid::display</code> just before that function goes about its business.
Recall the two <code>RawTileGrid</code>s in <code>TileGrid</code>.
The <code>front</code> tile grid holds what the game logic has drawn to the tile grid, while the <code>back</code> tile grid is the same data but from the previous frame.
The <code>TileGrid::render</code> function renders a logical tile into its corresponding buffer location only if the same cell in the <code>front</code> and <code>back</code> grids are visibly different.
If a tile doesn't change, it doesn't get rendered.
The end of <code>TileGrid::render</code> updates the back grid with the contents of the front grid in preparation for the next frame.</p>
<p><strong>Uploading</strong> occurs after rendering to update the contents of the tile grid's GPU-side texture with its CPU-side rendered buffer.
This is the <code>texture.update(...)</code> part of the <code>TileGrid::display</code> function, provided by SDL.</p>
<p><strong>Displaying</strong> the uploaded tile grid texture is, unsurprisingly, the job of the <code>TileGrid::display</code> function.
The main loop all the way over in <code>src/lib/run.rs</code> goes through all of the tile grid layers in its <code>layers</code> vector, and then calls this function on each tile grid in each layer.
The majority of the <code>TileGrid::display</code> function is dedicated to calculating where and how the tile grid should appear and calling <code>canvas.copy(...)</code> to put the tile grid texture on screen.
This is what happens in the straightforward case, but if you read the code in this function you'll notice there's a lot more going on.
Why are there four separate calls to <code>canvas.copy</code>?
In order to understand this, I'm going to need to go into the technique I've used here that I call &quot;wrapped offset rendering&quot;.</p>
<h2 id="improving-rendering-performance-with-wrapped-offset-rendering"><a class="header" href="#improving-rendering-performance-with-wrapped-offset-rendering">Improving Rendering Performance with Wrapped Offset Rendering</a></h2>
<p>When playing RuggRogue, the camera is generally always centered on the player, so when the player moves, the entire view of the map shifts accordingly.
Consider the following scenario.
If the player moves one tile to the right, the player is drawn stationary in the center tile of the tile grid while the entire dungeon is drawn one tile over to the left.
According to our tile grid rendering strategy, the player's tile is in the same place, so they won't need to be rendered again.
However, every single dungeon tile has shifted, so any tile that wasn't next to an identical tile will need to be rendered again, even though it's only the player that really moved.
Rendering multiple shifted dungeon tiles versus a single player tile seems pretty inefficient.
There must be some way to render only the player and their immediate surroundings while avoiding the need to render most of the visible dungeon tiles again.</p>
<p>What if, when the player moves one tile to the right, we <em>offset</em> all drawing one tile to the right internally as well?
This would normally cause drawing in the far right cell columns to overflow, so we need to <em>wrap</em> them over to the now-unused left cell columns instead.
The rendering phase will pick up that the player has moved one tile to the right, while the dungeon map remains stationary.
But the whole point of drawing the player at the center of the screen is, well, to have them centered.</p>
<p>This is where we get clever.
At display time, we <em>undo</em> the offset that was set when drawing, so the player that was drawn a tile over to the right is shifted a tile <em>back</em> to the left, thus recentering everything.
The wrapped column of cells that was drawn in the left column can then be split off and displayed over on the right side, where they were originally intended to be.
Presto!
We only had to render the player and immediate surroundings again, while the rest of the dungeon tiles can be skipped during rendering.
It is this central idea that underpins what I call <em>wrapped offset rendering</em>.</p>
<p>As you can probably guess from the example, wrapped offset rendering is used to reduce the number of dungeon tiles that need to be rendered when the player moves around.
The tile grid representing the dungeon map is given the player's position via its <code>TileGrid::set_draw_offset</code> function, which immediately passes it over to <code>RawTileGrid::set_draw_offset</code>, since the <code>RawTileGrid</code> handles drawing.
The <code>RawTileGrid::index</code> function underpins how all drawing functions 'see' the grid cell storage, and this is where the offset and wrapping are applied to affect drawing operations.
Meanwhile, the rendering process is blind to all of this offset business and renders whatever it sees.</p>
<p>This sets the stage for understanding why <code>TileGrid::display</code> calls <code>canvas.copy</code> (up to) four separate times.
All of the calculations in the lower half of <code>TileGrid::display</code> are to undo the wrapped offset rendering to display everything in the right place.
Only one <code>canvas.copy</code> call is needed if the offset is <code>(0, 0)</code>.
Two <code>canvas.copy</code> calls are needed if exactly one of the x-axis or the y-axis have a non-zero offset.
Finally, four <code>canvas.copy</code> calls are needed if both the x-axis and y-axis have non-zero offsets.
These additional calls take wrapped rows and columns of the grid and put them on the opposite side of the tile grid at display time, all in the name of reducing tile rendering.</p>
<p>If you're considering using this wrapped offset rendering technique in your own projects, there's a couple of points to keep in mind.
First, this is probably only really effective for software rendering and not hardware rendering, since graphics hardware renders all pixels every frame anyway.
Second, this approach won't work as well if tiles are constantly changing, like if they're being animated.
It is the unique combination of partial software rendering, a player-centric camera and a mostly static dungeon that makes wrapped offset rendering an effective performance-improving technique for RuggRogue.</p>
<p>In order for wrapped offset rendering to work, it needs an appropriate offset.
This happens early on in the <code>ChunkedMapGrid::draw</code> function in the <code>src/chunked.rs</code> file, which feeds the top-left corner of the top-left map chunk on screen into <code>TileGrid::set_draw_offset</code>, and all is well.</p>
<p>...</p>
<p>Wait, what's a &quot;chunk&quot;?</p>
<h2 id="improving-map-drawing-performance-with-chunked-drawing"><a class="header" href="#improving-map-drawing-performance-with-chunked-drawing">Improving Map Drawing Performance with Chunked Drawing</a></h2>
<p>It turns out that the performance rabbit hole goes even deeper than mere wrapped offset rendering.
Some time after I had finished work on getting wrapped offset rendering into a functioning state, I found myself profiling the web version of the game.
Performance still wasn't great at this time, and I wanted to know why.
What I saw in the profile data stuck out to me: <em>drawing</em> of the map was dominating execution time.
Not rendering, where all the pixels of each tile have to be handled, but just deciding what tiles were going to look like to begin with?
Well, I suppose that's what happens when you optimize a bottleneck: it moves elsewhere, and here it moved from rendering to map drawing.
It's worth noting that RuggRogue has a resizable window, but it doesn't stretch or zoom its contents to fit the window size.
Instead, it adds or removes space to accommodate more or less tiles.
In other words, if RuggRogue's window is very large, the game has to draw <em>a lot</em> of tiles, and the web version of the game was struggling with this.
In fact, it wasn't even strictly map drawing that was the bottleneck, the sheer number of tile grid cells that could potentially <em>show</em> a map tile was the performance bottleneck.
I had to do something to reduce the number of tile grid cells that had to be considered when drawing the map.</p>
<p>So I made a deal with the Programming Devil: I traded code simplicity for performance by pursuing a <a href="https://wiki.c2.com/?DirtyRectangles">dirty rectangles</a> approach to map drawing.
The idea here is that instead of deciding the appearance of every single cell in the map tile grid every single frame, I'd divide the map tile grid into <em>chunks</em> of 8-by-8 tiles that would be drawn once and would only be revisited on request.
Therefore, the tile grid associated with the map is the only tile grid in the game whose contents are not fully redrawn every single frame.
I refer to this approach as <em>chunked map drawing</em>.</p>
<p>The entirety of the chunked map drawing implementation can be found in the aptly-named <code>src/chunked.rs</code> file.
The most important part of that file is the <code>ChunkedMapGrid</code> struct that contains all of the book-keeping and logic required to make chunked map drawing a reality.
The <code>screen_chunks</code> field of <code>ChunkedMapGrid</code> is a vector of small <code>ScreenChunk</code> structs.
The data in the <code>ScreenChunk</code> is the chunk of the map to be drawn, while the position of each <code>ScreenChunk</code> in the vector implies its position on the screen, i.e. the map tile grid.</p>
<p>In order to maximize performance, we want to avoid the need to constantly redraw partial chunks near the edges of the screen whenever the camera moves.
Therefore, we must maintain a map tile grid whose dimensions are a whole multiple of the chunk size (i.e. 8 tiles) and is big enough to cover the available screen space given to it.
These calculations are performed in the <code>ChunkedMapGrid::prepare_grid</code> function, and the results are stored in the <code>new_chunks_across</code> and <code>new_chunks_down</code> variables.
Special care is taken to ensure the width and height of this grid is strictly greater than its screen dimension if the screen width or height is exactly a multiple of the chunk pixel dimensions to enable shifting.</p>
<p>Now that we have a map tile grid whose bounds exceed the screen space, we need to ensure that the display of the grid itself is shifted so that the camera is centered on screen.
There are two values we need to know in order to calculate how much to shift the map tile grid by:</p>
<ol>
<li>the pixel width of the screen, halved</li>
<li>the x-value of the central pixel of the tile relative to the left edge of the map tile grid</li>
</ol>
<p>The latter value is the sum of the pixels between the central chunk and the left edge, and the pixels between the center of the camera tile and the left edge of the central chunk in which it resides.
The difference between those two values is computed early in the <code>ChunkedMapGrid::draw</code> function and stored in <code>grid.view.dx</code> in order to shift the grid the correct amount.
A similar process is used to fill <code>grid.view.dy</code> as well, substituting &quot;x&quot; with &quot;y&quot; and &quot;width&quot; with &quot;height&quot;.</p>
<p>With size and position sorted, the next thing to work out is which screen chunk shows which map chunk.
This is the job of the <code>screen_chunks</code> field of the <code>ChunkedMapGrid</code> struct.
This is a vector of <code>ScreenChunk</code> structs that holds metadata for each chunk of the map tile grid that needs to be filled in.
Screen chunks are stored in this vector in row-major order, so <code>0</code> is the top-left 8-by-8 chunk of grid cells, <code>1</code> would be next to it on the right, and so on.
The <code>map_chunk</code> stores the 8-by-8 chunk of map tiles that the screen chunk should be showing.
Map chunks are stored as pairs of integers, but the idea is the same as for screen chunks, except representing map chunks instead, so <code>(0, 0)</code> is the top-left 8-by-8 chunk of map tiles, <code>(0, 1)</code> is to the left, <code>(1, 0)</code> is below, and so on.</p>
<p>The screen chunks are filled with map chunk data by figuring out which map chunk the top-left screen chunk should be showing, and populating the other screen chunks from there.
This is the task of the <code>ChunkedMapGrid::screen_top_left_map_chunk</code> function.
It takes the tile position of the camera on the map, and subtracts half a screen's width- and height-worth of tiles from it; whatever map chunk it lands in is assigned to be shown in the top-left screen chunk.</p>
<p>Each screen chunk is accompanied by a <code>dirty</code> flag.
When map chunks are assigned to a screen chunk, the new map chunk value is compared against the existing value remembered by the screen chunk.
If a change is detected, the dirty flag is set.
The presence of the dirty flag triggers the final checking and drawing of map tiles onto the tile grid on screen.
Map rendering is minimized by feeding the top-left tile of the top-left screen chunk into the <code>TileGrid::set_draw_offset</code> function, tying into the wrapped offset rendering described in the previous section.
All of this work is done by the <code>ChunkedMapGrid::draw</code> function.</p>
<p>If we stopped here, we'd only be redrawing chunks of the map as they enter from the edges of the screen.
We still need to handle the player, whose actions cause the contents of the map grid in their field of view to change pretty much every single turn.
When the player, or really the camera, moves around the map, the <code>ChunkedMapGrid::mark_dirty</code> function sets the dirty flags of the corresponding screen chunks.
When the player descends into a new map, the <code>ChunkedMapGrid::mark_all_dirty</code> function sets the dirty flags of every screen chunk.
These calls are made in the <code>DungeonMode::update</code> function after it performs most of its logic.</p>
<h2 id="wrap-up"><a class="header" href="#wrap-up">Wrap Up</a></h2>
<p>Whew, I think that's everything.
As you can see, rendering is a simple process involving hybrid rendering, tile grids, tile grid layers, tilesets, raw tile grids, surfaces, textures, tile grid views, cells, cellsyms, symbols, drawing, rendering, uploading, displaying, wrapped offset rendering and chunked map drawing.</p>
<p>...</p>
<p>Okay, maybe it's not so simple.
So after all of that, how's the performance of the game?
The performance of the web version is... passable.
It's far better than the initial version, but I can't improve it any further short of rethinking the web port from the ground-up.
In contrast, the native build of the game is butter smooth, both the debug build but especially the release build.
I'm really happy about how this all turned out.</p>
<p>If you've read this far, congratulations.
<code>src/lib/tilegrid.rs</code> is the longest source code file in the game, and <code>src/chunked.rs</code> is probably the most complicated.
Future chapters shouldn't be anywhere near as complicated as this one.
Hopefully this gives an idea about how 2D tile grid rendering works overall, and some hints about what's involved in pulling it all together.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-interface"><a class="header" href="#user-interface">User Interface</a></h1>
<p>This chapter covers how RuggRogue handles menus and dialogs, the layout and drawing of the main game screen, and how application closing is handled.</p>
<h2 id="menus"><a class="header" href="#menus">Menus</a></h2>
<p>Most of RuggRogue's interface exists in the form of menus and dialogs.
As mentioned in the overall game flow chapter, menus and dialogs are represented as modes in the game's mode stack.
Because of this, there's no real difference between a &quot;menu&quot; and a &quot;dialog&quot;: they both present themselves as tile grids, react to player input and return some result.
This is a perfect excuse to demonstrate how menus work by using a dialog as an example instead.</p>
<p>The <code>YesNoDialogMode</code> struct in the <code>src/modes/yes_no_dialog.rs</code> file is the simplest dialog, and therefore the simplest menu, in the game.
The struct itself contains the <code>prompt</code> field that is shown to the player and a <code>yes_selected</code> boolean that the player can change by pressing keys.
Every menu and dialog holds data like this: one or more fields related to presentation, and a selection that represents a player-controlled cursor.
Sometimes this selection will be accompanied by a <code>subsection</code> field for more complex menus; the <code>YesNoDialogMode</code> doesn't need one, so it doesn't have one.</p>
<p>Above the definition of <code>YesNoDialogMode</code> is the <code>YesNoDialogModeResult</code> enum.
When the <code>YesNoDialogMode</code> is closed, it returns an instance of <code>YesNoDialogModeResult</code> to the mode immediately below it in the mode stack.
There are three variants: <code>Yes</code>, <code>No</code> and <code>AppQuit</code>.
The first two variants should be obvious; the <code>AppQuit</code> variant is explained in the <a href="event-handling.html#the-appquit-event">Event Handling chapter</a>.</p>
<p>If the game wants to show a yes-or-no prompt, it has to create a <code>YesNoDialogMode</code> using the <code>YesNoDialogMode::new</code> function.
There's an example of this when the player chooses to &quot;save and exit&quot; in the options menu.
This corresponds to the <code>OptionsMenuMode</code> in <code>src/modes/options_menu.rs</code>; look for the &quot;Save and return to title screen&quot; message near the end of the <code>OptionsMenuMode::update</code> function.
There are two important things that need to be done to show a yes-or-no prompt:</p>
<ol>
<li>Create a <code>ModeControl::Push</code> with an instance of <code>YesNoDialogMode</code> created with the <code>YesNoDialogMode::new</code> function.</li>
<li>Clear the input queue using <code>inputs.clear_input()</code> followed by <code>ModeUpdate::Immediate</code> for same-frame result handling while avoiding double-handling of keys.</li>
</ol>
<p>The mode stack will then take the <code>YesNoDialogMode</code> that was wrapped in the <code>ModeControl::Push</code> return value, add it to the mode stack and prepare a fresh <code>TileGridLayer</code> for it.</p>
<p>Once a mode is present in the mode stack, it calls these mode-related functions in order:</p>
<ol>
<li><code>prepare_grids</code></li>
<li><code>update</code>, if the mode is at the top of the stack</li>
<li><code>draw</code></li>
</ol>
<p>Back in <code>src/modes/yes_no_dialog.rs</code>, the <code>YesNoDialogMode::prepare_grids</code> function is the very first function that is called when the <code>YesNoDialogMode</code> is on the stack.
This ensures that the <code>update</code> and <code>draw</code> functions have the same view of the screen and tile grids on any given frame.
The first thing this function does is calculate the dimensions of the tile grid it wants to draw in, whether or not such a tile grid even exists yet.
On the very first call, the vector of <code>TileGrid</code>s corresponding to the <code>TileGridLayer</code> assigned to the mode is empty, so the <code>YesNoDialogMode::prepare_grids</code> function will create a fresh <code>TileGrid</code> with the desired dimensions.
On subsequent calls that tile grid will already exist, so it will just be resized instead.
The <code>YesNoDialogMode::prepare_grids</code> function wraps up by setting its tileset, position (<code>TileGrid::view_centered</code> is a helper to adjust the <code>TileGridView</code>) and zoom factor.
The fact that this information is calculated and assigned every frame is what allows the options menu to instantly take effect on the entire interface.</p>
<p>The <code>YesNoDialogMode::update</code> function is how the dialog responds to player input.
First, an input is pulled in from the input queue by calling the <code>input.prepare_input</code> function.
Next, that input event is read out by calling the <code>input.get_input</code> function.
Assuming it's a key press event, it is then translated into a logical game key by calling the <code>gamekey::from_keycode</code> function.
The <code>YesNoDialogMode::update</code> function reacts to <code>GameKey::Left</code> and <code>GameKey::Right</code> by altering the selected option.</p>
<p>The <code>YesNoDialogMode::draw</code> function draws the dialog itself.
The first thing it does is dim itself if it's not the top-most mode on the stack by setting <code>color_mod</code> to <code>Color::GRAY</code> in response to the value of the <code>active</code> parameter.
The drawing itself takes place after that, drawing the box border and message.
When drawing the &quot;Yes&quot; and &quot;No&quot; options, it reads the <code>yes_selected</code> field of the mode to highlight whichever option the player currently has selected.</p>
<p>Eventually the player will pick either the &quot;Yes&quot; or &quot;No&quot; options.
This is picked up in the <code>YesNoDialogMode::update</code> function when it receives <code>GameKey::Confirm</code> or <code>GameKey::Cancel</code> as a input key.
At this point, the <code>YesNoDialogMode</code> will create an instance of either <code>YesNoDialogModeResult::Yes</code> or <code>YesNoDialogModeResult::No</code>, and wrap it in <code>ModeControl::Pop</code> to tell the mode stack to pop the <code>YesNoDialogMode</code> and send the <code>YesNoDialogModeResult</code> to whatever mode pushed it on to begin with.</p>
<p>This takes us back to the &quot;save and exit&quot; logic in the <code>OptionsMenuMode::update</code> function in <code>src/modes/options_menu.rs</code> file.
The <code>YesNoDialogModeResult</code> will be received in the <code>pop_result</code> parameter of the <code>OptionsMenuMode::update</code> function, and then responded to in the block starting with <code>if let Some(result) = pop_result</code>.
In this case, <code>OptionsMenuMode</code> responds to <code>YesNoDialogModeResult::Yes</code> by popping itself off the mode stack with its own <code>OptionsMenuModeResult::ReallyQuit</code> value.</p>
<p>This covers the entire life-cycle of a yes-or-no dialog:</p>
<ol>
<li>A mode that wants a yes-or-no dialog creates a <code>YesNoDialogMode</code> instance that gets pushed onto the mode stack.</li>
<li>The <code>YesNoDialogMode::prepare_grids</code> function is called to create a tile grid or adjust an existing one.</li>
<li><code>YesNoDialogMode::update</code> responds to player inputs.</li>
<li><code>YesNoDialogMode::draw</code> draws the dialog itself.</li>
<li><code>YesNoDialogMode::update</code> eventually pops itself off the mode stack with an instance of <code>YesNoDialogModeResult</code>.</li>
<li>The original mode beneath catches the <code>YesNoDialogModeResult</code> and reacts to it.</li>
</ol>
<p>This life-cycle is the foundation of every single dialog and menu in the game, even the <code>InventoryMode</code>, found in the <code>src/modes/inventory.rs</code> and the biggest of all the menus.</p>
<h2 id="the-main-game-screen"><a class="header" href="#the-main-game-screen">The Main Game Screen</a></h2>
<p>The majority of the gameplay takes place in <code>DungeonMode</code>, which can be found in the <code>src/modes/dungeon.rs</code> file.
It is responsible for handling player control, distributing turns and drawing the main game interface.
This section describes how the interface is laid out and drawn; player control and turn order will be covered in a later chapter.</p>
<p>The main game screen consists of multiple tile grids that the dungeon mode creates in its mode-stack-designated tile grid layer:</p>
<ol>
<li>The <em>map grid</em> that shows the dungeon map, the player, items and monsters.</li>
<li>The <em>status grid</em> that shows the player's status information, such as their level, health, hunger and turns.</li>
<li>The <em>item grid</em> that shows the player's equipment and number of carried inventory items.</li>
<li>The <em>message frame grid</em> that draws a border around the message log.</li>
<li>The <em>message grid</em> that shows the message log.</li>
</ol>
<p>The distinction between the message frame grid and the message grid is a bit janky.
The split was part of a plan to use wrapped offset rendering to increase message rendering performance, but it never ended up happening.
If I were to revisit this part of the code I would just have a single message grid that draws its frame like everything else.</p>
<p>The <code>DungeonMode::new</code> function prepares the book-keeping for the dungeon mode, the most important part of which is for chunked map drawing, described in detail back in the <a href="rendering.html#improving-map-drawing-performance-with-chunked-drawing">Rendering chapter</a>.</p>
<p>Things get slightly more interesting with the <code>DungeonMode::prepare_grids</code> function, which immediately delegates all of its work to the <code>ui::prepare_grids</code> function.
This function can be found at the very bottom of the <code>src/ui.rs</code> file, and is responsible for calculating and setting the size and position of all the main game screen tile grids.
Despite living in a separate file, it serves the same function as any code found in the <code>prepare_grids</code> function of any other mode.
After setting the size of the map grid, it calls the <code>ChunkedMapGrid::prepare_grid</code> function so that it can prepare and adjust itself to the map tile grid and screen dimensions.</p>
<p>Back in <code>src/modes/dungeon.rs</code>, the <code>DungeonMode::draw</code> function is responsible for coordinating the drawing of all the main game screen tile grids.
Pretty much all of the drawing is delegated here as well.
The <code>ChunkedMapGrid::draw</code> function renders the map itself, while entities on the map are drawn via the <code>render::draw_renderables</code> function, defined in the <code>src/render.rs</code> file.
All of the sidebar tile grids are drawn via the <code>ui::draw_ui</code> function, found in the <code>src/ui.rs</code> file.
The <code>ui::draw_ui</code> function in turn calls the <code>draw_status</code>, <code>draw_item_info</code> and <code>draw_messages</code> functions to fill out each of the grids.
The <code>draw_messages</code> function in particular applies word wrapping to message lines; this is covered in its own chapter.</p>
<p>Apart from <code>DungeonMode</code>, there are two other modes that also draw the main game screen in this fashion: <code>TargetMode</code> and <code>ViewMapMode</code>.
<code>TargetMode</code> is defined in <code>src/modes/target.rs</code> and allows the player to pick a target tile when using an item that needs a target.
<code>ViewMapMode</code> is defined in <code>src/modes/view_map.rs</code> and allows the player to pan the camera while describing map tiles.
Both of these modes show dynamically-updating text in the message area by filling in the optional <code>prompt</code> parameter when calling the <code>ui::draw_ui</code> function.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="options"><a class="header" href="#options">Options</a></h1>
<p>RuggRogue provides the player with an <em>options dialog</em> that can be brought up by either pressing the Esc key during play or choosing &quot;Options&quot; at the title screen.
This dialog allows the player to choose:</p>
<ul>
<li>whether the map uses a graphical tileset or an ASCII display with one of the fonts</li>
<li>the font of the user interface (i.e. the sidebar and menus)</li>
<li>1x or 2x zoom for the map</li>
<li>1x or 2x zoom for the user interface</li>
</ul>
<p>The game offers two fonts: the 8-by-8 pixel Terminal font and the 8-by-14 pixel <a href="https://font.gohu.org/">GohuFont</a>.
The graphical tileset available for the map is a monocolor version of the <a href="https://vurmux.itch.io/urizen-onebit-tilesets">Urizen OneBit Tilesets</a> by vurmux.</p>
<p>If the options dialog is brought up while playing the game, it presents an option to save the game and exit back to the title screen.</p>
<h2 id="options-data"><a class="header" href="#options-data">Options Data</a></h2>
<p>The data for options exists in the form of the <code>Options</code> struct near the top of the <code>src/ui.rs</code> file:</p>
<pre><code class="language-rust ignore">pub struct Options {
    pub tileset: u32,
    pub font: u32,
    pub map_zoom: u32,
    pub text_zoom: u32,
}
</code></pre>
<p>The <code>tileset</code> and <code>font</code> fields decide which of the fonts or tilesets are used when drawing the map and the user interface respectively.
The game treats fonts as tilesets that can only display characters, so these fields are essentially indexes into a single list of tilesets.
The game makes an effort to limit the <code>font</code> field to only the two 'font-like' tilesets, as will be explained later.</p>
<p>The <code>map_zoom</code> field is the numeric zoom factor for the map display that can be toggled between 1x and 2x zoom.
The <code>text_zoom</code> field serves the same purpose but for the user interface instead.</p>
<p>The default values of these options are set all the way back in the <code>main</code> function in the <code>src/main.rs</code> file, like so:</p>
<pre><code class="language-rust ignore">world.add_unique(Options {
    tileset: 2,
    font: 0,
    map_zoom: 1,
    text_zoom: 1,
});
</code></pre>
<p>The above default values display the map using the Urizen graphical tileset, the user interface using GohuFont, and show them both at 1x zoom.</p>
<p>The numeric indexes of the <code>tileset</code> and <code>font</code> fields refer to the tilesets loaded further down in the <code>main</code> function:</p>
<pre><code class="language-rust ignore">let settings = RunSettings {
    // ...
    tileset_infos: vec![
        TilesetInfo::&lt;GameSym&gt; {
            image_path: PathBuf::from(&quot;assets/gohufont-8x14.png&quot;),
            tile_size: (8, 14).into(),
            tile_start: (0, 0).into(),
            tile_gap: (0, 0).into(),
            font_map: TilesetInfo::&lt;GameSym&gt;::map_code_page_437(),
            symbol_map: HashMap::new(),
        },
        TilesetInfo::&lt;GameSym&gt; {
            image_path: PathBuf::from(&quot;assets/terminal-8x8.png&quot;),
            tile_size: (8, 8).into(),
            tile_start: (0, 0).into(),
            tile_gap: (0, 0).into(),
            font_map: TilesetInfo::&lt;GameSym&gt;::map_code_page_437(),
            symbol_map: HashMap::new(),
        },
        gamesym::urizen_tileset_info(),
    ],
};
</code></pre>
<p>In order, these are GohuFont, the Terminal font and the Urizen graphical tileset, referred to by the <code>tileset</code> and <code>font</code> fields of the <code>Options</code> struct as 0, 1 and 2 respectively.
Note that the fonts are listed before the tileset; this fact is exploited by the options dialog to limit <code>font</code> customization to only the fonts.</p>
<h2 id="the-options-dialog"><a class="header" href="#the-options-dialog">The Options Dialog</a></h2>
<p>The options dialog is represented by the <code>OptionsMenuMode</code> that lives in the <code>src/modes/options_menu.rs</code> file.
This dialog allows the player to view and change the game options to suit their preferences.</p>
<p>There's a menu item labelled &quot;Back&quot; at the bottom of the dialog that dismisses it when chosen.
If the options dialog is brought up in the middle of a game, it will read &quot;Save and Exit&quot; instead, and dismissing it will save the game and return the player to the title screen.
The flag that controls this is the <code>prompt_to_save</code> boolean argument sent to the <code>OptionsMenuMode::new</code> function when the dialog is created.</p>
<p>Pressing the left and right keys alters the values of the various options; this takes place in the <code>OptionsMenuMode::update</code> function.
The &quot;Font&quot; option that controls the user interface font is limited to only fonts by being checked against the <code>NUM_FONTS</code> constant near the top of the <code>src/modes/options_menu.rs</code> file.
It's currently hard-coded to be <code>2</code>; adding more fonts would require updating this value accordingly.</p>
<h2 id="real-time-options-updates"><a class="header" href="#real-time-options-updates">Real-Time Options Updates</a></h2>
<p>If you mess with the options a bit, you'll notice that changes to the options are reflected immediately on the screen.
The rendering system consults the option values directly, so they'll update in real time.
To understand how this happens, we need to recap some concepts from the <a href="rendering.html">Rendering</a> chapter:</p>
<table><thead><tr><th>Concept</th><th>Description</th></tr></thead><tbody>
<tr><td>Displayed tile grid</td><td>The physical appearance of a tile grid on the screen.</td></tr>
<tr><td><code>TileGridView</code></td><td>The size, position and zoom factor associated with a tile grid.</td></tr>
<tr><td>Tile grid texture</td><td>The GPU-side texture loaded with the pixels representing a tile grid.</td></tr>
<tr><td>Tile grid pixel buffer</td><td>The CPU-side buffer of the tile grid pixels, uploaded to the GPU-side texture.</td></tr>
<tr><td><code>tileset_index</code> field of <code>TileGrid</code></td><td>Index of the tileset that the tile grid should be rendered with.</td></tr>
<tr><td><code>TileGrid</code> tile data</td><td>The logical cells of the tile grid.</td></tr>
</tbody></table>
<p>Most of the data above depend on other data in the table.
The dependencies are as follows:</p>
<ul>
<li>Displayed tile grid
<ul>
<li><code>TileGridView</code></li>
<li>Tile grid texture
<ul>
<li>Tile grid pixel buffer
<ul>
<li><code>tileset_index</code></li>
<li>Tile data</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Changes to the tileset and font in the options dialog affect the <code>tileset_index</code>.
This invalidates the <em>tile grid pixel buffer</em>, <em>tile grid texture</em> and <em>displayed tile grid</em>.
Changes to the <code>tileset_index</code> of tile grids are made through the <code>TileGrid::set_tileset</code> function in the <code>src/lib/tilegrid.rs</code> file that ensures that all this invalidation takes place.
The <code>TileGrid::display</code> function ensures that any stale data is updated, thus enabling real-time option updates.</p>
<p>Changes to the zoom options affect the <code>TileGridView</code> of different tile grids in the game.
This invalidates the <em>displayed tile grid</em>.
For &quot;Font&quot; zoom, the <code>text_zoom</code> field of the <code>Options</code> struct is directly read out by the various <code>prepare_grids</code> functions of most modes.
It is then used to calculate the size, position and zoom factor for the <code>TileGridView</code> of each <code>TileGrid</code>.
The common case of a tile grid centered in the screen is handled by the <code>TileGrid::view_centered</code> function, filling in the <code>TileGridView</code> with just a single call.</p>
<p>The <code>map_zoom</code> field of the <code>Options</code> struct is specifically read out by the <code>ChunkedMapGrid::prepare_grid</code> function in the <code>src/chunked.rs</code> file.
This function performs special sizing and positioning to ensure that the play area is covered and that there's a single center tile for the camera focus
The <code>map_zoom</code> field impacts the pixel size of the tile grid cells on screen and thus must be accounted for here.</p>
<p>Both preparing and displaying of tile grids must be done every single frame in response to potential window resize events, so option changes accounted for by these processes will occur in real time.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="word-wrapping"><a class="header" href="#word-wrapping">Word Wrapping</a></h1>
<p>If you play RuggRogue, you'll notice the messages that appear in the sidebar.
There's enough room for messages up to 32 characters long to appear unbroken; anything longer than that must be <em>word wrapped</em>.
Word wrapping is the act of breaking a long line down into a sequence of shorter lines that fit inside a desired width while keeping words whole.</p>
<p>All of RuggRogue's word wrapping is done by the <code>ruggrogue::word_wrap</code> function in the <code>src/lib/word_wrap.rs</code> file.
If you're not used to Rust's iterator system, the logic might be hard to follow, so I'm going to do something a bit different here than in the rest of the book: we're going to build the whole thing from the ground up!
This chapter contains runnable code samples; press the &quot;play&quot; button in the top corner to build and run the examples (they get fed through the <a href="https://play.rust-lang.org/">Rust Playground</a>).
If you get time-outs, there's a button to copy the code to the clipboard, and you can paste that into a file and throw it at <code>rustc</code> to run the demo if you have Rust installed.</p>
<p>Before we start, read the <a href="https://doc.rust-lang.org/stable/book/ch13-02-iterators.html">iterators chapter of the Rust book</a>.
No, really, I'll wait; you'll want to be familiar with Rust's iterators before continuing.</p>
<p>...</p>
<p>Okay, now that you've read that (or not), the key take-away is this idea of <em>iterator adaptors</em>: functions that take an existing iterator and produces a new one that adds their own processing to the end.
The job of the <code>ruggrogue::word_wrap</code> function is to create an iterator that takes a string slice (a reference to a sequence of characters in a string) and produces multiple string slices that all fit within a given width.
RuggRogue prints these word-wrapped strings onto tile grids, so the width here is measured as the number of characters per line.</p>
<p>Broadly speaking, the <code>ruggrogue::word_wrap</code> function creates an iterator that does the following:</p>
<ol>
<li>Break the input string into lines based on any existing line break characters in the string itself.</li>
<li>Break each line down into characters and their byte offsets (all Rust strings are UTF-8 encoded).</li>
<li>Prepare the characters and byte offsets for word scanning.</li>
<li>Scan for words, emitting the byte offsets of whole words and individual whitespace characters.</li>
<li>Prepare the word and whitespace byte offset data for line building.</li>
<li>Build line data by fitting a sequence of whitespaces followed by a word onto the current line if it fits, or starting a new line with only the word if it doesn't.</li>
<li>Convert the line data back into strings.</li>
</ol>
<h2 id="step-1-break-on-existing-lines"><a class="header" href="#step-1-break-on-existing-lines">Step 1: Break on Existing Lines</a></h2>
<p>This all starts really basic: we need a function that takes an input string and a maximum character width, and returns an iterator.
To see the results of all of this, we need some sample input and some output logic, maybe something like this:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let max_length = 15;
    let msg = &quot;  I'm nbdy!  Wh are yu?
Are yu nbdy, t?
Then there's a pair of us - don't tell!
They'd banish us, you know.

  How dreary to be somebody!
How public, li-ke a rog
To tell your name the live-long day
To an admiring bog!

  - nobody&quot;;

    for tmp in word_wrap(msg, max_length) {
        println!(&quot;{:?}&quot;, tmp);
    }
}

fn word_wrap(input: &amp;str, max_length: usize) -&gt; impl Iterator&lt;Item = &amp;str&gt; {
    assert!(max_length &gt; 0);

    input.lines()
}
</code></pre></pre>
<p>I've taken the liberty of throwing in some random non-ASCII characters to ensure that we're handling the difference between bytes and characters, as you have to when handling UTF-8 encoded strings.
You should see the input string just being broken into the lines using Rust's <a href="https://doc.rust-lang.org/std/primitive.str.html#method.lines"><code>str::lines</code></a> function, which returns a simple iterator that does just that.
Rust's <code>for</code> loops automatically understand iterators, so that's what the main function does to produce its output.</p>
<p>From here on, we'll leave out the <code>main</code> function to focus on the <code>word_wrap</code> function that we're building up, but it will still be there when you run the code samples.
There's a toggle button in the top right of these samples to show the full demo code if you want to see it.</p>
<h2 id="step-2-characters-and-byte-offsets"><a class="header" href="#step-2-characters-and-byte-offsets">Step 2: Characters and Byte Offsets</a></h2>
<p>In order to perform word wrapping we'll need to know how each line breaks down into characters, so we know what's whitespace and what belongs to a word.
We'll also need the byte offsets of each of these characters, which can be larger than a single byte if they're not in the ASCII character range.
The byte offsets will be used to create the final string slices that refer back to the original input string data; we don't want to allocate string storage to replicate parts of strings that already exist!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let max_length = 15;
</span><span class="boring">    let msg = &quot;  I'm nbdy!  Wh are yu?
</span><span class="boring">Are yu nbdy, t?
</span><span class="boring">Then there's a pair of us - don't tell!
</span><span class="boring">They'd banish us, you know.
</span><span class="boring">
</span><span class="boring">  How dreary to be somebody!
</span><span class="boring">How public, li-ke a rog
</span><span class="boring">To tell your name the live-long day
</span><span class="boring">To an admiring bog!
</span><span class="boring">
</span><span class="boring">  - nobody&quot;;
</span><span class="boring">
</span><span class="boring">    for tmp in word_wrap(msg, max_length) {
</span><span class="boring">        println!(&quot;{:?}&quot;, tmp);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn word_wrap(input: &amp;str, max_length: usize) -&gt; impl Iterator&lt;Item = (usize, char)&gt; + '_ {
</span><span class="boring">    assert!(max_length &gt; 0);
</span><span class="boring">
</span>    input.lines().flat_map(move |line| {
        line.char_indices()
    })
<span class="boring">}
</span></code></pre></pre>
<p>Running the above sample should print a long list of characters and their byte offsets.</p>
<p>Rust's <a href="https://doc.rust-lang.org/std/primitive.str.html#method.char_indices"><code>str::char_indices</code></a> gives us the characters and byte offsets that you'll see if you run the code sample.
This by itself would give us a nested iterator: one iterator of chars-and-offsets per line.
We use Rust's <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.flat_map"><code>Iterator::flat_map</code></a> function to remove this nesting to get ourselves a single long list of chars-and-offsets.
Note that the byte offsets shown are relative to the start of each line, not the input string as a whole.</p>
<h2 id="step-3-prepare-for-word-scanning"><a class="header" href="#step-3-prepare-for-word-scanning">Step 3: Prepare for Word Scanning</a></h2>
<p>The word scanning that we're going to do next is done a character at a time, but we need to perform some finalization at the end.
But iterators in Rust only do things on a per-item basis.
How do we get an iterator to do something <em>after</em> the last item?</p>
<p>We're going to use Rust's <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code> type</a> to wrap each item inside a <code>Some</code> variant.
We'll then use <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.chain"><code>Iterator::chain</code></a> with a one-item iterator of the <code>None</code> variant using <a href="https://doc.rust-lang.org/std/iter/fn.once.html"><code>iter::once</code></a> to act as the final <em>sentinel</em> value.
Putting it together gives us something that looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let max_length = 15;
</span><span class="boring">    let msg = &quot;  I'm nbdy!  Wh are yu?
</span><span class="boring">Are yu nbdy, t?
</span><span class="boring">Then there's a pair of us - don't tell!
</span><span class="boring">They'd banish us, you know.
</span><span class="boring">
</span><span class="boring">  How dreary to be somebody!
</span><span class="boring">How public, li-ke a rog
</span><span class="boring">To tell your name the live-long day
</span><span class="boring">To an admiring bog!
</span><span class="boring">
</span><span class="boring">  - nobody&quot;;
</span><span class="boring">
</span><span class="boring">    for tmp in word_wrap(msg, max_length) {
</span><span class="boring">        println!(&quot;{:?}&quot;, tmp);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn word_wrap(input: &amp;str, max_length: usize) -&gt; impl Iterator&lt;Item = (usize, Option&lt;char&gt;)&gt; + '_ {
</span><span class="boring">    assert!(max_length &gt; 0);
</span><span class="boring">
</span>    input.lines().flat_map(move |line| {
        line.char_indices()
            .map(|(pos, ch)| (pos, Some(ch)))
            .chain(std::iter::once((line.len(), None))) // character sentinel
    })
<span class="boring">}
</span></code></pre></pre>
<p>Running the code sample should produce the same characters and offsets wrapped with <code>Some</code>, with a single <code>None</code> representing the end of each line.</p>
<h2 id="step-4-scan-for-words"><a class="header" href="#step-4-scan-for-words">Step 4: Scan for Words</a></h2>
<p>Now that we have characters, offsets and a sentinel to mark the end of each line, how do we detect words?
For that we'll use Rust's <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.scan"><code>iter::scan</code></a> function.
I recommend reading its official documentation.
The idea here is that we want to step through each character, building up memory of where each word begins, and the previous character to detect where each word should end.
We also treat hyphens as the end of a word, and break any words that exceed the maximum line width.
Every time we detect the end of a word, we need to emit data with <code>Some</code>, otherwise we'll emit a <code>None</code> to indicate that we're still processing characters.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let max_length = 15;
</span><span class="boring">    let msg = &quot;  I'm nbdy!  Wh are yu?
</span><span class="boring">Are yu nbdy, t?
</span><span class="boring">Then there's a pair of us - don't tell!
</span><span class="boring">They'd banish us, you know.
</span><span class="boring">
</span><span class="boring">  How dreary to be somebody!
</span><span class="boring">How public, li-ke a rog
</span><span class="boring">To tell your name the live-long day
</span><span class="boring">To an admiring bog!
</span><span class="boring">
</span><span class="boring">  - nobody&quot;;
</span><span class="boring">
</span><span class="boring">    for tmp in word_wrap(msg, max_length) {
</span><span class="boring">        println!(&quot;{:?}&quot;, tmp);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn word_wrap(input: &amp;str, max_length: usize) -&gt; impl Iterator&lt;Item = Option&lt;(usize, usize, usize, bool)&gt;&gt; + '_ {
</span><span class="boring">    assert!(max_length &gt; 0);
</span><span class="boring">
</span>    input.lines().flat_map(move |line| {
        line.char_indices()
            .map(|(pos, ch)| (pos, Some(ch)))
            .chain(std::iter::once((line.len(), None))) // character sentinel
            .scan(None, move |state, (pos, ch)| {
                // Break into words and single spaces.
                if let Some(ch) = ch {
                    if let Some((in_word, start_pos, char_count, last_char)) = state {
                        if *char_count &gt;= max_length || *last_char == '-' || ch.is_whitespace() {
                            // Line-length or hyphen-divided word, or mid-line whitespace.
                            let was_word = *in_word;
                            let last_start_pos = *start_pos;
                            let last_char_count = *char_count;
                            *in_word = !ch.is_whitespace();
                            *start_pos = pos;
                            *char_count = 1;
                            *last_char = ch;
                            Some(Some((last_start_pos, pos, last_char_count, was_word)))
                        } else if *in_word {
                            // Word continuation.
                            *char_count += 1;
                            *last_char = ch;
                            Some(None)
                        } else {
                            // Entering a word after whitespace.
                            let was_word = *in_word;
                            let last_start_pos = *start_pos;
                            let last_char_count = *char_count;
                            *in_word = true;
                            *start_pos = pos;
                            *char_count = 1;
                            *last_char = ch;
                            Some(Some((last_start_pos, pos, last_char_count, was_word)))
                        }
                    } else {
                        // Start of the line.
                        let in_word = !ch.is_whitespace();
                        let start_pos = pos;
                        let char_count = 1;
                        let last_char = ch;
                        *state = Some((in_word, start_pos, char_count, last_char));
                        Some(None)
                    }
                } else {
                    // End of the line.
                    if let Some((in_word, start_pos, char_count, _)) = state {
                        // Finish the final word or whitespace.
                        Some(Some((*start_pos, pos, *char_count, *in_word)))
                    } else {
                        // Empty line.
                        Some(Some((pos, pos, 0, false)))
                    }
                }
            })
    })
<span class="boring">}
</span></code></pre></pre>
<p>If you run the above code, you'll see that the output is a mixture of <code>Some</code> and <code>None</code> variants.
The <code>None</code>s represent intermediate working steps when a character is scanned but a word or whitespace hasn't been fully processed yet.
The <code>Some</code> means a whole word or single whitespace character has been processed.
The <code>Some</code> holds a 4-tuple consisting of three numbers and boolean flag.
The first two numbers are the byte offset of the start (inclusive) and end (exclusive) of each word or whitespace character.
The third number is the length of the word, in characters.
The boolean is <code>true</code> when it represents a word, or <code>false</code> for a whitespace character.</p>
<p>Note the bottom of the code that picks up the <code>None</code> sentinel value at the end of the line to finish the last word or whitespace character.</p>
<h2 id="step-5-prepare-for-line-scanning"><a class="header" href="#step-5-prepare-for-line-scanning">Step 5: Prepare for Line Scanning</a></h2>
<p>In order to build characters up into words, we needed to wrap each value with <code>Some</code> and add a <code>None</code> sentinel value.
We need to perform scanning again, this time for words.
If you ran the previous code sample, you'll notice that our data is already wrapped up in <code>Some</code>, but there's a lot of <code>None</code> values mixed in there.
We're going to use <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter"><code>iter::filter</code></a> along with <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.is_some"><code>Option::is_some</code></a> to clear out those <code>None</code> values.
We'd also like to re-add that single <code>None</code> value to mark the end of the line again to handle the final word or whitespace after we perform line scanning.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let max_length = 15;
</span><span class="boring">    let msg = &quot;  I'm nbdy!  Wh are yu?
</span><span class="boring">Are yu nbdy, t?
</span><span class="boring">Then there's a pair of us - don't tell!
</span><span class="boring">They'd banish us, you know.
</span><span class="boring">
</span><span class="boring">  How dreary to be somebody!
</span><span class="boring">How public, li-ke a rog
</span><span class="boring">To tell your name the live-long day
</span><span class="boring">To an admiring bog!
</span><span class="boring">
</span><span class="boring">  - nobody&quot;;
</span><span class="boring">
</span><span class="boring">    for tmp in word_wrap(msg, max_length) {
</span><span class="boring">        println!(&quot;{:?}&quot;, tmp);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn word_wrap(input: &amp;str, max_length: usize) -&gt; impl Iterator&lt;Item = Option&lt;(usize, usize, usize, bool)&gt;&gt; + '_ {
</span><span class="boring">    assert!(max_length &gt; 0);
</span><span class="boring">
</span>    input.lines().flat_map(move |line| {
        line.char_indices()
            .map(|(pos, ch)| (pos, Some(ch)))
            .chain(std::iter::once((line.len(), None))) // character sentinel
            .scan(None, move |state, (pos, ch)| {
                // Break into words and single spaces.
                // ...
<span class="boring">                if let Some(ch) = ch {
</span><span class="boring">                    if let Some((in_word, start_pos, char_count, last_char)) = state {
</span><span class="boring">                        if *char_count &gt;= max_length || *last_char == '-' || ch.is_whitespace() {
</span><span class="boring">                            // Line-length or hyphen-divided word, or mid-line whitespace.
</span><span class="boring">                            let was_word = *in_word;
</span><span class="boring">                            let last_start_pos = *start_pos;
</span><span class="boring">                            let last_char_count = *char_count;
</span><span class="boring">                            *in_word = !ch.is_whitespace();
</span><span class="boring">                            *start_pos = pos;
</span><span class="boring">                            *char_count = 1;
</span><span class="boring">                            *last_char = ch;
</span><span class="boring">                            Some(Some((last_start_pos, pos, last_char_count, was_word)))
</span><span class="boring">                        } else if *in_word {
</span><span class="boring">                            // Word continuation.
</span><span class="boring">                            *char_count += 1;
</span><span class="boring">                            *last_char = ch;
</span><span class="boring">                            Some(None)
</span><span class="boring">                        } else {
</span><span class="boring">                            // Entering a word after whitespace.
</span><span class="boring">                            let was_word = *in_word;
</span><span class="boring">                            let last_start_pos = *start_pos;
</span><span class="boring">                            let last_char_count = *char_count;
</span><span class="boring">                            *in_word = true;
</span><span class="boring">                            *start_pos = pos;
</span><span class="boring">                            *char_count = 1;
</span><span class="boring">                            *last_char = ch;
</span><span class="boring">                            Some(Some((last_start_pos, pos, last_char_count, was_word)))
</span><span class="boring">                        }
</span><span class="boring">                    } else {
</span><span class="boring">                        // Start of the line.
</span><span class="boring">                        let in_word = !ch.is_whitespace();
</span><span class="boring">                        let start_pos = pos;
</span><span class="boring">                        let char_count = 1;
</span><span class="boring">                        let last_char = ch;
</span><span class="boring">                        *state = Some((in_word, start_pos, char_count, last_char));
</span><span class="boring">                        Some(None)
</span><span class="boring">                    }
</span><span class="boring">                } else {
</span><span class="boring">                    // End of the line.
</span><span class="boring">                    if let Some((in_word, start_pos, char_count, _)) = state {
</span><span class="boring">                        // Finish the final word or whitespace.
</span><span class="boring">                        Some(Some((*start_pos, pos, *char_count, *in_word)))
</span><span class="boring">                    } else {
</span><span class="boring">                        // Empty line.
</span><span class="boring">                        Some(Some((pos, pos, 0, false)))
</span><span class="boring">                    }
</span><span class="boring">                }
</span>            })
            .filter(Option::is_some)
            .chain(Some(None)) // word sentinel
    })
<span class="boring">}
</span></code></pre></pre>
<p>The output should be the same as before, but with all of the <code>None</code> values gone, except for a final <code>None</code> to mark the end of each line.</p>
<h2 id="step-6-build-lines-by-scanning-words-and-whitespaces"><a class="header" href="#step-6-build-lines-by-scanning-words-and-whitespaces">Step 6: Build Lines by Scanning Words and Whitespaces</a></h2>
<p>We now have everything we need to create a scanner that builds up lines.
The idea of this scanner is to extend a line continuously with a sequence of whitespace characters followed by a single word.
If the sum of the character counts of that sequence and the existing line fits in the desired width, we append the whole thing to the line.
If not, we'll emit the line as-is, and start a new line <em>without</em> the preceeding whitespace characters.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let max_length = 15;
</span><span class="boring">    let msg = &quot;  I'm nbdy!  Wh are yu?
</span><span class="boring">Are yu nbdy, t?
</span><span class="boring">Then there's a pair of us - don't tell!
</span><span class="boring">They'd banish us, you know.
</span><span class="boring">
</span><span class="boring">  How dreary to be somebody!
</span><span class="boring">How public, li-ke a rog
</span><span class="boring">To tell your name the live-long day
</span><span class="boring">To an admiring bog!
</span><span class="boring">
</span><span class="boring">  - nobody&quot;;
</span><span class="boring">
</span><span class="boring">    for tmp in word_wrap(msg, max_length) {
</span><span class="boring">        println!(&quot;{:?}&quot;, tmp);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn word_wrap(input: &amp;str, max_length: usize) -&gt; impl Iterator&lt;Item = Option&lt;(usize, usize)&gt;&gt; + '_ {
</span><span class="boring">    assert!(max_length &gt; 0);
</span><span class="boring">
</span>    input.lines().flat_map(move |line| {
        line.char_indices()
            .map(|(pos, ch)| (pos, Some(ch)))
            .chain(std::iter::once((line.len(), None))) // character sentinel
            .scan(None, move |state, (pos, ch)| {
                // Break into words and single spaces.
                // ...
<span class="boring">                if let Some(ch) = ch {
</span><span class="boring">                    if let Some((in_word, start_pos, char_count, last_char)) = state {
</span><span class="boring">                        if *char_count &gt;= max_length || *last_char == '-' || ch.is_whitespace() {
</span><span class="boring">                            // Line-length or hyphen-divided word, or mid-line whitespace.
</span><span class="boring">                            let was_word = *in_word;
</span><span class="boring">                            let last_start_pos = *start_pos;
</span><span class="boring">                            let last_char_count = *char_count;
</span><span class="boring">                            *in_word = !ch.is_whitespace();
</span><span class="boring">                            *start_pos = pos;
</span><span class="boring">                            *char_count = 1;
</span><span class="boring">                            *last_char = ch;
</span><span class="boring">                            Some(Some((last_start_pos, pos, last_char_count, was_word)))
</span><span class="boring">                        } else if *in_word {
</span><span class="boring">                            // Word continuation.
</span><span class="boring">                            *char_count += 1;
</span><span class="boring">                            *last_char = ch;
</span><span class="boring">                            Some(None)
</span><span class="boring">                        } else {
</span><span class="boring">                            // Entering a word after whitespace.
</span><span class="boring">                            let was_word = *in_word;
</span><span class="boring">                            let last_start_pos = *start_pos;
</span><span class="boring">                            let last_char_count = *char_count;
</span><span class="boring">                            *in_word = true;
</span><span class="boring">                            *start_pos = pos;
</span><span class="boring">                            *char_count = 1;
</span><span class="boring">                            *last_char = ch;
</span><span class="boring">                            Some(Some((last_start_pos, pos, last_char_count, was_word)))
</span><span class="boring">                        }
</span><span class="boring">                    } else {
</span><span class="boring">                        // Start of the line.
</span><span class="boring">                        let in_word = !ch.is_whitespace();
</span><span class="boring">                        let start_pos = pos;
</span><span class="boring">                        let char_count = 1;
</span><span class="boring">                        let last_char = ch;
</span><span class="boring">                        *state = Some((in_word, start_pos, char_count, last_char));
</span><span class="boring">                        Some(None)
</span><span class="boring">                    }
</span><span class="boring">                } else {
</span><span class="boring">                    // End of the line.
</span><span class="boring">                    if let Some((in_word, start_pos, char_count, _)) = state {
</span><span class="boring">                        // Finish the final word or whitespace.
</span><span class="boring">                        Some(Some((*start_pos, pos, *char_count, *in_word)))
</span><span class="boring">                    } else {
</span><span class="boring">                        // Empty line.
</span><span class="boring">                        Some(Some((pos, pos, 0, false)))
</span><span class="boring">                    }
</span><span class="boring">                }
</span>            })
            .filter(Option::is_some)
            .chain(Some(None)) // word sentinel
            .scan(None, move |state, word_data| {
                // Build up lines up to max_length.
                if let Some((word_start, word_end, word_char_count, is_word)) = word_data {
                    if let Some((line_start, line_end, final_end, line_char_count)) = state {
                        if is_word {
                            if *line_char_count + word_char_count &lt;= max_length {
                                // Word fits on line, so include it.
                                *line_end = word_end;
                                *final_end = word_end;
                                *line_char_count += word_char_count;
                                Some(None)
                            } else {
                                // Word exceeds line, so start a new line with it instead.
                                let last_line_start = *line_start;
                                let last_line_end = *line_end;
                                *line_start = word_start;
                                *line_end = word_end;
                                *final_end = word_end;
                                *line_char_count = word_char_count;
                                Some(Some((last_line_start, last_line_end)))
                            }
                        } else {
                            if *line_char_count + word_char_count &lt;= max_length {
                                // Whitespace fits on line, so include it when finishing words.
                                *final_end = word_end;
                            }
                            *line_char_count += word_char_count;
                            Some(None)
                        }
                    } else {
                        // The first word.
                        let line_start = word_start;
                        let line_end = if is_word { word_end } else { word_start };
                        let final_end = word_end;
                        let line_char_count = word_char_count;
                        *state = Some((line_start, line_end, final_end, line_char_count));
                        Some(None)
                    }
                } else {
                    // End of words.
                    if let Some((line_start, _, final_end, _)) = state {
                        // Finish the line.
                        Some(Some((*line_start, *final_end)))
                    } else {
                        // Empty line.
                        Some(Some((0, 0)))
                    }
                }
            })
    })
<span class="boring">}
</span></code></pre></pre>
<p>Running the above sample code will output just the byte offsets of the start (inclusive) and end (exclusive) of each wrapped line.
All those <code>Some</code> and <code>None</code> values are littered in there, and at this point we really only need the data inside each <code>Some</code>.
There's a trick we can do here: Rust can treat an <code>Option</code> like a container that has no items (<code>None</code>) or a single item (<code>Some(...)</code>).
What's more, Rust can convert an <code>Option</code> into an iterator, so if we squint hard enough, we sort of have a list of <em>iterators</em>.
We can therefore use the <code>iter::flatten</code> function to clean out the <code>None</code> values and extract the data from the <code>Some</code> variants in one fell swoop!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let max_length = 15;
</span><span class="boring">    let msg = &quot;  I'm nbdy!  Wh are yu?
</span><span class="boring">Are yu nbdy, t?
</span><span class="boring">Then there's a pair of us - don't tell!
</span><span class="boring">They'd banish us, you know.
</span><span class="boring">
</span><span class="boring">  How dreary to be somebody!
</span><span class="boring">How public, li-ke a rog
</span><span class="boring">To tell your name the live-long day
</span><span class="boring">To an admiring bog!
</span><span class="boring">
</span><span class="boring">  - nobody&quot;;
</span><span class="boring">
</span><span class="boring">    for tmp in word_wrap(msg, max_length) {
</span><span class="boring">        println!(&quot;{:?}&quot;, tmp);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn word_wrap(input: &amp;str, max_length: usize) -&gt; impl Iterator&lt;Item = (usize, usize)&gt; + '_ {
</span><span class="boring">    assert!(max_length &gt; 0);
</span><span class="boring">
</span>    input.lines().flat_map(move |line| {
        line.char_indices()
            .map(|(pos, ch)| (pos, Some(ch)))
            .chain(std::iter::once((line.len(), None))) // character sentinel
            .scan(None, move |state, (pos, ch)| {
                // Break into words and single spaces.
                // ...
<span class="boring">                if let Some(ch) = ch {
</span><span class="boring">                    if let Some((in_word, start_pos, char_count, last_char)) = state {
</span><span class="boring">                        if *char_count &gt;= max_length || *last_char == '-' || ch.is_whitespace() {
</span><span class="boring">                            // Line-length or hyphen-divided word, or mid-line whitespace.
</span><span class="boring">                            let was_word = *in_word;
</span><span class="boring">                            let last_start_pos = *start_pos;
</span><span class="boring">                            let last_char_count = *char_count;
</span><span class="boring">                            *in_word = !ch.is_whitespace();
</span><span class="boring">                            *start_pos = pos;
</span><span class="boring">                            *char_count = 1;
</span><span class="boring">                            *last_char = ch;
</span><span class="boring">                            Some(Some((last_start_pos, pos, last_char_count, was_word)))
</span><span class="boring">                        } else if *in_word {
</span><span class="boring">                            // Word continuation.
</span><span class="boring">                            *char_count += 1;
</span><span class="boring">                            *last_char = ch;
</span><span class="boring">                            Some(None)
</span><span class="boring">                        } else {
</span><span class="boring">                            // Entering a word after whitespace.
</span><span class="boring">                            let was_word = *in_word;
</span><span class="boring">                            let last_start_pos = *start_pos;
</span><span class="boring">                            let last_char_count = *char_count;
</span><span class="boring">                            *in_word = true;
</span><span class="boring">                            *start_pos = pos;
</span><span class="boring">                            *char_count = 1;
</span><span class="boring">                            *last_char = ch;
</span><span class="boring">                            Some(Some((last_start_pos, pos, last_char_count, was_word)))
</span><span class="boring">                        }
</span><span class="boring">                    } else {
</span><span class="boring">                        // Start of the line.
</span><span class="boring">                        let in_word = !ch.is_whitespace();
</span><span class="boring">                        let start_pos = pos;
</span><span class="boring">                        let char_count = 1;
</span><span class="boring">                        let last_char = ch;
</span><span class="boring">                        *state = Some((in_word, start_pos, char_count, last_char));
</span><span class="boring">                        Some(None)
</span><span class="boring">                    }
</span><span class="boring">                } else {
</span><span class="boring">                    // End of the line.
</span><span class="boring">                    if let Some((in_word, start_pos, char_count, _)) = state {
</span><span class="boring">                        // Finish the final word or whitespace.
</span><span class="boring">                        Some(Some((*start_pos, pos, *char_count, *in_word)))
</span><span class="boring">                    } else {
</span><span class="boring">                        // Empty line.
</span><span class="boring">                        Some(Some((pos, pos, 0, false)))
</span><span class="boring">                    }
</span><span class="boring">                }
</span>            })
            .filter(Option::is_some)
            .chain(Some(None)) // word sentinel
            .scan(None, move |state, word_data| {
                // Build up lines up to max_length.
                // ...
<span class="boring">                if let Some((word_start, word_end, word_char_count, is_word)) = word_data {
</span><span class="boring">                    if let Some((line_start, line_end, final_end, line_char_count)) = state {
</span><span class="boring">                        if is_word {
</span><span class="boring">                            if *line_char_count + word_char_count &lt;= max_length {
</span><span class="boring">                                // Word fits on line, so include it.
</span><span class="boring">                                *line_end = word_end;
</span><span class="boring">                                *final_end = word_end;
</span><span class="boring">                                *line_char_count += word_char_count;
</span><span class="boring">                                Some(None)
</span><span class="boring">                            } else {
</span><span class="boring">                                // Word exceeds line, so start a new line with it instead.
</span><span class="boring">                                let last_line_start = *line_start;
</span><span class="boring">                                let last_line_end = *line_end;
</span><span class="boring">                                *line_start = word_start;
</span><span class="boring">                                *line_end = word_end;
</span><span class="boring">                                *final_end = word_end;
</span><span class="boring">                                *line_char_count = word_char_count;
</span><span class="boring">                                Some(Some((last_line_start, last_line_end)))
</span><span class="boring">                            }
</span><span class="boring">                        } else {
</span><span class="boring">                            if *line_char_count + word_char_count &lt;= max_length {
</span><span class="boring">                                // Whitespace fits on line, so include it when finishing words.
</span><span class="boring">                                *final_end = word_end;
</span><span class="boring">                            }
</span><span class="boring">                            *line_char_count += word_char_count;
</span><span class="boring">                            Some(None)
</span><span class="boring">                        }
</span><span class="boring">                    } else {
</span><span class="boring">                        // The first word.
</span><span class="boring">                        let line_start = word_start;
</span><span class="boring">                        let line_end = if is_word { word_end } else { word_start };
</span><span class="boring">                        let final_end = word_end;
</span><span class="boring">                        let line_char_count = word_char_count;
</span><span class="boring">                        *state = Some((line_start, line_end, final_end, line_char_count));
</span><span class="boring">                        Some(None)
</span><span class="boring">                    }
</span><span class="boring">                } else {
</span><span class="boring">                    // End of words.
</span><span class="boring">                    if let Some((line_start, _, final_end, _)) = state {
</span><span class="boring">                        // Finish the line.
</span><span class="boring">                        Some(Some((*line_start, *final_end)))
</span><span class="boring">                    } else {
</span><span class="boring">                        // Empty line.
</span><span class="boring">                        Some(Some((0, 0)))
</span><span class="boring">                    }
</span><span class="boring">                }
</span>            })
            .flatten()
    })
<span class="boring">}
</span></code></pre></pre>
<p>Running the above code sample should produce a cleaned-up version of the output from the previous code sample.</p>
<h2 id="step-7-convert-data-back-into-string-slices"><a class="header" href="#step-7-convert-data-back-into-string-slices">Step 7: Convert Data back into String Slices</a></h2>
<p>We originally wanted string slices of word-wrapped lines, which trivially builds on the work that's been done up to this point.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let max_length = 15;
</span><span class="boring">    let msg = &quot;  I'm nbdy!  Wh are yu?
</span><span class="boring">Are yu nbdy, t?
</span><span class="boring">Then there's a pair of us - don't tell!
</span><span class="boring">They'd banish us, you know.
</span><span class="boring">
</span><span class="boring">  How dreary to be somebody!
</span><span class="boring">How public, li-ke a rog
</span><span class="boring">To tell your name the live-long day
</span><span class="boring">To an admiring bog!
</span><span class="boring">
</span><span class="boring">  - nobody&quot;;
</span><span class="boring">
</span><span class="boring">    for tmp in word_wrap(msg, max_length) {
</span><span class="boring">        println!(&quot;{:?}&quot;, tmp);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn word_wrap(input: &amp;str, max_length: usize) -&gt; impl Iterator&lt;Item = &amp;str&gt; {
</span><span class="boring">    assert!(max_length &gt; 0);
</span><span class="boring">
</span>    input.lines().flat_map(move |line| {
        line.char_indices()
            .map(|(pos, ch)| (pos, Some(ch)))
            .chain(std::iter::once((line.len(), None))) // character sentinel
            .scan(None, move |state, (pos, ch)| {
                // Break into words and single spaces.
                // ...
<span class="boring">                if let Some(ch) = ch {
</span><span class="boring">                    if let Some((in_word, start_pos, char_count, last_char)) = state {
</span><span class="boring">                        if *char_count &gt;= max_length || *last_char == '-' || ch.is_whitespace() {
</span><span class="boring">                            // Line-length or hyphen-divided word, or mid-line whitespace.
</span><span class="boring">                            let was_word = *in_word;
</span><span class="boring">                            let last_start_pos = *start_pos;
</span><span class="boring">                            let last_char_count = *char_count;
</span><span class="boring">                            *in_word = !ch.is_whitespace();
</span><span class="boring">                            *start_pos = pos;
</span><span class="boring">                            *char_count = 1;
</span><span class="boring">                            *last_char = ch;
</span><span class="boring">                            Some(Some((last_start_pos, pos, last_char_count, was_word)))
</span><span class="boring">                        } else if *in_word {
</span><span class="boring">                            // Word continuation.
</span><span class="boring">                            *char_count += 1;
</span><span class="boring">                            *last_char = ch;
</span><span class="boring">                            Some(None)
</span><span class="boring">                        } else {
</span><span class="boring">                            // Entering a word after whitespace.
</span><span class="boring">                            let was_word = *in_word;
</span><span class="boring">                            let last_start_pos = *start_pos;
</span><span class="boring">                            let last_char_count = *char_count;
</span><span class="boring">                            *in_word = true;
</span><span class="boring">                            *start_pos = pos;
</span><span class="boring">                            *char_count = 1;
</span><span class="boring">                            *last_char = ch;
</span><span class="boring">                            Some(Some((last_start_pos, pos, last_char_count, was_word)))
</span><span class="boring">                        }
</span><span class="boring">                    } else {
</span><span class="boring">                        // Start of the line.
</span><span class="boring">                        let in_word = !ch.is_whitespace();
</span><span class="boring">                        let start_pos = pos;
</span><span class="boring">                        let char_count = 1;
</span><span class="boring">                        let last_char = ch;
</span><span class="boring">                        *state = Some((in_word, start_pos, char_count, last_char));
</span><span class="boring">                        Some(None)
</span><span class="boring">                    }
</span><span class="boring">                } else {
</span><span class="boring">                    // End of the line.
</span><span class="boring">                    if let Some((in_word, start_pos, char_count, _)) = state {
</span><span class="boring">                        // Finish the final word or whitespace.
</span><span class="boring">                        Some(Some((*start_pos, pos, *char_count, *in_word)))
</span><span class="boring">                    } else {
</span><span class="boring">                        // Empty line.
</span><span class="boring">                        Some(Some((pos, pos, 0, false)))
</span><span class="boring">                    }
</span><span class="boring">                }
</span>            })
            .filter(Option::is_some)
            .chain(Some(None)) // word sentinel
            .scan(None, move |state, word_data| {
                // Build up lines up to max_length.
                // ...
<span class="boring">                if let Some((word_start, word_end, word_char_count, is_word)) = word_data {
</span><span class="boring">                    if let Some((line_start, line_end, final_end, line_char_count)) = state {
</span><span class="boring">                        if is_word {
</span><span class="boring">                            if *line_char_count + word_char_count &lt;= max_length {
</span><span class="boring">                                // Word fits on line, so include it.
</span><span class="boring">                                *line_end = word_end;
</span><span class="boring">                                *final_end = word_end;
</span><span class="boring">                                *line_char_count += word_char_count;
</span><span class="boring">                                Some(None)
</span><span class="boring">                            } else {
</span><span class="boring">                                // Word exceeds line, so start a new line with it instead.
</span><span class="boring">                                let last_line_start = *line_start;
</span><span class="boring">                                let last_line_end = *line_end;
</span><span class="boring">                                *line_start = word_start;
</span><span class="boring">                                *line_end = word_end;
</span><span class="boring">                                *final_end = word_end;
</span><span class="boring">                                *line_char_count = word_char_count;
</span><span class="boring">                                Some(Some((last_line_start, last_line_end)))
</span><span class="boring">                            }
</span><span class="boring">                        } else {
</span><span class="boring">                            if *line_char_count + word_char_count &lt;= max_length {
</span><span class="boring">                                // Whitespace fits on line, so include it when finishing words.
</span><span class="boring">                                *final_end = word_end;
</span><span class="boring">                            }
</span><span class="boring">                            *line_char_count += word_char_count;
</span><span class="boring">                            Some(None)
</span><span class="boring">                        }
</span><span class="boring">                    } else {
</span><span class="boring">                        // The first word.
</span><span class="boring">                        let line_start = word_start;
</span><span class="boring">                        let line_end = if is_word { word_end } else { word_start };
</span><span class="boring">                        let final_end = word_end;
</span><span class="boring">                        let line_char_count = word_char_count;
</span><span class="boring">                        *state = Some((line_start, line_end, final_end, line_char_count));
</span><span class="boring">                        Some(None)
</span><span class="boring">                    }
</span><span class="boring">                } else {
</span><span class="boring">                    // End of words.
</span><span class="boring">                    if let Some((line_start, _, final_end, _)) = state {
</span><span class="boring">                        // Finish the line.
</span><span class="boring">                        Some(Some((*line_start, *final_end)))
</span><span class="boring">                    } else {
</span><span class="boring">                        // Empty line.
</span><span class="boring">                        Some(Some((0, 0)))
</span><span class="boring">                    }
</span><span class="boring">                }
</span>            })
            .flatten()
            .map(move |(start, end)| &amp;line[start..end])
    })
<span class="boring">}
</span></code></pre></pre>
<p>And that's it!
If you run this code, you'll see the original input wrapped into lines no longer than 15 characters each.
Note that lines with non-ASCII multi-byte characters still count characters correctly, and hyphenated words are split across lines.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Using Rust's iterator API to perform word wrapping has a couple of advantages over something like hand-rolled loops.
As part of the standard library, I have strong confidence that these iterator adaptor functions are always correct.
Writing lots of nested loops by hand means extra code and lots of extra small book-keeping variables, each of which is a chance for bugs to slip in and cause headaches.
Using iterators also encapsulates all of these tracking variables into a single bundle inside the iterator: calling the <code>ruggrogue::word_wrap</code> function returns an iterator <em>immediately</em> so a <code>for</code> loop can process it all at its own pace.</p>
<p>However, I still don't feel like this iterator approach is the easiest code to read.
But in order to write a simpler version, stable Rust would need a language feature known as <em>generators</em>; look them up if you're curious.
Still, this word wrapping code manages to perform its work on demand, avoid memory allocations and is fast enough to run every frame, so all-in-all it worked out pretty well for the game.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entity-component-system"><a class="header" href="#entity-component-system">Entity Component System</a></h1>
<p>Up until now, most of the data that has been covered in this book has been about technical things that the game needs just to run, like input events, surfaces, textures and timing information.
But beyond that is the data that defines RuggRogue as a game, such as the player, the map, monsters and items.
This game-specific data is all managed by a crate named <a href="https://crates.io/crates/shipyard">Shipyard</a>, and this chapter is all about Shipyard and how RuggRogue uses it.</p>
<p>By its own description:</p>
<blockquote>
<p>Shipyard is an Entity Component System focused on usability and speed.</p>
</blockquote>
<p>Here, an <em>entity</em> is a lightweight ID whose role is to associate groups of <em>components</em> that hold the data describing the entity.
The main benefit of this is that it avoids the &quot;talking sword&quot; problem that you'd run into with an object-oriented approach: if you have NPCs that you can talk to, and a sword you can pick up and swing, how do you represent a talking sword?
In the object-oriented style of modelling game data, problems like this end up poking holes in the encapsulation the classes are supposed to have, and functionality drifts up the inheritance tree into a gigantic all-encompassing mega-class.
Game data modelled with entities and components instead avoids both of those issues; see Catherine West's RustConf 2018 closing keynote (<a href="https://www.youtube.com/watch?v=aKLntZcp27M">video</a> and <a href="https://kyren.github.io/2018/09/14/rustconf-talk.html">notes</a>) for more information.</p>
<p>In a game built fully in the ECS-style, <em>systems</em> are just functions that manipulate groups of entities according to what components they have.</p>
<!-- However, RuggRogue mostly does *not* use Shipyard's systems, for reasons that will be discussed later. -->
<h2 id="shipyard-04"><a class="header" href="#shipyard-04">Shipyard 0.4</a></h2>
<p>RuggRogue uses Shipyard <strong>0.4</strong>, but at the time of writing it is <em>not</em> the most recent version of Shipyard, which is <strong>0.5</strong>.
So what gives?
Well, 0.4 was the most up-to-date version of Shipyard when I started work on RuggRogue, and when 0.5 came out I ported the game over to it.
Unfortunately, <a href="https://github.com/tung/ruggrogue/commit/76454e69aa5734d98bda91869bdcec75f8152732">this broke the web build</a>, so it had to be reverted.
Therefore, RuggRogue uses Shipyard 0.4 and not 0.5.</p>
<p>In order to understand how RuggRogue reads and modifies its own game data, you'll need to understand the basics of Shipyard 0.4.
This is the point where I would link to the Shipyard 0.4 User's Guide that existed when I started writing the game, except it was replaced wholesale when Shipyard 0.5 came out, which has a bunch of differences.
I could build and host that old guide myself, but putting up documentation for an older version of somebody else's library with no indication that it's stale would be problematic.
As such, most of this chapter is going to serve as a crash course on Shipyard 0.4, which should provide a foundation for understanding the code in RuggRogue that works with game data.</p>
<p>If you have Rust installed and you have the RuggRogue source code, you can peruse a detailed reference to Shipyard 0.4's API, along with all of the other crates used by RuggRogue, by typing <code>cargo doc --open</code>.
Shipyard's source code also contains its user guide that can be built with <a href="https://crates.io/crates/mdbook">mdBook</a>, so you can check out older versions of its source code and run it through mdBook to read it.</p>
<h2 id="the-world"><a class="header" href="#the-world">The World</a></h2>
<p>All data in Shipyard is stored in a <code>World</code> that consists of:</p>
<ul>
<li><strong>Entities</strong>: They're just IDs, but the world tracks which ones are still alive.</li>
<li><strong>Components</strong>: Associated with entities; Shipyard stores components of each unique type in separate storages.</li>
<li><strong>Uniques</strong>: Like components, but not associated with any entity; often called <em>resources</em> in other Rust ECS crates.</li>
</ul>
<p>RuggRogue creates one as the very first thing in the <code>main</code> function in the <code>src/main.rs</code> file:</p>
<pre><code class="language-rust ignore">let world = World::new();
</code></pre>
<p>Every bit of data specific to RuggRogue as a game is stored in the world, such as the map, the player, monsters and items.</p>
<h2 id="uniques"><a class="header" href="#uniques">Uniques</a></h2>
<p>As mentioned above, a <em>unique</em> is some data stored in the world that isn't associated with an entity like a component would be.
They're not technically required in an ECS, but many Rust ECS crates provide something like them as a convenience.
For example, here's how RuggRogue stores the current game seed:</p>
<pre><code class="language-rust ignore">pub struct GameSeed(u64);

<span class="boring">let world = World::new();
</span>let game_seed = std::env::args()
    .nth(1)
    .and_then(|arg| arg.as_str().parse().ok())
    .unwrap_or_else(rand::random);

world.add_unique(GameSeed(game_seed)); // &lt;-- adding a unique to the world
</code></pre>
<p>Since RuggRogue uses a single world to store all game data and passes it everywhere, uniques effectively act like global variables, without a lot of the incidental downsides of actual global variables.</p>
<p>Unique data is accessed by requesting a <code>UniqueView</code> or <code>UniqueViewMut</code> borrow out of the world with <code>World::borrow</code>:</p>
<pre><code class="language-rust ignore">// immutable borrow of GameSeed unique
let game_seed = world.borrow::&lt;UniqueView&lt;GameSeed&gt;&gt;();
println!(&quot;{:?}&quot;, game_seed.0);
</code></pre>
<pre><code class="language-rust ignore">// mutable borrow of GameSeed unique
let game_seed = world.borrow::&lt;UniqueViewMut&lt;GameSeed&gt;&gt;();
game_seed.0 = 1234567890;
</code></pre>
<p>There is no way to remove or directly replace a unique in Shipyard 0.4.
The ability to remove uniques was only added in Shipyard 0.5, so RuggRogue hacks around this limitation when it needs to.</p>
<h2 id="entity-and-component-basics"><a class="header" href="#entity-and-component-basics">Entity and Component Basics</a></h2>
<p>An <em>entity</em> is a lightweight ID that's just a number in Shipyard's case.
A <em>component</em> is some data associated with an entity.
Each entity can have zero or one component of each type associated with it.</p>
<p>Entities are created with a special borrow of <code>EntitiesViewMut</code>, like so:</p>
<pre><code class="language-rust ignore">// creating a empty entity with no components
let mut entities = world.borrow::&lt;EntitiesViewMut&gt;();

let entity_id = entities.add_entity((), ());
</code></pre>
<p>Entities are often made starting out with component data that is modified using <code>ViewMut</code>:</p>
<pre><code class="language-rust ignore">struct Position {
    x: i32,
    y: i32,
}

struct Renderable {
    ch: char,
}

let mut entities = world.borrow::&lt;EntitiesViewMut&gt;();
let mut positions = world.borrow::&lt;ViewMut&lt;Position&gt;&gt;();
let mut renderables = world.borrow::&lt;ViewMut&lt;Renderable&gt;&gt;();

// creating an entity with a Position component and a Renderable component
let entity_id = entities.add_entity(
    (&amp;mut positions, &amp;mut renderables),
    (
        Position { x: 1, y: 2 },
        Renderable { ch: '@' },
    ),
);
</code></pre>
<p>Deleting an entity requires clearing it out of every component storage, and thus requires the special <code>AllStoragesViewMut</code> borrow:</p>
<pre><code class="language-rust ignore">let mut all_storages = world.borrow::&lt;AllStoragesViewMut&gt;();

all_storages.delete(entity_id_to_delete);
</code></pre>
<p>Components can be added to entities after creation with an immutable <code>EntitiesView</code> borrow along with mutable <code>ViewMut</code> component borrows of the relevant storages:</p>
<pre><code class="language-rust ignore">struct Name(String);

struct GivesExperience(u64);

let entities = world.borrow::&lt;EntitiesView&gt;();
let mut gives_experiences = world.borrow::&lt;ViewMut&lt;GivesExperience&gt;&gt;();
let mut names = world.borrow::&lt;ViewMut&lt;Name&gt;&gt;();

// adding Name and GivesExperience components to goblin_entity_id
entities.add_component(
    (&amp;mut gives_experiences, &amp;mut names),
    (
        GivesExperience(20),
        Name(&quot;Goblin&quot;.to_string()),
    ),
    goblin_entity_id,
);
</code></pre>
<p>Components can be deleted from an entity on demand with just a mutable <code>ViewMut</code> borrow on the relevant component storage:</p>
<pre><code class="language-rust ignore">let mut names = world.borrow::&lt;ViewMut&lt;Name&gt;&gt;();

names.delete(entity_id_to_make_nameless);
</code></pre>
<p>To check if an entity has a component, we can check if the <code>View</code> of the component storage contains the entity ID:</p>
<pre><code class="language-rust ignore">struct Monster; // &lt;-- empty tag struct

if world.borrow::&lt;View&lt;Monster&gt;&gt;().contains(entity_id) {
    // entity_id has a Monster component
}
</code></pre>
<p>A component can be checked for and accessed via a <code>View</code> or <code>ViewMut</code> as well using Rust's <code>if let</code> pattern matching syntax:</p>
<pre><code class="language-rust ignore">struct CombatStats {
    hp: i32,
}

let mut combat_stats = world.borrow::&lt;ViewMut&gt;();

if let Ok(combat_stats) = (&amp;mut combat_stats).try_get(entity_id) {
    // entity_id has a CombatStats component, so do a bit of damage to it
    combat_stats.hp -= 1;
}
</code></pre>
<h2 id="iterating-entities-and-components"><a class="header" href="#iterating-entities-and-components">Iterating Entities and Components</a></h2>
<p>A common operation in RuggRogue is to iterate over all entities that have a certain set of components on them.
That can be achieved with the <code>iter</code> function of the <code>Shipyard::IntoIter</code> trait:</p>
<pre><code class="language-rust ignore">use Shipyard::IntoIter;

struct Name(String);

struct Position {
    x: i32,
    y: i32,
}

let names = world.borrow::&lt;View&lt;Name&gt;&gt;();
let positions = world.borrow::&lt;View&lt;Position&gt;&gt;();

// iterate over all entities that have both Name and Position components
for (name, pos) in (&amp;names, &amp;positions).iter() {
    println!(&quot;{} is at ({},{})&quot;, name.0, pos.x, pos.y);
}
</code></pre>
<p>The entity IDs can be retrieved as well using the <code>with_id</code> function from <code>Shipyard::Shiperator</code>:</p>
<pre><code class="language-rust ignore">use Shipyard::IntoIter;
use Shipyard::Shiperator;

for (id, (name, pos)) in (&amp;names, &amp;positions).iter().with_id() {
    // do something with id, name and pos
}
</code></pre>
<p>I believe <code>Shipyard::IntoIter</code> and <code>Shipyard::Shiperator</code> are no longer needed in Shipyard 0.5; consult its current documentation if you want to know more.</p>
<h2 id="the-entityid"><a class="header" href="#the-entityid">The EntityId</a></h2>
<p>Entities are uniquely identified by the <code>Shipyard::EntityId</code> type, which, as mentioned before, is just a number internally.
Since it's so lightweight, we can use it to model relationships between different entities.
For example, here's what equipping a player entity with weapon and armor entities might look like:</p>
<pre><code class="language-rust ignore">struct Equipment {
    weapon: Option&lt;EntityId&gt;,
    armor: Option&lt;EntityId&gt;,
}

struct AttackBonus(i32);

struct DefenseBonus(i32);

// create the player, weapon and armor entities
let (player_id, weapon_id, armor_id) = {
    let mut entities = world.borrow::&lt;EntitiesViewMut&gt;();
    let mut attack_bonuses = world.borrow::&lt;ViewMut&lt;AttackBonus&gt;&gt;();
    let mut defense_bonuses = world.borrow::&lt;ViewMut&lt;DefenseBonus&gt;&gt;();
    let mut equipments = world.borrow::&lt;ViewMut&lt;Equipment&gt;&gt;();

    // Equipment component for the player
    let player_id = entities.add_entity(
        &amp;mut equipments,
        Equipment {
            weapon: None,
            armor: None,
        },
    );

    // AttackBonus component for the weapon
    let weapon_id = entities.add_entity(&amp;mut attack_bonuses, AttackBonus(2));

    // DefenseBonus component for the armor
    let armor_id = entities.add_entity(&amp;mut defense_bonuses, DefenseBonus(1));

    (player_id, weapon_id, armor_id)
};

// later on...
{
    let mut equipments = world.borrow::&lt;ViewMut&lt;Equipment&gt;&gt;();

    // equip the player if they have an Equipment component
    if let Ok(player_equip) = (&amp;mut equipments).try_get(player_id) {
        // put the weapon and armor in the player's Equipment component
        player_equip.weapon = Some(weapon_id);
        player_equip.armor = Some(armor_id);
    }
}
</code></pre>
<p>This pretty much covers all of the ways that RuggRogue uses Shipyard to handle its own game data.</p>
<!--
## Why not use Systems?

As mentioned earlier, RuggRogue uses Shipyard for entities and components, but it mostly does *not* use its systems.
From my prior experience of reading the source code of open source roguelikes, and sometimes tinkering with it too, the order and conditions under which logic is supposed to run needs to be precise.
With systems, a lot of synchronizing data is needed to define this precision; for example see how the Rust Roguelike Tutorial uses a ["WantsToAttack" component](https://bfnightly.bracketproductions.com/chapter_7.html#player-attacking-and-killing-things) as an ad-hoc queue to synchronize systems.
(I'd use an actual queue in that case, but that's still extra synchronizing data that's needed.)
Just sticking with functions, branches and loops avoids all of that, and it's what I'm more comfortable with, so it's the approach I chose for RuggRogue.
It seems like I arrived at a similar conclusion as Bob Nystrom in his talk about ECS and roguelikes ([video](https://www.youtube.com/watch?v=JxI3Eu5DPwE)).

However, if you read the source code of RuggRogue for a while, you'll see a fair number of uses of a `World::run` function with a closure:

```rust,ignore
world.run(|names: View<Name>, positions: View<Position>| {
    // Name and Position component storages borrowed in here
});
```

That's equivalent to this:

```rust,ignore
{
    let names = world.borrow::<View<Name>>();
    let positions = world.borrow::<View<Position>>();

    // Name and Position component storages borrowed in here
}
```

`World::run` is also used with functions:

```rust,ignore
fn do_something(names: View<Name>, positions: View<Position>) {
    // Name and Position component storages borrowed in here
}

// somewhere else...
world.run(do_something);
```

So what's `World::run` running here?
The functions and closures being put through `World::run` are *systems*, in Shipyard's terms.
So I lied a bit: RuggRogue does use systems.
What it doesn't use are Shipyard's notion of *workloads*, which are bundles of systems that are designed to be run together.
By avoiding workloads, RuggRogue is able to precisely dictate how and when logic runs without having to manage explicit synchronizing data.

In most of the code samples above, `World::borrow` is preferred over `World::run`.
In the RuggRogue source code in general, older code tended to use a lot of `World::run`, while newer code mostly prefers `World::borrow`.
But in the code we just saw, the code for the `World::run` versions is shorter and more convenient.
So why does RuggRogue prefer `World::borrow` over `World::run`?

Due to Rust's borrowing rules, a system cannot easily be called from within another system.
For instance, the following code will not compile:

```rust,ignore
fn my_subsystem(cs: View<C>) {
    // do stuff from cs...
}

{
    world.run(|bs: View<b>| {
        // do stuff with bs...
        world.run(my_subsystem); // <- Can't borrow 'world' twice!!!
    });
}
```

This could be reworked to compile by borrowing the `C` components *alongside* the `B` components, like so:

```rust,ignore
fn my_subsystem(cs: &View<C>) {
    // do stuff with cs...
}

{
    world.run(|bs: View<B>, cs: View<C>| {
        // do stuff with bs...
        my_subsystem(&cs);
    });
}
```

But it gets clumsier when introducing another system deeper in that wants, say, `D` components:

```rust,ignore
fn my_sub_subsystem(ds: &View<D>) {
    // do stuff with ds...
}

fn my_subsystem(cs: &View<C>, ds: &View<D>) { // <- Getting longer...
    // do stuff with cs...
    my_sub_subsystem(ds);
}

{
    world.run(|bs: View<B>, cs: View<C>, ds: View<D>| { // <- Getting longer...
        // do stuff with bs...
        my_subsystem(&cs, &ds); // <- Getting longer...
    });
}
```

Using `world::borrow` instead of `world::run` allows for fine-grained on-demand component access instead.
Here's the equivalent code the above, but using `world::borrow` instead of `world::run`:

```rust,ignore
fn my_sub_system(world: &World) {
    let ds = world.borrow::<View<D>>();
    // do stuff with ds...
}

fn my_subsystem(world:&World) {
    let cs = world.borrow::<View<C>>();
    // do stuff with cs...
    my_sub_subsystem(world);
}

{
    let bs = world.borrow::<View<B>>();
    // do stuff with bs...
    my_subsystem(world);
}
```

RuggRogue works with many different component types and functions that call each other, so `world:borrow` ends up being much easier to use most of the time.
`world::run` tends to be used with small, self-contained functions that don't call many other functions.
-->
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>You should now have a general idea of how RuggRogue stores and accesses its data using Shipyard.
Insofar as Rust ECS crates go, I'm so-so on Shipyard, since it came with a lot of functionality that I never used.
I could use it for future projects, but I can just as easily see myself exploring other options or even cobbling my own data storage to suit my own needs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="game-data"><a class="header" href="#game-data">Game Data</a></h1>
<p>The <a href="entity-component-system.html">Entity Component System chapter</a> covered <em>how</em> RuggRogue uses Shipyard to store its game data.
This chapter is all about <em>what</em> that data actually is.
<em>Game data</em> here refers to all the data that defines RuggRogue as a game that isn't just technical book-keeping, such as the player, the map, items and monsters.</p>
<p>As mentioned in the entity component system chapter, game data is divided into two kinds:</p>
<ol>
<li><em>Uniques</em> that are independent of entities.</li>
<li><em>Components</em> that are associated with an entity.</li>
</ol>
<p>All game data is stored in a world that's passed pretty much everywhere throughout the code of RuggRogue.
The world stores exactly one of each type of unique, and every entity has either zero or one instance of each type of component.
This chapter will provide a run-down of what each of those types are, and will wrap up by covering how and when entities are spawned and despawned.</p>
<h2 id="uniques-1"><a class="header" href="#uniques-1">Uniques</a></h2>
<p>The following types are stored as uniques in RuggRogue's game world.</p>
<h3 id="baseequipmentlevel"><a class="header" href="#baseequipmentlevel"><code>BaseEquipmentLevel</code></a></h3>
<p>Found in: <code>src/main.rs</code></p>
<p>32-bit integer of the minimum power level of weapons and armors that spawn throughout the game.
It's set when starting a new loop of New Game Plus to ensure that all spawned equipment in this loop will be more powerful than in the previous loop.</p>
<h3 id="camera"><a class="header" href="#camera"><code>Camera</code></a></h3>
<p>Found in: <code>src/chunked.rs</code></p>
<p>Position that should be centered upon when drawing the map on the main game screen.
Usually this is the position of the player, but it can be shifted around in view mode.</p>
<h3 id="difficulty"><a class="header" href="#difficulty"><code>Difficulty</code></a></h3>
<p>Found in: <code>src/experience.rs</code></p>
<p>Tracks the total amount of experience to be gained by defeating every monster on the current level, as well as the ID of an entity that gains experience like the player.
Together, this tracking data calculates how much experience the player could gain upon defeating all of the monsters on each level.
The outcome of this tracking is used to determine the power level of items and monsters spawned on future levels.</p>
<h3 id="gameseed"><a class="header" href="#gameseed"><code>GameSeed</code></a></h3>
<p>Found in: <code>src/main.rs</code></p>
<p>64-bit unsigned integer that is used to provide random number sequences that are unique to each playthrough.
It's set to a random value or via a command line argument when starting a new game.
Loading a game populates this value from the save file.</p>
<h3 id="map"><a class="header" href="#map"><code>Map</code></a></h3>
<p>Found in: <code>src/map.rs</code></p>
<p>The map of the current dungeon level.
Mainly consists of a grid of tiles representing the level itself, but also includes the current dungeon depth, tracking of tiles the player has previously seen and a spatial cache of positions to entities.</p>
<h3 id="menumemory"><a class="header" href="#menumemory"><code>MenuMemory</code></a></h3>
<p>Found in: <code>src/menu_memory.rs</code></p>
<p>Tracks the last cursor position in various menus throughout the game so that they can be restored when the menu is opened again.
This makes it easier for the player to deal with longer menus repeatedly.</p>
<h3 id="messages"><a class="header" href="#messages"><code>Messages</code></a></h3>
<p>Found in: <code>src/message.rs</code></p>
<p>Holds the message log that appears in the sidebar in the main gameplay screen.
It has a maximum capacity of messages, and old messages will be cleared out as new ones are added when this capacity is exceeded.</p>
<h3 id="monsterturns"><a class="header" href="#monsterturns"><code>MonsterTurns</code></a></h3>
<p>Found in: <code>src/monster.rs</code></p>
<p>A heap that holds the entity IDs of monsters that should be given a turn to act between player turns.
The heap gives turns to monsters nearest to the player first.</p>
<h3 id="options-1"><a class="header" href="#options-1"><code>Options</code></a></h3>
<p>Found in: <code>src/ui.rs</code></p>
<p>Stores the tilesets and zoom settings of the tile grids that show the map in the main gameplay mode and the user interface as a whole.</p>
<h3 id="pickuphint"><a class="header" href="#pickuphint"><code>PickUpHint</code></a></h3>
<p>Found in: <code>src/item.rs</code></p>
<p>A flag that determines whether the game should append a hint of the key to press to pick up items when the player steps over one.
It's set at the start of each new game, and is unset once the player picks up an item.</p>
<h3 id="playeralive"><a class="header" href="#playeralive"><code>PlayerAlive</code></a></h3>
<p>Found in: <code>src/player.rs</code></p>
<p>A flag that's <code>true</code> when the player is alive and <code>false</code> when they've died.
This determines whether the player should keep getting turns, as well as if they should get a win screen or game over screen when the game ends.</p>
<h3 id="playerid"><a class="header" href="#playerid"><code>PlayerId</code></a></h3>
<p>Found in: <code>src/player.rs</code></p>
<p>ID of the entity representing the player.
This is consulted pretty much universally throughout the game to read from or modify data associated with the player.</p>
<h3 id="turncount"><a class="header" href="#turncount"><code>TurnCount</code></a></h3>
<p>Found in: <code>src/main.rs</code></p>
<p>64-bit unsigned integer representing the number of elapsed turns since the start of each game.
It's shown in the user interface and in the game ending screens.</p>
<h3 id="wins"><a class="header" href="#wins"><code>Wins</code></a></h3>
<p>Found in: <code>src/main.rs</code></p>
<p>64-bit unsigned integer that counts the number of times the player has won the game.
This impacts the number of items and monsters that spawn in successive New Game Plus runs.</p>
<h2 id="components"><a class="header" href="#components">Components</a></h2>
<p>The following types represent components that are associated with entities.
As mentioned before, an entity can have either zero or one instance of each of these components.
Components can all be found in the <code>src/components.rs</code> file.</p>
<h3 id="areaofeffect"><a class="header" href="#areaofeffect"><code>AreaOfEffect</code></a></h3>
<p>Attached to item entities to determine the radius of their circular area of effect when they're used.</p>
<h3 id="asleep"><a class="header" href="#asleep"><code>Asleep</code></a></h3>
<p>Attached to player or monster entities when they are afflicted with the sleep status.
This contains a bit of hit point tracking to check if the affected entity took damage between turns, which reduces their sleepiness.</p>
<h3 id="blockstile"><a class="header" href="#blockstile"><code>BlocksTile</code></a></h3>
<p>Tag component that is attached monster entities to block other monsters from stepping into their tile.
This causes monsters to find paths around each other when pursuing the player.</p>
<h3 id="combatbonus"><a class="header" href="#combatbonus"><code>CombatBonus</code></a></h3>
<p>Attached to weapon and armor entities to determine how much extra attack and defense they confer when wielded or worn.</p>
<h3 id="combatstats"><a class="header" href="#combatstats"><code>CombatStats</code></a></h3>
<p>Attached to player and monster entities to track hit points, as well as hold base attack and defense values.
This is the main component that is dealt with during combat.
When hit points reach zero here, the entity dies.</p>
<h3 id="consumable"><a class="header" href="#consumable"><code>Consumable</code></a></h3>
<p>Tag component that is attached to items that indicates that the item can be used and that it will be consumed on use.</p>
<h3 id="coord"><a class="header" href="#coord"><code>Coord</code></a></h3>
<p>Attached to player, monster and item entities to hold their coordinates on the current level's map when they are on the map.
In particular, items will lose this component when picked up, and gain it again when dropped on the ground.</p>
<h3 id="equipslot"><a class="header" href="#equipslot"><code>EquipSlot</code></a></h3>
<p>Attached to item entities to determine whether they can be equipped as a weapon or armor.</p>
<h3 id="equipment"><a class="header" href="#equipment"><code>Equipment</code></a></h3>
<p>Tracks the entity IDs of the weapon and armor equipped by an entity.
In practice, only the player has one of these components.</p>
<h3 id="experience"><a class="header" href="#experience"><code>Experience</code></a></h3>
<p>Attached to the player to track their experience level and total experience points.
The <code>Difficulty</code> unique also has an entity with this component attached to track the total experience that can be gained per dungeon level.</p>
<h3 id="fieldofview"><a class="header" href="#fieldofview"><code>FieldOfView</code></a></h3>
<p>Attached to players and monsters to determine their immediate fields of view.
It consists of a grid of flags that track which tiles are visible relative to a position on the map.</p>
<h3 id="givesexperience"><a class="header" href="#givesexperience"><code>GivesExperience</code></a></h3>
<p>Attached to monsters to determine how many experience points they should grant when defeated.</p>
<h3 id="hurtby"><a class="header" href="#hurtby"><code>HurtBy</code></a></h3>
<p>Attached to entities that take damage to track the source of that damage.
This is used to determine who to grant experience to when something dies, as well as provide a reason on the game over screen when the player dies.
This component is cleared from all entities at the end of each turn.</p>
<h3 id="inflictsdamage"><a class="header" href="#inflictsdamage"><code>InflictsDamage</code></a></h3>
<p>Attached to consumable items to determine how much damage they should inflict when used.</p>
<h3 id="inflictssleep"><a class="header" href="#inflictssleep"><code>InflictsSleep</code></a></h3>
<p>Attached to items to inflict sleep on targeted entities when used.</p>
<h3 id="inventory"><a class="header" href="#inventory"><code>Inventory</code></a></h3>
<p>Attached to an entity to hold items that the entity picks up.
In practice, only the player is given one of these.</p>
<h3 id="item"><a class="header" href="#item"><code>Item</code></a></h3>
<p>Tag component attached to an entity to indicate that it is an item.
An entity must have this component in order to appear in the player's pick up menu.</p>
<h3 id="monster"><a class="header" href="#monster"><code>Monster</code></a></h3>
<p>Tag component attached to an entity to indicate that it is a monster.
This grants turns and artificial intelligence to the entity that they belong to between player turns.</p>
<h3 id="name"><a class="header" href="#name"><code>Name</code></a></h3>
<p>Attached to entities to refer to them in menus and messages throughout the game.</p>
<h3 id="nutrition"><a class="header" href="#nutrition"><code>Nutrition</code></a></h3>
<p>Attached to items to provide nutrition when used.</p>
<h3 id="player"><a class="header" href="#player"><code>Player</code></a></h3>
<p>Attached to the player to store player-specific data, which in practice is tracking of their auto-run state.
There's a few places in the code that try to support multiple players, but the vast majority of the game logic leans on the singular <code>PlayerId</code> unique instead.</p>
<h3 id="provideshealing"><a class="header" href="#provideshealing"><code>ProvidesHealing</code></a></h3>
<p>Attached to items to indicate the amount of hit points they should restore on their targets.</p>
<h3 id="ranged"><a class="header" href="#ranged"><code>Ranged</code></a></h3>
<p>Attached to consumable items to indicate that they can be used on a target at range.
If the player uses an item with this component, they can target a distant space with the item.
If the item also has an <code>AreaOfEffect</code> component, that distant space will be the center of the area of effect.</p>
<h3 id="renderonfloor"><a class="header" href="#renderonfloor"><code>RenderOnFloor</code></a></h3>
<p>One of two tag components that tells the game to draw the entity on the map.
Entities with this component are drawn below entities with a <code>RenderOnMap</code> component.</p>
<h3 id="renderonmap"><a class="header" href="#renderonmap"><code>RenderOnMap</code></a></h3>
<p>One of two tag components that tells the game to draw the entity on the map.
Entities with this component are drawn above entities with a <code>RenderOnFloor</code> component.</p>
<h3 id="renderable"><a class="header" href="#renderable"><code>Renderable</code></a></h3>
<p>Attached to entities that are drawn on the map to determine their visual appearance, such as their game symbol, foreground and background colors.</p>
<h3 id="stomach"><a class="header" href="#stomach"><code>Stomach</code></a></h3>
<p>Attached to the player to give them hunger and regeneration mechanics.
Fullness tracked in this component slowly drains over time, and is replenished when an item with a <code>Nutrition</code> component is used.
An entity with normal levels of fullness will slowly regenerate hit points over time.
An entity with an empty stomach will instead take damage over time.</p>
<h3 id="tally"><a class="header" href="#tally"><code>Tally</code></a></h3>
<p>Attached to the player to track interesting statistics throughout the course of their game, such as damage taken, damage inflicted and number of defeated monsters.
The statistics are shown to the player when their game ends, win or lose.</p>
<h3 id="victory"><a class="header" href="#victory"><code>Victory</code></a></h3>
<p>Tag component attached to an item that results in the player winning the game when the item is used.
One item with this specific component is spawned once the player has descended deep enough into the dungeon.</p>
<h2 id="spawning-entities"><a class="header" href="#spawning-entities">Spawning Entities</a></h2>
<p>All entity spawning logic is centralized in the <code>src/spawn.rs</code> file.
Most entities are spawned at map generation time when the <code>fill_rooms_with_spawns</code> function is called, which in turn calls the following functions:</p>
<ul>
<li><code>spawn_guaranteed_equipment</code> to spawn level-appropriate equipment at an steady but unpredictable pace.</li>
<li><code>spawn_guaranteed_ration</code> to spawn a single ration per level.</li>
<li><code>fill_room_with_spawns</code> to randomly populate rooms with items and monsters.</li>
</ul>
<p>Items are spawned via the <code>spawn_random_item_at</code> function that calls one of the following functions at random:</p>
<ul>
<li><code>spawn_weapon</code></li>
<li><code>spawn_armor</code></li>
<li><code>spawn_health_potion</code></li>
<li><code>spawn_magic_missile_scroll</code></li>
<li><code>spawn_fireball_scroll</code></li>
<li><code>spawn_sleep_scroll</code></li>
</ul>
<p>The <code>spawn_weapon</code> and <code>spawn_armor</code> functions consider the current difficulty to determine the power level of the equipment they create.</p>
<p>Monsters are spawned via the <code>spawn_random_monster</code> function that then calls the <code>spawn_monster</code> function to create the monster entity itself.
Like the <code>spawn_weapon</code> and <code>spawn_armor</code> functions, the <code>spawn_monster</code> function considers the current difficulty level when determining the monster to create and its power level.</p>
<p>The positions of entities that exist on the map are stored in the <code>Coord</code> component of the entity.
This means that an entity with a <code>Coord</code> component is considered to be &quot;on the map&quot;.
In addition to this, the map maintains a <em>spatial cache</em> that tracks a list of entity IDs for any given position.
This may seem redundant, but it drastically improves performance when dealing with entities by position by avoiding the need to iterate over all entities and check their positions manually.
The consequence of all this is that any entity that is added to the map needs to be given a <code>Coord</code> component <em>and</em> be placed correctly in the map's spatial cache.
Items and monsters are placed in the spatial cache at the end of their respective spawn-related functions.
This placement is done by calling the <code>Map::place_entity</code> function, whose definition can be found in the <code>src/map.rs</code> file.</p>
<p>There are exactly two entities that are <em>not</em> automatically added to the map's spatial cache: the difficulty tracker and the player.</p>
<p>The difficulty tracking entity has only an <code>Experience</code> component.
Its role is to track the total amount of experience that could be gained by defeating all monsters on the current map in order to gauge an appropriate power level to spawn items and monsters on future levels.
The difficulty tracking entity is created by the <code>spawn_difficulty</code> function in the <code>src/spawn.rs</code> file, and its entity ID is stored in the <code>id</code> field of the unique <code>Difficulty</code> struct defined in the <code>src/experience.rs</code> file.
The difficulty tracking entity is spawned when a new game is started, namely in the <code>new_game_setup</code> function defined in the <code>src/modes/title.rs</code> file.</p>
<p>The player entity is created by the <code>spawn_player</code> function defined in the <code>src/spawn.rs</code> file, which is called when starting a new game in the <code>new_game_setup</code> function.
The ID of the player entity is needed almost everywhere in the game, so it's stored in the <code>PlayerId</code> unique for easy access.
As mentioned before, the player entity is not automatically added to the map's spatial cache, but unlike the difficulty tracking entity, it eventually needs to be added so that the player can move around and do things on the map.
When this needs to happen, the <code>add_coords_to_players</code> function (defined in <code>src/player.rs</code>) is called, followed by the <code>place_player_in_first_room</code> function (defined in <code>src/map.rs</code>) to position it and add it to the spatial cache.</p>
<p>You may notice that the difficulty tracking and player entities are also created in the <code>main</code> function in the <code>src/main.rs</code> file.
These are dummy entities whose only purpose is to guarantee that these entities exist so that code that replaces these entities can despawn them unconditionally, which makes their logic simpler.</p>
<h2 id="despawning-entities"><a class="header" href="#despawning-entities">Despawning Entities</a></h2>
<p>Entities are despawned for a number of reasons:</p>
<ol>
<li>Despawning items and monsters when moving between dungeon levels.</li>
<li>Despawning monsters when they are defeated.</li>
<li>Despawning items and monsters after the game over sequence.</li>
<li>Despawning old entities when starting or loading a game.</li>
</ol>
<p>We'll cover each of these in turn.</p>
<h3 id="moving-between-dungeon-levels"><a class="header" href="#moving-between-dungeon-levels">Moving Between Dungeon Levels</a></h3>
<p>The simplest and most common reason for entities to be despawned is when the player descends to the next dungeon level.
Moving between levels means replacing the current map with a fresh map, which in turn means despawning entities on the current map so they can be replaced with new spawns.
This is the task of the <code>despawn_coord_entities</code> function (defined in <code>src/spawn.rs</code>), which is called by the <code>player_do_descend</code> function (defined in <code>src/player.rs</code>) when the player takes the downstairs of the current level.
It simply despawns entities that have a <code>Coord</code> component, which are the ones that belong to the map.</p>
<p>But the player has a <code>Coord</code> component; how does it avoid being despawned when moving between levels?
The answer is simple: all entities with the <code>Player</code> tag component are stripped of their <code>Coord</code> component by the <code>remove_coords_from_players</code> function in the <code>src/player.rs</code> file.
Once this despawning is done, player entities regain their <code>Coord</code> component through the <code>add_coords_to_players</code> function in the same file.</p>
<p>There's also the matter of the items belonging to the player: how do they avoid being despawned between levels?
The <code>Coord</code> component is removed from items while being picked up by the <code>remove_item_from_map</code> function in the <code>src/item.rs</code> file.
Conversely, a <code>Coord</code> component is attached to dropped items by the <code>add_item_to_map</code> function in the same file.
These functions take care to manage the map's spatial cache, which must be correct while the map exists.</p>
<h3 id="defeating-monsters"><a class="header" href="#defeating-monsters">Defeating Monsters</a></h3>
<p>The next most common reason to despawn entities is when the player defeats a monster.
This is the job of the <code>despawn_entity</code> function in the <code>src/spawn.rs</code> file, which despawns an entity by its ID.
This is called when a monster dies in the <code>handle_dead_entities</code> function in the <code>src/damage.rs</code> file.
The monster is removed from the map's spatial cache just before being despawned, for the same reason as when an item is picked up off the map.</p>
<h3 id="after-game-over"><a class="header" href="#after-game-over">After Game Over</a></h3>
<p>The game over sequence is where things get interesting with respect to entity despawning.
When a monster is defeated, it's despawned as usual.
However, when the player is defeated, their entity is <em>not</em> despawned.
Instead, the unique <code>PlayerAlive</code> flag is set to <code>false</code>, and the player is whisked away to the game over screen.</p>
<p>The game over screen shows a bunch of information about the player at the time that they were defeated, but it also shows the reason that they were defeated to begin with.
If the reason is due to a monster, then it needs the name of the monster in order to display it.
This means that the monster entity still exists in the game over screen.
In fact, the entire map and all the entities in it still exist in the game over screen!
It is only when the player leaves the game over screen that it clears up most of these entities by calling the <code>post_game_cleanup</code> function in the <code>src/modes/title.rs</code> file, which calls the <code>despawn_coord_entities</code> function mentioned earlier to do its heavy lifting.</p>
<p>There is exactly <em>one</em> entity that is not despawned by the <code>post_game_cleanup</code> function: the player entity.
The reason for this is to support the new game plus feature, which carries the player into the next iteration of the game, items, stats and all.</p>
<h3 id="starting-or-loading-a-game"><a class="header" href="#starting-or-loading-a-game">Starting or Loading a Game</a></h3>
<p>If the <code>post_game_cleanup</code> function never despawns the player, then what does?
In the case of starting a new game, this is done by the <code>new_game_setup</code> function in the <code>src/modes/title.rs</code> file.
This is why the dummy player entity is created when the game is first launched: it simplifies this logic.</p>
<p>Meanwhile, loading a game from a save file pretty much loads replacement entities for everything.
Assuming the load was successful, all of the old entities are manually despawned by the loading code using the <code>despawn_entity</code> function that you should probably be familiar with now.
This despawning is done by the <code>load_game</code> function in the <code>src/saveload.rs</code> file.</p>
<p>If you take a moment to think, you'll realize there's something missing in this explanation: what happens to the inventory items and equipment carried by the player when the player is despawned?
The answer is that all of those are despawned as well in the <code>despawn_entity</code> function.
The code in that function gathers up the entity IDs of any equipped weapon and armor, as well as the entity IDs of all inventory items, and deletes them along with the original entity itself.</p>
<p>All of this ceremony around despawning entities referred to by other entities is needed to avoid leaving entities <em>unreachable</em>.
An entity is considered reachable if:</p>
<ol>
<li>Its ID is stored in a unique, e.g. the <code>id</code> field of the <code>Difficulty</code> unique, or the <code>PlayerId</code>.</li>
<li>It has a <code>Coord</code> component, meaning that it exists on the current map.</li>
<li>Its ID is stored in a component owned by another entity that is reachable, like the <code>Equipment</code> or <code>Inventory</code> components.</li>
</ol>
<p>If an entity doesn't fit in any of the above cases, it is considered unreachable, which is the equivalent of a memory leak.
By despawning entities through the <code>despawn_entity</code> function instead of deleting them raw, we avoid making entities unreachable and thus leaking memory.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="saving-and-loading"><a class="header" href="#saving-and-loading">Saving and Loading</a></h1>
<p>RuggRogue features a pretty basic save system.
When the player chooses to save and exit from the options menu, all game data is written into a save file.
The title screen will detect the presence of this file and show an option to load the game.
The game also auto-saves at a couple of other points, such as when the player takes the stairs, and when they're about to win the game.
If the player dies, any detected save file is deleted.
If the player chooses to start a new game and a save file exists, a prompt will appear to delete it first.</p>
<p>All of this save-and-load action happens in the fittingly-named <code>src/saveload.rs</code> file, which will be the focus of most of this chapter.</p>
<h2 id="the-save-file-format"><a class="header" href="#the-save-file-format">The Save File Format</a></h2>
<p>When the game is saved, save data will be written to a file named <code>savegame.txt</code> in the same directory as the game itself.
This file is in plain text format where each line represents either a unique or a component, made up of three tab-separated fields of data.
Each unique line consists of an asterisk character, the type name of the unique and the unique data.
Each component line consists of the ID of the entity it belongs to, the type name of the component and the component data.</p>
<p>Here is an example of the contents of a small, complete save file:</p>
<pre><code class="language-plaintext">*	GameSeed	9542716676452101438
*	TurnCount	10
*	Wins	0
*	BaseEquipmentLevel	0
*	Difficulty	{&quot;id&quot;:[8,0],&quot;exp_for_next_depth&quot;:40}
*	Messages	{&quot;capacity&quot;:100,&quot;msg_queue&quot;:[&quot;This is a test save!&quot;],&quot;num_highlighted&quot;:0}
*	PlayerAlive	true
*	PlayerId	[5,0]
*	Map	{&quot;depth&quot;:1,&quot;width&quot;:80,&quot;height&quot;:50,&quot;tiles&quot;:[[&quot;W&quot;,1952],[&quot;F&quot;,8],[&quot;W&quot;,72],[&quot;F&quot;,8],[&quot;W&quot;,72],[&quot;F&quot;,8],[&quot;W&quot;,72],[&quot;F&quot;,8],[&quot;W&quot;,72],[&quot;F&quot;,8],[&quot;W&quot;,72],[&quot;F&quot;,8],[&quot;W&quot;,72],[&quot;F&quot;,8],[&quot;W&quot;,72],[&quot;F&quot;,8],[&quot;W&quot;,1760]],&quot;rooms&quot;:[{&quot;x1&quot;:32,&quot;y1&quot;:24,&quot;x2&quot;:39,&quot;y2&quot;:31}],&quot;seen&quot;:{&quot;width&quot;:80,&quot;height&quot;:50,&quot;bv&quot;:[[1,4000]]}}
[2,0]	BlocksTile	null
[3,0]	CombatBonus	{&quot;attack&quot;:0.0,&quot;defense&quot;:1.4}
[4,0]	CombatBonus	{&quot;attack&quot;:3.2,&quot;defense&quot;:0.0}
[5,0]	CombatStats	{&quot;max_hp&quot;:40,&quot;hp&quot;:40,&quot;attack&quot;:4.8,&quot;defense&quot;:2.4}
[2,0]	CombatStats	{&quot;max_hp&quot;:14,&quot;hp&quot;:14,&quot;attack&quot;:8.0,&quot;defense&quot;:4.0}
[6,0]	Consumable	null
[7,0]	Consumable	null
[5,0]	Coord	{&quot;x&quot;:33,&quot;y&quot;:25}
[7,0]	Coord	{&quot;x&quot;:33,&quot;y&quot;:30}
[2,0]	Coord	{&quot;x&quot;:38,&quot;y&quot;:30}
[6,0]	Coord	{&quot;x&quot;:38,&quot;y&quot;:25}
[3,0]	EquipSlot	&quot;Armor&quot;
[4,0]	EquipSlot	&quot;Weapon&quot;
[5,0]	Equipment	{&quot;weapon&quot;:[4,0],&quot;armor&quot;:[3,0]}
[5,0]	Experience	{&quot;level&quot;:1,&quot;exp&quot;:0,&quot;next&quot;:50,&quot;base&quot;:0}
[8,0]	Experience	{&quot;level&quot;:1,&quot;exp&quot;:0,&quot;next&quot;:50,&quot;base&quot;:0}
[2,0]	Experience	{&quot;level&quot;:1,&quot;exp&quot;:0,&quot;next&quot;:0,&quot;base&quot;:0}
[5,0]	FieldOfView	{&quot;tiles&quot;:{&quot;width&quot;:17,&quot;height&quot;:17,&quot;bv&quot;:[[0,108],[1,10],[0,7],[1,10],[0,7],[1,10],[0,7],[1,10],[0,7],[1,10],[0,7],[1,10],[0,7],[1,10],[0,7],[1,9],[0,8],[1,9],[0,8],[1,7],[0,21]]},&quot;range&quot;:8,&quot;center&quot;:[33,25],&quot;dirty&quot;:false}
[2,0]	FieldOfView	{&quot;tiles&quot;:{&quot;width&quot;:17,&quot;height&quot;:17,&quot;bv&quot;:[[0,21],[1,7],[0,8],[1,9],[0,8],[1,9],[0,7],[1,10],[0,7],[1,10],[0,7],[1,10],[0,7],[1,10],[0,7],[1,10],[0,7],[1,10],[0,7],[1,10],[0,108]]},&quot;range&quot;:8,&quot;center&quot;:[38,30],&quot;dirty&quot;:false}
[2,0]	GivesExperience	10
[5,0]	Inventory	{&quot;items&quot;:[]}
[3,0]	Item	null
[4,0]	Item	null
[6,0]	Item	null
[7,0]	Item	null
[2,0]	Monster	null
[6,0]	Name	&quot;Health Potion&quot;
[7,0]	Name	&quot;Ration&quot;
[5,0]	Name	&quot;Player&quot;
[3,0]	Name	&quot;+1 Jerkin&quot;
[4,0]	Name	&quot;+1 Knife&quot;
[2,0]	Name	&quot;Blob&quot;
[7,0]	Nutrition	750
[5,0]	Player	{}
[6,0]	ProvidesHealing	{&quot;heal_amount&quot;:15}
[7,0]	RenderOnFloor	null
[6,0]	RenderOnFloor	null
[5,0]	RenderOnMap	null
[2,0]	RenderOnMap	null
[6,0]	Renderable	{&quot;sym&quot;:&quot;HealthPotion&quot;,&quot;fg&quot;:{&quot;r&quot;:255,&quot;g&quot;:0,&quot;b&quot;:255},&quot;bg&quot;:{&quot;r&quot;:0,&quot;g&quot;:0,&quot;b&quot;:0}}
[7,0]	Renderable	{&quot;sym&quot;:&quot;Ration&quot;,&quot;fg&quot;:{&quot;r&quot;:191,&quot;g&quot;:92,&quot;b&quot;:0},&quot;bg&quot;:{&quot;r&quot;:0,&quot;g&quot;:0,&quot;b&quot;:0}}
[5,0]	Renderable	{&quot;sym&quot;:&quot;Player&quot;,&quot;fg&quot;:{&quot;r&quot;:255,&quot;g&quot;:255,&quot;b&quot;:0},&quot;bg&quot;:{&quot;r&quot;:0,&quot;g&quot;:0,&quot;b&quot;:0}}
[3,0]	Renderable	{&quot;sym&quot;:&quot;Jerkin&quot;,&quot;fg&quot;:{&quot;r&quot;:170,&quot;g&quot;:97,&quot;b&quot;:32},&quot;bg&quot;:{&quot;r&quot;:0,&quot;g&quot;:0,&quot;b&quot;:0}}
[4,0]	Renderable	{&quot;sym&quot;:&quot;Knife&quot;,&quot;fg&quot;:{&quot;r&quot;:165,&quot;g&quot;:165,&quot;b&quot;:165},&quot;bg&quot;:{&quot;r&quot;:0,&quot;g&quot;:0,&quot;b&quot;:0}}
[2,0]	Renderable	{&quot;sym&quot;:&quot;Blob&quot;,&quot;fg&quot;:{&quot;r&quot;:89,&quot;g&quot;:162,&quot;b&quot;:191},&quot;bg&quot;:{&quot;r&quot;:0,&quot;g&quot;:0,&quot;b&quot;:0}}
[5,0]	Stomach	{&quot;fullness&quot;:1491,&quot;max_fullness&quot;:1500,&quot;sub_hp&quot;:0}
[5,0]	Tally	{&quot;damage_dealt&quot;:0,&quot;damage_taken&quot;:0,&quot;kills&quot;:0}
</code></pre>
<p>If you have a native build of RuggRogue, you can copy and paste this into a file named <code>savegame.txt</code> and the game will load it.
The above save data contains the player, a monster and some items confined in a small enclosed room in the center of the map.
We can break down this example save data, starting with the top lines:</p>
<pre><code class="language-plaintext">*	GameSeed	9542716676452101438
*	TurnCount	10
*	Wins	0
*	BaseEquipmentLevel	0
*	Difficulty	{&quot;id&quot;:[8,0],&quot;exp_for_next_depth&quot;:40}
*	Messages	{&quot;capacity&quot;:100,&quot;msg_queue&quot;:[&quot;This is a test save!&quot;],&quot;num_highlighted&quot;:0}
*	PlayerAlive	true
*	PlayerId	[5,0]
*	Map	{&quot;depth&quot;:1,&quot;width&quot;:80,&quot;height&quot;:50,&quot;tiles&quot;:[[&quot;W&quot;,1952],[&quot;F&quot;,8],[&quot;W&quot;,72],[&quot;F&quot;,8],[&quot;W&quot;,72],[&quot;F&quot;,8],[&quot;W&quot;,72],[&quot;F&quot;,8],[&quot;W&quot;,72],[&quot;F&quot;,8],[&quot;W&quot;,72],[&quot;F&quot;,8],[&quot;W&quot;,72],[&quot;F&quot;,8],[&quot;W&quot;,72],[&quot;F&quot;,8],[&quot;W&quot;,1760]],&quot;rooms&quot;:[{&quot;x1&quot;:32,&quot;y1&quot;:24,&quot;x2&quot;:39,&quot;y2&quot;:31}],&quot;seen&quot;:{&quot;width&quot;:80,&quot;height&quot;:50,&quot;bv&quot;:[[1,4000]]}}
</code></pre>
<p>All of these lines represent uniques, since they all start with an asterisk character.
There's some basic data for uniques such as <code>GameSeed</code>, <code>TurnCount</code>, <code>Wins</code> and <code>PlayerAlive</code> whose data should hopefully be self-explanatory.
Looking at some of the other lines reveals that all data is serialized in JSON format.</p>
<p>The line for the <code>Map</code> unique is interesting here.
The <code>&quot;tiles&quot;</code> field stores the contents of each tile in the map: <code>&quot;W&quot;</code> is a wall, <code>&quot;F&quot;</code> is a floor and <code>&quot;D&quot;</code> would be a downstairs tile that isn't featured in this tile data.
Tiles have a lot of redundancy, so they're stored in a special compressed form that will be covered later in this chapter.
Even with compression, this <code>Map</code> line will often be a lot longer than this in a typical save file.</p>
<p>You may have noticed the pairs of numbers present in the lines for the <code>Difficulty</code> and the <code>PlayerId</code> uniques.
These are entity IDs, so each pair uniquely identifies a entity.
Here, the difficulty tracker is represented by the <code>[8,0]</code> entity, while the player is represented by the <code>[5,0]</code> entity.</p>
<p>We can peek at the component data for the difficulty tracker by singling out lines of component data starting with the <code>[8,0]</code> entity ID, of which there is just one:</p>
<pre><code class="language-plaintext">[8,0]	Experience	{&quot;level&quot;:1,&quot;exp&quot;:0,&quot;next&quot;:50,&quot;base&quot;:0}
</code></pre>
<p>As we can see, the difficulty tracking entity has a single <code>Experience</code> component that is at level 1 and will advance to the next level once it gains 50 experience points.</p>
<p>Filtering for the player by looking at lines starting with <code>[5,0]</code> shows that they hold a lot more data:</p>
<pre><code class="language-plaintext">[5,0]	CombatStats	{&quot;max_hp&quot;:40,&quot;hp&quot;:40,&quot;attack&quot;:4.8,&quot;defense&quot;:2.4}
[5,0]	Coord	{&quot;x&quot;:33,&quot;y&quot;:25}
[5,0]	Equipment	{&quot;weapon&quot;:[4,0],&quot;armor&quot;:[3,0]}
[5,0]	Experience	{&quot;level&quot;:1,&quot;exp&quot;:0,&quot;next&quot;:50,&quot;base&quot;:0}
[5,0]	FieldOfView	{&quot;tiles&quot;:{&quot;width&quot;:17,&quot;height&quot;:17,&quot;bv&quot;:[[0,108],[1,10],[0,7],[1,10],[0,7],[1,10],[0,7],[1,10],[0,7],[1,10],[0,7],[1,10],[0,7],[1,10],[0,7],[1,9],[0,8],[1,9],[0,8],[1,7],[0,21]]},&quot;range&quot;:8,&quot;center&quot;:[33,25],&quot;dirty&quot;:false}
[5,0]	Inventory	{&quot;items&quot;:[]}
[5,0]	Name	&quot;Player&quot;
[5,0]	Player	{}
[5,0]	RenderOnMap	null
[5,0]	Renderable	{&quot;sym&quot;:&quot;Player&quot;,&quot;fg&quot;:{&quot;r&quot;:255,&quot;g&quot;:255,&quot;b&quot;:0},&quot;bg&quot;:{&quot;r&quot;:0,&quot;g&quot;:0,&quot;b&quot;:0}}
[5,0]	Stomach	{&quot;fullness&quot;:1491,&quot;max_fullness&quot;:1500,&quot;sub_hp&quot;:0}
[5,0]	Tally	{&quot;damage_dealt&quot;:0,&quot;damage_taken&quot;:0,&quot;kills&quot;:0}
</code></pre>
<p>The player's <code>CombatStats</code> show that they're at 40 out of 40 hit points, with a base attack value of 4.8 and a base defense value of 2.4.
According to the <code>Coord</code> component they are located at coordinates 33,25.
Like the difficulty tracker, the player has an <code>Experience</code> component.
Components such as <code>Name</code>, <code>Renderable</code>, <code>Stomach</code> and <code>Tally</code> contain basic data.</p>
<p>The <code>RenderOnMap</code> component is a tag component with no data, so its serialized to the JSON <code>null</code> value.
The <code>Player</code> component would be saved the same way, except it stores some runtime data that doesn't need to be saved, so it comes out as an empty JSON object instead.</p>
<p>The <code>FieldOfView</code> component represents which tiles in the immediate vicinity of the player should be visible.
It's a very long line out of necessity since each line must hold the full data of either a unique or a component.
The <code>&quot;bv&quot;</code> field within the top-level <code>&quot;tiles&quot;</code> field is compressed in the same way as the tiles of the map unique.</p>
<p>The <code>Equipment</code> and <code>Inventory</code> components typically contain entity IDs.
Here, the player's inventory is empty, but they are armed with a weapon and armor.
Here are the lines for the weapon entity, which is a &quot;+1 Knife&quot;:</p>
<pre><code class="language-plaintext">[4,0]	CombatBonus	{&quot;attack&quot;:3.2,&quot;defense&quot;:0.0}
[4,0]	EquipSlot	&quot;Weapon&quot;
[4,0]	Item	null
[4,0]	Name	&quot;+1 Knife&quot;
[4,0]	Renderable	{&quot;sym&quot;:&quot;Knife&quot;,&quot;fg&quot;:{&quot;r&quot;:165,&quot;g&quot;:165,&quot;b&quot;:165},&quot;bg&quot;:{&quot;r&quot;:0,&quot;g&quot;:0,&quot;b&quot;:0}}
</code></pre>
<p>The player's armor is a &quot;+1 Jerkin&quot;:</p>
<pre><code class="language-plaintext">[3,0]	CombatBonus	{&quot;attack&quot;:0.0,&quot;defense&quot;:1.4}
[3,0]	EquipSlot	&quot;Armor&quot;
[3,0]	Item	null
[3,0]	Name	&quot;+1 Jerkin&quot;
[3,0]	Renderable	{&quot;sym&quot;:&quot;Jerkin&quot;,&quot;fg&quot;:{&quot;r&quot;:170,&quot;g&quot;:97,&quot;b&quot;:32},&quot;bg&quot;:{&quot;r&quot;:0,&quot;g&quot;:0,&quot;b&quot;:0}}
</code></pre>
<p>There's a &quot;Health Potion&quot; that's on the floor at coordinates 38,25:</p>
<pre><code class="language-plaintext">[6,0]	Consumable	null
[6,0]	Coord	{&quot;x&quot;:38,&quot;y&quot;:25}
[6,0]	Item	null
[6,0]	Name	&quot;Health Potion&quot;
[6,0]	ProvidesHealing	{&quot;heal_amount&quot;:15}
[6,0]	RenderOnFloor	null
[6,0]	Renderable	{&quot;sym&quot;:&quot;HealthPotion&quot;,&quot;fg&quot;:{&quot;r&quot;:255,&quot;g&quot;:0,&quot;b&quot;:255},&quot;bg&quot;:{&quot;r&quot;:0,&quot;g&quot;:0,&quot;b&quot;:0}}
</code></pre>
<p>Finally, there's an enemy &quot;Blob&quot; in the opposite corner of the room to the player:</p>
<pre><code class="language-plaintext">[2,0]	BlocksTile	null
[2,0]	CombatStats	{&quot;max_hp&quot;:14,&quot;hp&quot;:14,&quot;attack&quot;:8.0,&quot;defense&quot;:4.0}
[2,0]	Coord	{&quot;x&quot;:38,&quot;y&quot;:30}
[2,0]	Experience	{&quot;level&quot;:1,&quot;exp&quot;:0,&quot;next&quot;:0,&quot;base&quot;:0}
[2,0]	FieldOfView	{&quot;tiles&quot;:{&quot;width&quot;:17,&quot;height&quot;:17,&quot;bv&quot;:[[0,21],[1,7],[0,8],[1,9],[0,8],[1,9],[0,7],[1,10],[0,7],[1,10],[0,7],[1,10],[0,7],[1,10],[0,7],[1,10],[0,7],[1,10],[0,7],[1,10],[0,108]]},&quot;range&quot;:8,&quot;center&quot;:[38,30],&quot;dirty&quot;:false}
[2,0]	GivesExperience	10
[2,0]	Monster	null
[2,0]	Name	&quot;Blob&quot;
[2,0]	RenderOnMap	null
[2,0]	Renderable	{&quot;sym&quot;:&quot;Blob&quot;,&quot;fg&quot;:{&quot;r&quot;:89,&quot;g&quot;:162,&quot;b&quot;:191},&quot;bg&quot;:{&quot;r&quot;:0,&quot;g&quot;:0,&quot;b&quot;:0}}
</code></pre>
<p>Monsters share a lot of common component types with the player, but they have a <code>Monster</code> tag component instead of a <code>Player</code> component.
The <code>BlocksTile</code> tag component marks that other monsters should take a path around this monster, rather than trying to go through it.</p>
<p>And that's it: a full run-down of a complete save file.
The format is pretty flexible: lines can technically occur in any order so long as every unique type is present.
Save data is considered valid as long as all entity IDs exist, and the existence of entities is implied by the ID values at the start of component lines.</p>
<h2 id="saving"><a class="header" href="#saving">Saving</a></h2>
<p>The <code>save_game</code> function is responsible for saving the game.
It's called from several other places in the code:</p>
<ol>
<li>In the <code>use_item</code> function in the <code>src/item.rs</code> file when the player uses the victory item.</li>
<li>In the <code>DungeonMode::update</code> function in <code>src/modes/dungeon.rs</code> in response to:
<ul>
<li>confirming when closing the game (the <code>AppQuitDialogModeResult::Confirmed</code> case)</li>
<li>taking the stairs (the <code>YesNoDialogModeResult::Yes</code> case)</li>
<li>choosing to save and exit from the options menu (the <code>OptionsMenuModeResult::ReallyQuit</code> case)</li>
</ul>
</li>
</ol>
<p>The logic of the <code>save_game</code> function is simple: open a buffered writer for the <code>savegame.txt</code> file, write lines for all uniques and component storages, then flush the buffered writer.
Since this is Rust, the writer will automatically be closed when it falls out of scope at the end of the function.</p>
<p>The writing of a unique line is handled by the <code>save_named_unique</code> function, which outputs the asterisk, the unique type name and the unique data in tab-separated form.
Used as-is, it would normally appear like this in the <code>save_game</code> function:</p>
<pre><code class="language-rust ignore">save_named_unique&lt;_, GameSeed&gt;(world, &amp;mut writer, &quot;GameSeed&quot;)?;
</code></pre>
<p>To avoid having to specify the type name of the unique twice, the <code>save_game</code> function instead uses a helper macro named <code>save_unique!</code>, shortening the above to:</p>
<pre><code class="language-rust ignore">save_unique!(GameSeed, world, &amp;mut writer)?;
</code></pre>
<p>While the <code>save_named_unique</code> function writes a single line for a unique, the <code>save_named_storage</code> function instead writes multiple lines for a given component type, one for each individual component.
Used as-is, it would look like this:</p>
<pre><code class="language-rust ignore">save_named_storage&lt;_, AreaOfEffect&gt;(world, &amp;mut writer, &quot;AreaOfEffect&quot;)?;
</code></pre>
<p>There's also a helper macro for this named <code>save_storage!</code> that shortens it to this instead:</p>
<pre><code class="language-rust ignore">save_storage!(AreaOfEffect, world, &amp;mut writer)?;
</code></pre>
<p>That's all there is to saving the game.
You should appreciate the simplicity of this, because the loading logic is a lot more involved.</p>
<p>It's worth noting what <em>isn't</em> being considered here: entity IDs.
It turns out that entity IDs are not only serializable, but they're 100% safe to save as-is with no further intervention.
If game data were stored and managed with something like references or pointers instead, it would need an <a href="https://en.wikipedia.org/wiki/Pointer_swizzling">unswizzling</a> strategy that would have to invade the data serialization logic.</p>
<h2 id="loading"><a class="header" href="#loading">Loading</a></h2>
<p>Saving is a relatively straightforward affair, free of branches and loops, with very simple error conditions.
Loading, on the other hand, is a lot more complex.
Part of this is due to how permissive the save file format is; in particular, lines for uniques and components can technically appear in any order and still be valid.
But a lot of this complexity comes from the fact that the very nature of loading involves setting up and altering a lot of data, which is something that the saving process never has to worry about.</p>
<p>The loading process can be broadly broken down into these major parts:</p>
<ol>
<li>Load data for each line in the save file:
<ul>
<li>If it starts with an asterisk, load the line as a unique.</li>
<li>Otherwise, try to load component data and attach it to a specific entity, creating it if it doesn't exist yet.</li>
</ul>
</li>
<li>Check that all uniques needed were loaded from the save file.</li>
<li>Fix entity IDs across all uniques and components that store them.</li>
<li>Place entities with <code>Coord</code> components on the map.</li>
<li>Commit the freshly-loaded uniques and entities to the world.</li>
<li>Despawn any entities that need to be despawned.</li>
</ol>
<p>We'll look at each part one at a time.</p>
<h3 id="handling-entity-despawning"><a class="header" href="#handling-entity-despawning">Handling Entity Despawning</a></h3>
<p>This is not a mistake: we're looking at the last phase first.
If you take a look at the <code>load_game</code> function, you'll notice that despawning entities is all that it really does; most of loading logic is instead handled by the <code>load_save_file</code> function that it calls.
Why is it set up like this?</p>
<p>To understand the answer, we need to step back and think about what loading actually means in terms of data.
While we read in each line of the save file, we'll be loading components.
In order to load components, we need to create new entities to attach them to.
At this point, there will be entities in the world that existed before loading began alongside newly-created entities spawned in the process of loading.
If loading fails, these new entities need to be despawned so that we don't have half-loaded entities floating about in the world.
Likewise, if loading succeeds, old entities need to be despawned since they've been fully replaced by the loaded entities and are thus no longer needed.</p>
<p>The sole purpose of the <code>load_game</code> function is to give a blank list for the <code>load_save_file</code> function to fill with the IDs of entities that need to be despawned, and guarantee that they are despawned afterwards.
The <code>load_game</code> function is called from the <code>TitleMode::update</code> function in the <code>src/modes/title.rs</code> file when the player chooses to load a game from the title screen.
If the <code>load_save_file</code> function fails to load the game, this list will contain the newly-loaded entity IDs so that they can be cleaned up.
If it succeeds, this list will instead contain the IDs of old entities that weren't part of the save file.</p>
<h3 id="loading-data-a-line-at-a-time"><a class="header" href="#loading-data-a-line-at-a-time">Loading Data a Line at a Time</a></h3>
<p>The loading of the save data proper is handled by the <code>load_save_file</code> function.
The top half of this function is dedicated to setting up for and loading the data out of the save file, one line at a time.</p>
<p>We can think of loaded data as transitioning through two phases: temporary and committed.
As the save file is processed a line at a time, data is loaded in some temporary form.
Once we're happy that everything was loaded successfully, we can take the temporary data and convert it into its committed form; the form that the rest of the game will see and deal with.</p>
<h4 id="loading-a-unique-line"><a class="header" href="#loading-a-unique-line">Loading a Unique Line</a></h4>
<p>The big loop near the beginning of the <code>load_save_file</code> function is what reads in each line of the save file.
Just before it are a bunch of lines that look like this:</p>
<pre><code class="language-rust ignore">let mut game_seed: Option&lt;GameSeed&gt; = None;
let mut turn_count: Option&lt;TurnCount&gt; = None;
let mut wins: Option&lt;Wins&gt; = None;
let mut base_equipment_level: Option&lt;BaseEquipmentLevel&gt; = None;
let mut difficulty: Option&lt;Difficulty&gt; = None;
let mut messages: Option&lt;Messages&gt; = None;
let mut player_alive: Option&lt;PlayerAlive&gt; = None;
let mut player_id: Option&lt;PlayerId&gt; = None;
let mut map: Option&lt;Map&gt; = None;
</code></pre>
<p>These are all temporary variables for unique data.
When the per-line loop reads in a unique, it fills one of these with a <code>Some</code> variant containing the loaded data for that unique.</p>
<p>The first conditional block of the per-line loop checks for an asterisk character and a whitespace.
If those characters are detected, the line is trimmed to the point after them and the loading process will attempt to interpret the line according to all of the unique types it knows of, one at a time.</p>
<p>Unique lines are loaded via the <code>deserialize_named_unique</code> function, which has a helper <code>deserialize_unique!</code> macro to reduce typing redundancy.
The <code>deserialize_named_unique</code> function accepts one of the temporary variables for holding unique data.
It does one of the following things, depending on the contents of the data line it sees:</p>
<ol>
<li>Returns <code>Ok(false)</code> if the unique type name doesn't match what was expected.</li>
<li>Returns <code>Ok(false)</code> if deserializing failed for whatever reason.</li>
<li>Returns <code>Err(LoadError::DuplicateUnique(...))</code> if the temporary variable was already filled in and the load would otherwise have succeeded.</li>
<li>Returns <code>Ok(true)</code> and fills in the temporary variable with the loaded data if none of the above occurred.</li>
</ol>
<p>In other words, a return value of <code>Ok(true)</code> means the unique data was successfully loaded, while <code>Ok(false)</code> indicates that other unique types should be attempted.</p>
<h4 id="loading-a-component-line"><a class="header" href="#loading-a-component-line">Loading a Component Line</a></h4>
<p>When components are loaded in, they need to be attached to newly-created entities.
These entities share the same world space as any entities that existed before the loading process started.
When entities are created during the loading process they're added to the <code>despawn_ids</code> vector passed into the <code>load_save_file</code> function.
As mentioned before, entities in this vector will eventually be despawned if they're still there when the <code>load_save_file</code> function is done.
Therefore, we can think of components loaded and attached to these entities as temporary storage.</p>
<p>With that in mind, we can now consider lines that should contain component data.
The loading process will try to interpret any line that doesn't start with an asterisk character as a component line instead.</p>
<p>The first part of a component line is the entity that the component should be attached to.
This entity ID is meaningful within the save data, but is meaningless in the current world.
To reconcile this, we need to map each distinct entity ID that we encounter while loading components to <em>fresh</em> entities that have their own new entity IDs.
Near the top of the <code>load_save_file</code> function is the data structure whose job is to manage exactly this:</p>
<pre><code class="language-rust ignore">let mut old_to_new_ids: HashMap&lt;EntityId, EntityId&gt; = HashMap::new();
</code></pre>
<p>The keys of this hash map are the entity IDs as listed in the save file, while the values are the entity IDs of the corresponding fresh new entities that represent them in their real, loaded form.
If the entity ID at the beginning of the component line exists, it is simply retrieved.
If it doesn't, it is created and added to this hash map.</p>
<p>Since we have the ID of the new entity, we can proceed to attempt to load components, trying one type at a time.
This is done with the <code>deserialize_named_component</code> function and the <code>deserialize_component!</code> helper macro that work much like how <code>deserialize_named_unique</code> and <code>deserialize_unique!</code> did for uniques.
In fact, the <code>deserialize_named_component</code> function works the same way as the <code>deserialize_named_unique</code> function, except that it attaches component data to a new temporary entity passed in by ID and emits <code>Err(LoadError::DuplicateComponent(...))</code> instead.</p>
<p>At this point, any line that cannot be read as data for a unique or for a component causes the <code>load_save_file</code> function to return <code>LoadError::UnrecoginzedLine</code> as an error.</p>
<h3 id="checking-uniques"><a class="header" href="#checking-uniques">Checking Uniques</a></h3>
<p>Once every line in the save file has been processed, we need to check that every unique is accounted for.
The code is short enough to show here in its entirety:</p>
<pre><code class="language-rust ignore">// Check that all uniques are present.
let game_seed = game_seed.ok_or(LoadError::MissingUnique(&quot;GameSeed&quot;))?;
let turn_count = turn_count.ok_or(LoadError::MissingUnique(&quot;TurnCount&quot;))?;
let wins = wins.ok_or(LoadError::MissingUnique(&quot;Wins&quot;))?;
let base_equipment_level =
    base_equipment_level.ok_or(LoadError::MissingUnique(&quot;BaseEquipmentLevel&quot;))?;
let mut difficulty = difficulty.ok_or(LoadError::MissingUnique(&quot;Difficulty&quot;))?;
let messages = messages.ok_or(LoadError::MissingUnique(&quot;Messages&quot;))?;
let player_alive = player_alive.ok_or(LoadError::MissingUnique(&quot;PlayerAlive&quot;))?;
let mut player_id = player_id.ok_or(LoadError::MissingUnique(&quot;PlayerId&quot;))?;
let mut map = map.ok_or(LoadError::MissingUnique(&quot;Map&quot;))?;
</code></pre>
<p>The above code checks that each unique type was loaded, and bails with an error if any of them are missing.
It also uses <em>shadowing</em> to redefine the temporary unique variables into non-<code>Option</code> form so they're easier to work with later in the loading code.</p>
<h3 id="fixing-entity-ids"><a class="header" href="#fixing-entity-ids">Fixing Entity IDs</a></h3>
<p>When component lines were being processed, new entities were being created according to the entity ID found at the beginning of those lines.
However, there are also entity IDs present in the data payloads at the end of unique and component lines as well that are loaded verbatim, which means they refer to the IDs at the beginning of lines.
We need to fix these IDs to point to the IDs of the entities created during the loading process by converting them according to the <code>old_to_new_ids</code> hash map that was built up earlier.</p>
<p>There are two uniques and two components that hold entity IDs and thus need fixing.
The unique types are <code>Difficulty</code> and <code>PlayerId</code>, while the component types are <code>Equipment</code> (weapon and armor) and <code>Inventory</code> (items).
The loading code takes care to only iterate over entities that were created during the loading process by filtering by the values of the <code>old_to_new_ids</code> hash map.</p>
<p>Converting old save IDs to new loaded entity IDs also doubles as an integrity check to ensure that each ID refers to an existing entity in the save file.
If any of the IDs to fix are absent from the <code>old_to_new_ids</code> hash map, a <code>LoadError::UnknownId</code> error is raised.</p>
<h3 id="placing-entities-on-the-map"><a class="header" href="#placing-entities-on-the-map">Placing Entities on The Map</a></h3>
<p>If you look at the serialized version of the map in a save file and compare it to the definition of the <code>Map</code> struct in the <code>src/map.rs</code> file, you'll notice that the <code>tile_entities</code> field isn't being serialized.
This is the spatial cache that's used to speed up access to entities according to their position in the map.
It doesn't need to be saved or loaded because the same information is stored in the <code>Coord</code> components of each entity.
However, this spatial cache still needs to be restored when loading a save file; this is done by simply iterating over all entities with a <code>Coord</code> component and using the <code>Map::place_entity</code> function to fill in the cache.</p>
<h3 id="committing-loaded-uniques-and-entities"><a class="header" href="#committing-loaded-uniques-and-entities">Committing Loaded Uniques and Entities</a></h3>
<p>So far all of our data has been loaded in a temporary form: uniques are loaded in local variables, while components are attached to temporary entities.
We want to <em>commit</em> our temporary data; that is, prepare it so it can be used by the rest of the game.</p>
<p>Committing temporary entities involves clearing out the <code>despawn_ids</code> vector that was passed in at the beginning.
Its contents are replaced with old entities that were around before loading that need to be despawned.
There are only two entities that fall under this description: the difficulty tracking entity and the player entity (plus any equipment and items they may have).
We know that we only have to handle these two entities because loading only happens at the title screen, so no other unassociated entities exist at that point in the game.</p>
<p>After committing temporary entities comes committing uniques, which is a simple matter of assigning over or replacing each unique type individually.
The API of Shipyard 0.4 has no way to replace or remove a unique once one has been added to a world, so this involves some clumsy <code>replace</code> function definitions for some unique types, but otherwise it works.</p>
<h3 id="after-loading"><a class="header" href="#after-loading">After Loading</a></h3>
<p>At this point all of the saved data has been loaded and prepared, so all that's left is to bounce the player right back into the gameplay.
The original invocation of the <code>load_game</code> function in the <code>TitleMode::update</code> function triggers a mode switch to <code>DungeonMode</code> which does pretty much that.</p>
<p>So like I said earlier: loading is a lot more complicated than saving.
Despite all of these checks and safe-guards, there's a lot of ways a save file can be loaded and accepted by the game, but still be broken.
For example:</p>
<ul>
<li>A map has a set width and height, but could be loaded with insufficient tiles.</li>
<li>Numbers that are typically positive could be negative.</li>
<li>What if entities are missing important components?</li>
<li>A lot of nonsense can happen if entity IDs are changed to refer to unintended entities.</li>
</ul>
<p>The loading logic of RuggRogue doesn't check for any of these; it's complex enough as-is and there's almost no limit to the number of things that could be wrong with the data that it loads.
Instead, it's mostly content to successfully load a save file that was produced by the saving logic.
If the save file is messed up, the impact on the game can vary from minor unintended behavior all the way to <em>panicking</em>, which is Rust's safe way of bailing out at the first sign of trouble it detects.</p>
<p>Opening and reading a save file is a good way of gaining insight as to what data exists at any given point in a game.
You can also have some fun by modifying a save file: try cranking up <code>Wins</code> to 300 and witness the flood of monsters and items, or add a zero or two to the player's maximum hit points.</p>
<h2 id="run-length-encoding"><a class="header" href="#run-length-encoding">Run-Length Encoding</a></h2>
<p>If you've been reading up to this point, you might have noticed that something is missing in this explanation: how is serialization and deserialization actually performed?
If each line of the save file ends with JSON-formatted data, how are data structures converted to and from JSON when saving and loading?</p>
<p>The reason that all of this has been glossed over is because RuggRogue outsources the task to two crates: <a href="https://crates.io/crates/serde">serde</a> and <a href="https://crates.io/crates/serde_json">serde_json</a>, that make it almost trivial.
RuggRogue first uses Serde to annotate any data structure that needs this treatment using the <em>derive macros</em> that provides, like so:</p>
<pre><code class="language-rust ignore">use serde::{Deserialize, Serialize};

#[derive(Deserialize, Serialize)]
pub struct GameSeed(u64);
</code></pre>
<p>In the above example, <code>GameSeed</code> is a simple tuple struct, but this annotation works for larger structs with fields and enums as well.
Every data structure that RuggRogue needs to save into the save file is annotated in this way.</p>
<p>Once annotated like this, these data structures can then be serialized into JSON format using serde_json, e.g.:</p>
<pre><code class="language-rust ignore">// NOTE: Not real saving code!

use serde_json::Serializer;

let mut writer = SomethingToWriteInto::new();
let game_seed = world.borrow::&lt;UniqueView&lt;GameSeed&gt;&gt;();
game_seed.serialize(&amp;mut Serializer::new(&amp;mut writer))?;
</code></pre>
<p>Deserialization from JSON is also handled by serde_json:</p>
<pre><code class="language-rust ignore">// NOTE: Not real loading code!

use serde_json::Deserializer;

let line = GetALineFromSomewhere::new();
let mut ds = Deserializer::from_str(line);
let mut game_seed = GameSeed::deserialize(&amp;mut ds)?;
world.borrow::&lt;UniqueViewMut&lt;GameSeed&gt;&gt;().0 = game_seed.0;
</code></pre>
<p>The above code samples aren't real code, but they're rough approximations of what happens inside the <code>serialize_named_unique</code>, <code>serialize_named_storage</code>, <code>deserialize_named_unique</code> and <code>deserialize_named_storage</code> functions.</p>
<p>For simple data, this is all that is needed for serialization and deserialization.
However, let's take a look at the definition of the <code>Map</code> struct in the <code>src/map.rs</code> file, paying attention to the annotations:</p>
<pre><code class="language-rust ignore">#[derive(Deserialize, Serialize)]
pub struct Map {
    pub depth: i32,
    pub width: i32,
    pub height: i32,
    #[serde(with = &quot;crate::saveload::run_length_encoded&quot;)]
    tiles: Vec&lt;Tile&gt;,
    pub rooms: Vec&lt;Rect&gt;,
    pub seen: BitGrid,

    // (x, y) -&gt; (blocking_entity_count, entities_here)
    #[serde(skip)]
    tile_entities: HashMap&lt;(i32, i32), (i32, Vec&lt;EntityId&gt;)&gt;,

    // zero-length non-zero-capacity vectors for reuse in tile_entities
    #[serde(skip)]
    empty_entity_vecs: Vec&lt;Vec&lt;EntityId&gt;&gt;,
}
</code></pre>
<p>Note the <code>&quot;crate::saveload::run_length_encoded&quot;</code> annotation on the <code>tiles</code> field.
This is how RuggRogue tells Serde that it wants to save the <code>tiles</code> field differently than how it normally would.
In this case, we know that there would be a lot of redundancy when saving the tile data of the map, so to cut it down we want to handle this field specially.</p>
<p>The way we want to cut down the size of the tile data that we save is by <a href="https://en.wikipedia.org/wiki/Run-length_encoding">run-length encoding</a> it.
Instead of writing each tile individually, we want to write the tile followed by the number of repetitions until a different tile appears.
This has a pretty dramatic impact on save file size: basic tests show that it reduces save file size by about two-thirds!</p>
<p>The <code>&quot;crate::saveload::run_length_encoded&quot;</code> bit refers to the <code>run_length_encoded</code> module near the bottom of the <code>src/saveload.rs</code> file.
The <code>serialize</code> function contained within just reads in tiles and tracks runs of repeated tiles into a temporary vector, and just serializes that vector.
Conversely, the <code>deserialize</code> function reads in the vector in that format and uses some Rust iterator functions to convert it back into a normal vector of tiles that the <code>Map</code> struct actually wants.</p>
<p>For the tiles of a map, that's all that we need to perform run-length encoding.
However, we also want to apply run-length encoding to things like our fields of view, specifically to the <code>bv</code> field of our homegrown <code>BitGrid</code> struct in the <code>src/bitgrid.rs</code> file:</p>
<pre><code class="language-rust ignore">/// A width-by-height-sized BitVec for convenient handling of a grid of boolean values.
#[derive(Deserialize, Serialize)]
pub struct BitGrid {
    width: i32,
    height: i32,
    #[serde(with = &quot;crate::saveload::bit_vec&quot;)]
    bv: BitVec,
}
</code></pre>
<p>We have a <code>BitVec</code> here which is notably not Rust's standard <code>Vec</code> type that the <code>run_length_encoded</code> module wants.
The <code>&quot;crate::saveload::bit_vec&quot;</code> bit refers to the <code>bit_vec</code> module at the very bottom of the <code>src/saveload.rs</code> file.
The only job of this module is to convert the <code>BitVec</code> to and from a standard Rust <code>Vec&lt;u8&gt;</code> of ones and zeroes and then hand it off to the <code>run_length_encoded</code> module to apply its run-length encoding.
The end result is run-length encoding for <code>BitVec</code> fields that decreases the amount of space needed to save them.</p>
<p>A final note: apparently the <code>BitVec</code> type can be processed by Serde with an internal representation that's even more compact than the roundabout run-length encoding that RuggRogue uses.
However, the documentation of that crate warns that its output isn't guaranteed to stay stable.
What's more, even trying to use it as-is resulted in serialized output that the deserializer would choke on.
In a sense, the run-length encoding that RuggRogue uses is actually a workaround for the <code>BitVec</code> type not serializing and deserializing correctly to begin with.</p>
<h2 id="save-support-for-the-web-build"><a class="header" href="#save-support-for-the-web-build">Save Support for the Web Build</a></h2>
<p>The native build of RuggRogue writes game data to the <code>savegame.txt</code> file in the same directory as the game itself, but what about the web build?
Obviously the web build can't just write files to the visitor's local filesystem directly.
The web version of RuggRogue is created using <a href="https://emscripten.org/">Emscripten</a>, which provides an in-memory file system by default called <a href="https://emscripten.org/docs/api_reference/Filesystem-API.html#filesystem-api-memfs"><code>MEMFS</code></a> that enables standard file operations to just work.
The downside of this default system is that anything saved to this file system is lost the moment the player closes the tab.</p>
<p>In order to allow the player to save the game and load it when visiting the game page at a later point in time, we need an Emscripten file system that will preserve the save file written into it.
RuggRogue uses <a href="https://emscripten.org/docs/api_reference/Filesystem-API.html#filesystem-api-idbfs"><code>IDBFS</code></a> to accomplish this, which provides a file system backed by an <code>IndexedDB</code> instance provided by the web browser.</p>
<p>The first step to using <code>IDBFS</code> is to link it in so it can be used at all.
RuggRogue does this by passing <code>-lidbfs.js</code> as a linker option to the Emscripten toolchain in the <code>.cargo/config.toml</code> file.</p>
<p>If you take a look near the top of the <code>src/saveload.rs</code> file, you may have noticed this bit regarding the location of the save file:</p>
<pre><code class="language-rust ignore">#[cfg(target_os = &quot;emscripten&quot;)]
const SAVE_FILENAME: &amp;str = &quot;/ruggrogue/savegame.txt&quot;;

#[cfg(not(target_os = &quot;emscripten&quot;))]
const SAVE_FILENAME: &amp;str = &quot;savegame.txt&quot;;
</code></pre>
<p>This sets the save file location to <code>savegame.txt</code> when building the native version of the game, while putting the save in the fixed <code>/ruggrogue/savegame.txt</code> location in the web version instead.
The <code>/ruggrogue</code> directory is a location that we want to create in Emscripten's virtual file system, which will be mounted as an <code>IDBFS</code>.
This is done with some JavaScript inside the <code>index.html</code> file:</p>
<pre><code class="language-javascript">var Module = {
    // ...
    'preRun': [function () {
        FS.mkdir(&quot;/ruggrogue&quot;);
        FS.mount(IDBFS, {}, &quot;/ruggrogue&quot;);
        FS.syncfs(true, function (err) {});
    }],
};
</code></pre>
<p>The above snippet creates <code>/ruggrogue</code> as a mount point in Emscripten's virtual file system, mounts an <code>IDBFS</code> instance there, and loads in any data saved in the web browser's IndexedDB into it.
In theory, that's all that's needed to get saving and loading to work in the web version of RuggRogue.</p>
<p>Unfortunately, this process is imperfect.
The final <code>FS.syncfs</code> call above is asynchronous, and the callback provided is supposed to be called when it's done, but I couldn't work out how to make Emscripten wait for it to be called before jumping into the title screen of the game.
If you take a peek at the menu logic in the <code>src/modes/title.rs</code> file, you can see that RuggRogue works around this by always including the &quot;Load Game&quot; option in the web build.</p>
<p>The other caveat of this IndexedDB approach is that persistent IndexedDB instances aren't available in private browsing tabs.
In that case, the game will silently fall back to the in-memory file system, so save files will be forgotten when the game page is closed.</p>
<p>To be honest, I don't know if doing all of this the way I'm supposed to.
Emscripten has a decent amount of reference documentation, but it's very thin on guidance, so a lot of what I did above was cobbled together from bits and pieces of the docs I could find.
There feels like there should be a better and more reliable way to do what I've done here, but I haven't found one, so I just had to make do with what I could find.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="field-of-view"><a class="header" href="#field-of-view">Field of View</a></h1>
<p>When you start a new game in RuggRogue, one of the first things you'll notice is that the player can only see their immediate surroundings.
As you move around the dungeon, you'll also find that the player's sight is additionally limited from seeing through walls.
In other words, the player's vision is confined to their <em>field of view</em>: the set of tiles that are visible from the player's position in a straight line.
Limiting vision to a field of view is one of the staples of the roguelike genre, and RuggRogue is no exception.</p>
<p>Despite its single topic focus, this chapter is going to cover a lot of ground.
The first thing this chapter will cover is how fields of view are used in RuggRogue.
Next comes the general approach to calculating fields of view and the design considerations that come with it, followed by a high-level description of the algorithm used to calculate fields of view.
The rest of the chapter will then describe the various parts of the RuggRogue source code that implement this algorithm.</p>
<h2 id="how-fields-of-view-are-used"><a class="header" href="#how-fields-of-view-are-used">How Fields of View are used</a></h2>
<p>Before diving into how fields of view are calculated, it's worth considering how they're used to begin with.
The most obvious purpose of field of view calculation is to define and limit how much of the map the player can see at any given time, in order to generate a sense of mystery and danger in exploring unknown territory.
However, it's also used for a number of other purposes.</p>
<p>Monsters in the dungeon are subject to the same vision rules as the player and thus also have a field of view calculated for them.
Monsters and the player both possess a <code>FieldOfView</code> component that tells the game to calculate the field of view when needed for the corresponding entity.
The <code>FieldOfView</code> component itself, defined in the <code>src/components.rs</code> file, consists of the position and range of the field of view, a bit grid with a bit set for each visible tile and a dirty flag to prevent unnecessary recalculations.
All of this calculation is regulated by the <code>recalculate_fields_of_view</code> function defined in the <code>src/vision.rs</code> file; it's here that we get our first glimpse of the use of the <code>ruggrogue::field_of_view</code> function that calculates the field of view itself.
Fields of view belonging to the player will update the memory of previously-seen map tiles stored in the <code>seen</code> bit grid field of the <code>Map</code> struct defined in the <code>src/map.rs</code> file.</p>
<p>The field of view of the player is used to limit which tiles can be targeted when using an item at range to stop them from using items directly through walls.
The tiles of the player's field of view are used as the basis for valid target tiles considered by the <code>TargetMode</code> struct in the <code>src/modes/target.rs</code> file.
This is done by filling in the <code>valid</code> field of the <code>TargetMode</code> struct in the <code>TargetMode::new</code> function.</p>
<p>The final use of field of view calculation is to shape the area of effect of items according to the target epicenter of their blast.
The <code>use_item</code> function in the <code>src/item.rs</code> file fills in a <code>targets</code> variable with entity IDs according to their positions within the field of view of the target epicenter; note the use of the <code>ruggrogue::field_of_view</code> function here to achieve this.</p>
<h2 id="calculating-field-of-view"><a class="header" href="#calculating-field-of-view">Calculating Field of View</a></h2>
<p>There are many ways that roguelikes choose to define their fields of view.
RuggRogue defines its field of view as all tiles that are visible from a starting tile in a straight line within some maximum range.
Roguelikes that use this definition generally approach field of view calculations in one of three ways:</p>
<ol>
<li><em>Ray casting</em>: Cast a straight line ray between the starting tile and every other tile; a tile is visible if the ray is not blocked.</li>
<li><em>Shadow casting</em>: Trace visible tiles outwards from the starting tile, skipping shadows cast by blocking tiles described by slopes relative to the center of the starting tile.</li>
<li><em>Permissive field of view</em>: A group of approaches that try to calculate visible tiles by detecting if a straight line can be drawn between any point in the starting tile and any point in each checked tile.</li>
</ol>
<p>RuggRogue takes the <strong>shadow casting</strong> approach.
The <a href="http://roguebasin.com/index.php/Field_of_Vision">&quot;Field of Vision&quot; page on RogueBasin</a> is a good starting point for finding out more about these approaches.
Ray casting runs pretty slowly, especially as fields of view grow larger, and performance matters somewhat considering RuggRogue calculates fields of view for monsters as well as the player.
On the other hand, there's not much written about permissive field of view calculation, and the different approaches tend to involve corner-case handling of common input scenarios, leading to messy algorithms.
Shadow casting is fast, precise and robust when it's implemented correctly.</p>
<p>There are two major design considerations when using shadow casting to calculate fields of view: <strong>wall shape</strong> and <strong>determining visibility</strong>.</p>
<p>The wall shape chosen by an implementation of the shadow casting algorithm determines the shape of the shadows that are cast by walls when they block vision.
The most obvious wall shape choice is square walls, where the wall is considered to completely fill its occupying tile.
This is a very common implementation choice, but surprisingly it leads to larger shadows and smaller, more claustrophobic fields of view compared to the results of other algorithms.
RuggRogue instead opts for <em>diamond-shaped walls</em>, in which a wall consists of a diamond drawn between the mid-points of its four sides.
This grants better visibility around corners and creates more natural-looking shadows behind occlusions.</p>
<p><img src="img/fov-square-vs-diamond-walls.png" alt="Square wall shadow versus diamond wall shadow." /></p>
<p>Visibility determination is about exactly how a shadow casting implementation decides whether or not a tile is visible from the starting tile.
The obvious approach here is center-to-any visibility, i.e. a tile is visible if there is a straight line between the center of the starting tile to any point in the target tile.
Unfortunately, this leads to <em>asymmetry</em>: target tiles are visible from the starting tile, but not necessarily vice versa.
To preserve symmetry, we could instead opt for center-to-center visibility, i.e. a tile is visible if there is a straight line between its center and the center of the starting tile.
This also has a problem when applied naively: walls become <em>non-expansive</em>, i.e. standing next to a long straight wall renders faraway wall tiles as not visible, even while non-wall tiles next to them are visible.
RuggRogue adopts a hybrid strategy for visibility determination made up of two core rules:</p>
<ol>
<li>Symmetric <em>center-to-center</em> visibility for non-wall tiles.</li>
<li>Asymmetric <em>center-to-mid-line</em> visibility for wall tiles.</li>
</ol>
<p>We want to use &quot;center-to-mid-line&quot; visibility instead of &quot;center-to-any&quot; to make visibility determination match our diamond-shaped walls.
Center-to-mid-line visibility exploits the fact that diamond-shaped walls can also be considered as <em>plus-shaped</em> walls; it doesn't matter how the mid-points of each side of the tile are connected for the purposes of shadow casting.
We can therefore check if a wall is visible by seeing if any stem of the plus shape is visible from the central point of the starting tile.
In the following diagram, the far wall is asymmetrically visible due to one of its mid-lines, while every other tile is symmetrically visible, including the close wall:</p>
<p><img src="img/fov-symmetric-visibility.png" alt="Example diagram demonstrating the difference betweeen symmetric and asymmetric visibility." /></p>
<p>It's important to remember that wall shape and visibility determination are implementation details and not core properties of the shadow casting algorithm itself.
The two are often confused in other literature when listing downsides to using shadow casting, or when comparing the results of shadow casting to that of other field of view algorithms.</p>
<h2 id="the-shadow-casting-algorithm"><a class="header" href="#the-shadow-casting-algorithm">The Shadow Casting Algorithm</a></h2>
<p>In order to make sense of the code in RuggRogue that calculates fields of view, we'll first need to understand how shadow casting works on an algorithmic level.
There are two broad approaches to implementing shadow casting: recursive and iterative.
The recursive approach solves the shadow casting problem by repeatedly breaking it down into smaller sub-problems, tracking visible areas as arguments fed into successive function calls.
The iterative approach loops over tiles while tracking visible areas explicitly in data structures.
RuggRogue implements iterative shadow casting since iterative algorithms tend to perform better than recursive ones in real-world cases, so that's what will be covered here.</p>
<p>Before getting into all of this, a couple of definitions are in order.
First, we'll use the word &quot;wall&quot; for tiles that block vision and &quot;floor&quot; for tiles that don't, just for convenience.
Second, we'll define y as increasing <em>upwards</em> like in most mathematics and geometry literature, so words like &quot;higher&quot; and &quot;lower&quot; make more sense.
In reality, grids and coordinates in RuggRogue treat y as increasing downwards, but shadow casting still works even when things are vertically flipped, so we can get away with it.</p>
<h3 id="dividing-space-to-make-shadow-casting-easier"><a class="header" href="#dividing-space-to-make-shadow-casting-easier">Dividing Space to Make Shadow Casting Easier</a></h3>
<p>The first step of shadow casting is to visit the <em>starting tile</em>, marked with an at-sign (&quot;@&quot;) in all of these diagrams.
This seems obvious, but we won't be revisiting it at any other point in our algorithm, so it needs to be accounted for before anything else.</p>
<p>Beyond the starting tile, how are we going to handle all of the other tiles?
With shadow casting, we'll need to work with <em>slopes</em> going from the center of the starting tile to the corners of our diamond-shaped walls, but if we dive straight in with this information you'll run into a problem straight away.
Depending on whether our slopes are mostly horizontal or vertical, different wall corners are going to matter: mostly-horizontal slopes care about vertical wall corners, while mostly-vertical slopes care about horizontal wall corners.
Another problem is that slopes will occasionally straddle two tiles exactly, so we'll have to perform rounding to break ties, but if this rounding is applied uniformly we'll end up biasing vision in certain directions.
It seems like we'll need a lot of ugly special cases to avoid ugly and incorrect results... or will we?</p>
<p>Instead of working with the entire area all at once, we can divide the space around the starting tiles into eight slices or <em>octants</em>:</p>
<p><img src="img/fov-octants.png" alt="Octants numbered 0 through 7 dividing space surrounding the starting tile." /></p>
<p>As it turns out, wall handling and rounding is handled the same way for all tiles in any single octant.
In octants where our slopes are mostly horizontal (octants 0, 3, 4 and 7 above) we only care about the vertical corners of our diamond-shaped walls; conversely, we only consider the horizontal corners in the other mostly-vertical octants (1, 2, 5 and 6 above).
When slopes straddle tiles, we want to round towards the nearest cardinal axis to avoid odd-looking bias, and this rounding is performed in the same direction for all tiles in an octant.
Dividing our processing into octants will make our logic a lot cleaner.</p>
<p>However, the best part about all of this is that we can now perform shadow casting in just one octant and use some clever mathematics to reuse our work in all of the other octants!
When we work in a single octant, we'll treat the starting tile as being at (0,0) coordinates and identify other tiles as offset from the starting tile by x and y values.
When we need real map coordinates instead, such as when checking if a tile is a wall or floor on the map, we can convert them using the following formulas:</p>
<pre><code class="language-plaintext">real_x = x * real_x_from_x + y * real_x_from_y + start_x
real_y = x * real_y_from_x + y * real_y_from_y + start_y
</code></pre>
<p>In the above formulas, <code>real_x</code> and <code>real_y</code> are real map coordinates, <code>x</code> and <code>y</code> are tile coordinates in the octant relative to the starting tile, and <code>start_x</code> and <code>start_y</code> are the real map coordinates of the starting tile.
The other four coefficients are different for every octant, and have the following values:</p>
<table><thead><tr><th>Octant</th><th><code>real_x_from_x</code></th><th><code>real_x_from_y</code></th><th><code>real_y_from_x</code></th><th><code>real_y_from_y</code></th></tr></thead><tbody>
<tr><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td></tr>
<tr><td>2</td><td>0</td><td>-1</td><td>1</td><td>0</td></tr>
<tr><td>3</td><td>-1</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>4</td><td>-1</td><td>0</td><td>0</td><td>-1</td></tr>
<tr><td>5</td><td>0</td><td>-1</td><td>-1</td><td>0</td></tr>
<tr><td>6</td><td>0</td><td>1</td><td>-1</td><td>0</td></tr>
<tr><td>7</td><td>1</td><td>0</td><td>0</td><td>-1</td></tr>
</tbody></table>
<p>With these formulas and values we can write code to perform shadow casting in one octant, then run it with different sets of values from the above table to cover the other octants.</p>
<p>There's one final thing to note in the diagram from earlier.
Look at the highlighted tiles on the edges of the octants.
These tiles are shared by two octants, and we'll need to consider them in both octants in case they contain walls, but we also want to avoid visiting them twice.
It's easy enough to make this happen by only visiting these tiles in even-numbered octants, i.e. octants 0, 2, 4 and 6 above.</p>
<h3 id="processing-a-single-octant"><a class="header" href="#processing-a-single-octant">Processing a Single Octant</a></h3>
<p>To ensure that walls closer to the starting tile block vision, we'll need to process tiles near the starting tile and work our way outwards.
This means that our work will be broken down into columns, like so:</p>
<p><img src="img/fov-octant-columns.png" alt="Columns in an octant, numbered 1 through 7." /></p>
<p>Whatever we do, we'll need to finish all of our work in one column before moving onto the next.
In the image above, we start with column 1 and process it completely, then column 2, then column 3 and so on.</p>
<h3 id="determining-visible-tiles-in-a-column"><a class="header" href="#determining-visible-tiles-in-a-column">Determining Visible Tiles in a Column</a></h3>
<p>Once we're down to the level of a single column, we need some way to describe the areas that are visible from the starting tile.
To understand the type of data that we need, we'll first need to understand two concepts: <em>slopes</em> and <em>sights</em>.</p>
<p>A <strong>slope</strong> describes the angle between the center of the starting tile and some other point, like the corner of a wall.
Here is an example of a slope of the top corner of a nearby wall:</p>
<p><img src="img/fov-slope.png" alt="An example of a slope created by a nearby wall." /></p>
<p>The first thing to note about the slope above, and indeed all slopes, is that they are <em>always measured from the center of the starting tile</em>.
The center is the only point in the starting tile that stays in the same place regardless of flipping and transposing, which is what will happen when taking our work into other octants.</p>
<p>The next thing to note is that we're representing slopes as pairs of integers and measuring them out in <em>half-tile units</em>.
Slopes are fractional values and could be represented as floating point values instead, as some other shadow casting implementations will choose.
By measuring in half-tiles, RuggRogue avoids the performance overhead of converting between integers and floating point values.</p>
<p>Finally, even though a slope is created between two points, its influence extends beyond them.
This is what allows our field of view to properly expand outwards from the starting tile.</p>
<p>An important property of slopes is that they can be <em>compared</em>; slope comparison will be used later on to do things like test if a tile is symmetrically visible, for example.
Low slopes are considered to be of a value less than higher slopes.
One way to compare two slopes, <code>a</code> and <code>b</code>, is to define a less-than-or-equal-to inequality, like so:</p>
<pre><code class="language-plaintext">a_rise / a_run &lt;= b_rise / b_run
</code></pre>
<p>To avoid the need to divide and fall back on floating point values, we can multiply both sides of this inequality by the products of the runs:</p>
<pre><code class="language-plaintext">a_rise / a_run * a_run * b_run &lt;= b_rise / b_run * a_run * b_run
</code></pre>
<p>This simplifies to:</p>
<pre><code class="language-plaintext">a_rise * b_run &lt;= b_rise * a_run
</code></pre>
<p>If this inequality is true, then slope <code>a</code> is less than or equal to slope <code>b</code>.</p>
<p>We can use a pair of slopes as a way to represent a visible area; we'll call this a <strong>sight</strong>.
Here's an example of three sights in practice:</p>
<p><img src="img/fov-sights.png" alt="Three sights projected over an octant." /></p>
<p>In the example above, the visible area in columns 1 through 5 can all be described by a single sight whose low slope is 0/1 and high slope is 1/1.
The wall tile in column 5 creates two sights: 0/1 to 3/10 and 5/10 to 1/1.
These two sights describe the visible area for columns 6 and 7.</p>
<p>Now that we know about sights and slopes, we can now define the (potentially) visible tiles in a column as the tiles inside the list of sights for that column.
We consider a tile as 'inside' a sight if any part of its mid-line is inside the sight.
Fortunately, we don't have to calculate any line intersections to determine this.
If we consider the starting tile as (0, 0) and our column numbers as x values, we just need to figure out the range of y values for a sight in that column.
Here's the basic line equation:</p>
<pre><code class="language-plaintext">y = a * x + c
</code></pre>
<p><code>y</code> is the value that we want, <code>x</code> is the column number, <code>a</code> is our slope and <code>c</code> is the constant offset.
Our <code>c</code> is zero since all of our slopes start at the center of the starting tile, while the <code>a</code> value is just <code>rise / run</code>, so our equation becomes this:</p>
<pre><code class="language-plaintext">y = x * rise / run
</code></pre>
<p>There's a problem if we use this equation as-is: we're off by half a tile, since we defined our (0, 0) point as the <em>center</em> of the starting tile, not its bottom-left corner.
To correct for this, we'll need to add half a tile:</p>
<pre><code class="language-plaintext">y = x * rise / run + 0.5
</code></pre>
<p>We can avoid resorting to floating point values by multiplying by two, adding one and exploiting the fact that integer division rounds down to achieve the same thing with only integer arithmetic:</p>
<pre><code class="language-plaintext">y = (2 * x * rise / run + 1) / 2
</code></pre>
<p>If we plug in the values for the low and high slopes of a sight we'll get the exact y values of the tiles whose mid-lines lie inside that sight.
Here's an example of this formula in action:</p>
<p><img src="img/fov-sight-y-values.png" alt="y values of a (1/4)-(3/4) sight projected onto column 5." /></p>
<p>In this diagram, we have a single sight with a low slope of 1/4 and high slope of 3/4, and we want to know which y values this sight covers in column 5.
If we apply the formula to the low slope, we get a low y of 1; doing to the same with the high slope gets us a high y of 4.
Therefore, the potentially visible tiles of this (1/4)-(3/4) sight in column 5 lie between y = 1 and y = 4 inclusive, highlighted above.</p>
<p>This is an example of a single sight projected onto a column, but if there are multiple active sights in a column we need to repeat this process for all of those sights in order to get all of the potentially visible tiles of that column.</p>
<h3 id="processing-visible-tiles-in-a-column"><a class="header" href="#processing-visible-tiles-in-a-column">Processing Visible Tiles in a Column</a></h3>
<p>So far, a column takes a list of sights as input that we'll call the <em>current sight list</em>.
For each sight in the current sight list, we can calculate the low and high y values of the potentially visible tiles of that sight in the column.
As we step through each potentially visible tile of a sight, we have two jobs:</p>
<ol>
<li>Build up a <em>next sight list</em> based on the walls and floors detected in the current column.</li>
<li>Visit each tile to mark it as visible.</li>
</ol>
<p>The word &quot;visit&quot; here differs between shadow casting implementations; some hard-code the marking of a visibility map here, others provide a callback to permit a caller to decide what to do.
RuggRogue's shadow casting implementation is built as an iterator, so it just returns the real map coordinates to whatever code is driving the iterator.
This is all that's needed for wall tiles, which are asymetrically center-to-mid-line visible.
All other tiles are only <em>symetrically</em> center-to-center visible, so we need to test if the tile is symmetrically visible and return it as a flag alongside the tile coordinates.
We can do this by testing if the slope of the tile's center point lies inside the low and high slopes of the current sight:</p>
<pre><code class="language-plaintext">low_slope &lt;= tile_center_slope &lt;= high_slope
</code></pre>
<p>If this condition is true, the tile is symmetrically visible from the starting tile and should be marked visible.</p>
<p>Reading from the current sight list while building up a next sight list means we need <em>two</em> sight lists at any given time when working with a column.
The start of the shadow casting logic creates these lists and hands them to the octants.
Each octant initializes the lists: an empty <em>even list</em> and an <em>odd list</em> with a single sight covering the whole octant, i.e. a low slope of 0/1 and a high slope of 1/1.
Each odd column treats the odd list as its current sight list, then clears and starts pushing to the even list as the next sight list; even columns swap the roles of the even and odd lists.
This list-flipping strategy allows us to avoid the need to allocate extra lists during all of this.</p>
<p>To build up the next sight list, we'll need to scan for consecutive runs of floor tiles.
We need to step through each potentially visible tile in the sight while keeping track of a <em>working slope</em>.
The working slope is set to <code>None</code> to begin with or when stepping through a run of walls, and is set to <code>Some(slope)</code> when stepping through a run of floors, where <code>slope</code> is the slope where the current run of floors began.
Whenever the working slope changes from <code>Some(...)</code> to <code>None</code> we push a new sight onto the next sight list.</p>
<p>When we put all of this together, the logic for a single column looks something like this:</p>
<ol>
<li>Pick current and next sight lists out of the even and odd lists based on whether this column is even- or odd-numbered.</li>
<li>Clear the next sight list.</li>
<li>For each sight in the current sight list:
<ol>
<li>Calculate the low and high y values of potentially visible tiles to iterate over.</li>
<li>Initialize <code>working_slope</code> to <code>None</code>.</li>
<li>For each potentially visible tile in the sight:
<ol>
<li>Calculate <code>low_mid_slope</code>: the slope of the center of the bottom edge of the tile.</li>
<li>If the tile is a wall and <code>working_slope</code> is <code>Some(...)</code>:
<ol>
<li>Push a new sight onto the next sight list:
<ol>
<li>Set the low slope of the sight to <code>working_slope</code>.</li>
<li>Set the high slope of the sight to <code>low_mid_slope</code>.</li>
</ol>
</li>
<li>Set <code>working_slope</code> to <code>None</code>.</li>
</ol>
</li>
<li>If the tile is a floor and <code>working_slope</code> is <code>None</code>:
<ol>
<li>Set <code>working_slope</code> to the <em>higher</em> of <code>low_mid_slope</code> and the low slope of the current sight.</li>
</ol>
</li>
<li>Visit the tile by returning its real map coordinates and test its center for symmetric visibility.</li>
</ol>
</li>
<li>If <code>working_slope</code> is <code>Some(...)</code> after all of the tiles, push a final sight onto the next sight list:
<ol>
<li>Set the low slope of the sight to <code>working_slope</code>.</li>
<li>Set the high slope of the sight to the high slope of the current sight.</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>This looks like a lot to take in, but really all it's doing is looking for runs of consecutive floor tiles and adding them as sights to the next sight list when they end, while visiting potentially visible tiles.
If you do this for all of the columns in an octant, then repeat it for all eight octants, you'll have the full shadow casting algorithm!</p>
<h3 id="algorithm-wrap-up"><a class="header" href="#algorithm-wrap-up">Algorithm Wrap-Up</a></h3>
<p>If you poke around online, you'll find that there are many different ways to implement shadow casting.
The algorithm described here has a number of nice properties:</p>
<ul>
<li>It uses iteration instead of recursion for performance.</li>
<li>It avoids the use of floating point values for performance.</li>
<li>It performs no allocations except for the two sight lists, again for performance.</li>
<li>It is precise: slopes are exact and nothing is approximated.</li>
<li>It combines asymmetric vision for nice-looking walls with symmetric vision for other tiles for fair gameplay.</li>
<li>It uses diamond-shaped walls for better visibility around corners.</li>
</ul>
<h2 id="implementing-shadow-casting-in-ruggrogue"><a class="header" href="#implementing-shadow-casting-in-ruggrogue">Implementing Shadow Casting in RuggRogue</a></h2>
<p>Armed with an understanding of the shadow casting algorithm that RuggRogue uses to calculate fields of view, we can finally start looking at the code itself.</p>
<h3 id="initializing-and-using-the-iterator"><a class="header" href="#initializing-and-using-the-iterator">Initializing and Using the Iterator</a></h3>
<p>The most important part of the field of view story starts in the <code>recalculate_fields_of_view</code> function in the <code>src/vision.rs</code> file, and the most important part of that is reproduced below:</p>
<pre><code class="language-rust ignore">// Update field of view.
for (x, y, symmetric) in
    ruggrogue::field_of_view(&amp;*map, coord.0.into(), fov.range, FovShape::CirclePlus)
{
    if symmetric || matches!(map.get_tile(x, y), &amp;Tile::Wall) {
        fov.set((x, y), true);
    }
}
</code></pre>
<p>The <code>ruggrogue::field_of_view</code> function returns the iterator that implements shadow casting.
That iterator is initialized with the map and center starting tile, but you'll also notice the &quot;range&quot; and &quot;shape&quot; being given as well.
Vision is calculated up to a maximum range given in tiles.
The &quot;shape&quot; of a field of view determines how that range is treated: <code>FovShape::CirclePlus</code> effectively asks for a circle with a radius of that range plus half a tile.
Adding half a tile prevents single tiles poking out on the four cardinal directions that would occur with an exact radius circle of vision.</p>
<p>The iterator returns the map coordinates of visible tiles, along with a symmetric flag if the tile is considered symmetrically visible, i.e. its center point is visible to the center of the starting tile.
The body of the loop then makes the final decision about whether that tile is visible: a symmetrically visible tile is always visible, and walls are visible regardless of symmetry.</p>
<p>The <code>ruggrogue::field_of_view</code> function itself lives at the bottom of the <code>src/lib/field_of_view.rs</code> file.
It does nothing more than initialize an instance of the <code>FovIter</code> struct whose definition can be found near the top of the file.</p>
<p>The first interesting thing about the <code>FovIter</code> struct is the map that it takes.
The map it wants needs to adhere to two traits: the <code>BoundedMap</code> trait (defined in <code>src/lib/lib.rs</code>) that allows the upcoming logic to query the bounds of the map to avoid out-of-bounds access, and the <code>ViewableField</code> trait to check if a given coordinate blocks vision.</p>
<p>The other thing to note about the <code>FovIter</code> struct is that it holds a lot of book-keeping data aside from its initial parameters.
We can break down the fields into three groups:</p>
<ol>
<li>Initial data
<ul>
<li><code>map</code>: The map to calculate the field of view over.</li>
<li><code>start_pos</code>: The map coordinates of the center starting tile to calculate the field of view from.</li>
<li><code>range</code>: The maximum range of the field of view, in tiles.</li>
<li><code>fov_shape</code>: The shape that the field of view should take: the game only uses <code>FovShape::CirclePlus</code> as described earlier.</li>
</ul>
</li>
<li>Temporary data
<ul>
<li><code>bounds</code>: Cached map bounds describing the inclusive range of valid coordinates of the map.</li>
<li><code>max_dist2</code>: Maximum distance squared, derived from <code>range</code> and used as part of distance checking in order to shape the field of view.</li>
<li><code>sights_even</code> and <code>sights_odd</code>: Even and odd sight lists described in the shadow casting algorithm section earlier.</li>
<li><code>low_y</code> and <code>high_y</code>: Range of y values for the current sight being processed.</li>
<li><code>low_sight_angle</code>: The working slope that holds the slope of the first floor tile as described in the shadow casting algorithm section earlier.</li>
</ul>
</li>
<li>Iteration progress
<ul>
<li><code>octant</code>: The current octant being processed; <code>None</code> means we're just getting started, while <code>Some(8)</code> means that the iterator is finished.</li>
<li><code>x</code>: The column being processed within an octant: <code>None</code> means the octant was just entered.</li>
<li><code>s</code>: The index into the current sight list within the column.</li>
<li><code>y</code>: The y value of the tile being processed within the sight, ranging from <code>low_y</code> to <code>high_y</code> inclusive.</li>
</ul>
</li>
</ol>
<p>To fully appreciate why all of this data needs to be tracked in the <code>FovIter</code> struct and not, say, in variables in a function with nested loops, we need to dive into what happens after initialization.</p>
<h3 id="driving-the-iterator"><a class="header" href="#driving-the-iterator">Driving the Iterator</a></h3>
<p>Iterators are fundamentally inert: they'll never do any work or produce any values until something else drives them.
The driving of the <code>FovIter</code> iterator is done by the <code>for</code> loop that was shown earlier.
This repeatedly calls the <code>Iterator::next</code> function defined just above the code for the <code>ruggrogue::field_of_view</code> function.
You'll quickly notice that this function does very little on its own.
It exists only to call the <code>FovIter::advance</code> function defined above it repeatedly until it gets a valid <code>Some(...)</code> value or <code>self.octant</code> reaches 8, meaning that the iterator is finished.
This is due to the fact that the <code>FovIter::advance</code> function occasionally needs to perform logic without producing a valid tile output, so it needs to be called until it produces one.</p>
<h3 id="advancing-through-the-shadow-casting-algorithm"><a class="header" href="#advancing-through-the-shadow-casting-algorithm">Advancing through the Shadow Casting Algorithm</a></h3>
<p>The entire shadow casting algorithm implementation used by RuggRogue is housed in the <code>FovIter::advance</code> function that makes up the largest part of the <code>src/lib/field_of_view.rs</code> file.
There's a lot going in here, but if you've read through the shadow casting algorithm section earlier in the chapter you'll be equipped to understand it.</p>
<p>By far the most unusual thing about this function is that despite the multiple octants, columns, sights and tiles that need to be handled, there is not a single loop in the whole function.
This comes back to the fact that this is all one big iterator: it gets called once, does some work and produces an output, gets called again and does some more work.
This is why the <code>FovIter</code> struct housed so much temporary and iteration progress data: to remember where to pick up from after returning a single tile's worth of data.</p>
<p>The <code>FovIter::advance</code> function begins by declaring and initializing two variables: <code>out_pos</code> and <code>out_symmetric</code>, for the tile position and symmetry test to output respectively.
Setting these variables signals that the function should return their values after this iteration.
Leaving them be instead causes nothing to be returned, in turn causing the function to be called again immediately if the iteration hasn't finished yet.</p>
<p>The very first call to <code>FovIter::advance</code> sets the <code>octant</code> field to <code>Some(value)</code> where the value is the octant index of -1 to visit the starting tile, 0 through 7 for each of the octants, or 8 when shadow casting is complete.
The first level of <code>if</code> branches performs the logic for each of these cases.</p>
<p>Visiting the starting tile when <code>octant</code> is -1 provides the simplest example of how <code>FovIter</code> produces output while setting up for its next iteration.
Setting <code>out_pos</code> and <code>out_symmetric</code> causes these values to be returned by that iteration, while setting <code>octant</code> to <code>Some(octant + 1)</code> sets up the next iteration to resume processing in the very first octant.</p>
<p>When processing an octant the very first step is to prepare the even and odd lists.
This case is detected when the <code>x</code> (column) field is set to <code>None</code>: the odd list is cleared and set to a single sight covering the whole octant, i.e. low slope of 0/1 and high slope of 1/1.
The <code>x</code> field is then set to <code>Some(1)</code> where 1 is the index of the first column in the octant, which prevents this logic from running again until we need it.</p>
<p>The logic for processing a single column is gated with a check on <code>if x &lt;= self.range</code>.
One of the first things done in this branch is this:</p>
<pre><code class="language-rust ignore">// Flip between using even and odd sights for current and next.
let (current, next) = if x % 2 == 0 {
    (&amp;mut self.sights_even, &amp;mut self.sights_odd)
} else {
    (&amp;mut self.sights_odd, &amp;mut self.sights_even)
};
</code></pre>
<p>If <code>x</code> is even, the current sight list is set to <code>sights_odd</code> and the role of the next sight list is given to <code>sights_even</code>; the lists are swapped when <code>x</code> is odd.</p>
<p>This gets us to the point where we need to loop over sights in the current sight list.
The index into this sight list is the <code>s</code> field which was previously initialized to <code>None</code>.
If <code>s</code> is <code>None</code> at this point we need to prepare the next sight list to be filled in by clearing it and setting <code>s</code> to <code>Some(0)</code> where 0 is represents the first entry in the current sight list.</p>
<p>If <code>s</code> is a valid index into the current sight list (i.e. <code>s &lt; current.len()</code>), then we need to process the sight.
This starts by checking if <code>y</code> is <code>None</code>: in that case the <code>low_y</code> and <code>high_y</code> for the sight need to be calculated, <code>low_sight_angle</code> (i.e. the working slope) needs to be initialized to <code>None</code> and <code>y</code> needs to be be initialized to <code>Some(low_y)</code> to kick off iteration of potentially visible tiles in the sight.</p>
<p>There's a quick range and shape test to see if the tile being tested lies within the desired range; assuming it does, there's a bunch of things that need to be set up to deal with individual tiles:</p>
<ul>
<li><code>real_x</code> and <code>real_y</code> are calculated with the help of the octant coefficients, depending on which octant is being processed.</li>
<li><code>low_mid_angle</code> is assembled, representing the slope of the mid-point of the bottom edge of the tile.</li>
<li>An <code>in_bounds</code> callback is defined to avoid indexing coordinates outside of the map bounds.</li>
<li>An <code>angle_lt_or_eq</code> callback is defined to compare slopes.</li>
</ul>
<p>The next conditional block that checks <code>self.map.is_opaque(...)</code> is responsible for detecting runs of floor tiles and adding them as sights to the next sight list when those runs end.
If the tile is a wall and <code>low_sight_angle</code> is <code>Some(...)</code> value, a sight is added to the next sight list and <code>low_sight_angle</code> is reset to <code>None</code>.
On the other hand, if the tile isn't a wall and <code>low_sight_angle</code> is <code>None</code>, <code>low_sight_angle</code> is set to either <code>low_mid_angle</code> or the low slope of the sight, whichever is higher; we need this check to ensure that we're never expanding sights in a way that doesn't make sense.</p>
<p>With sight management out of the way we can finally visit the tile.
As mentioned earlier, this involves setting the <code>out_pos</code> and <code>out_symmetric</code> variables, but there's a catch to this.
First, we need to ensure that the tile is within the map bounds; we don't want to return out-of-bounds coordinates.
Second, remember those shared edges between octants?
This is the point where we check for that.
We don't have to worry if <code>y</code> is strictly between 0 and <code>x</code>, but those exact values are the shared edge tiles.
We only want to visit those if we're in octants that set the <code>include_edges</code> flag, which you may have noticed was part of the octant data amongst the hard-coded coefficients.
This <code>include_edges</code> flag is set for octants 0, 3, 4 and 7, so the shared edge tiles will be visited in these octants and skipped in the others.
Tile visitation is concluded by incrementing <code>y</code>.</p>
<p>When <code>y</code> ticks past the <code>high_y</code> set for the current sight, it needs to wrap up with a final sight if <code>low_sight_angle</code> is still set to <code>Some(...)</code> value at this point.
Other than that, <code>s</code> is incremented to move onto the next sight in the current sight list, and <code>y</code> is reset to <code>None</code> to invoke the start-of-sight logic the next time it's called.</p>
<p>Beneath that is the case where <code>s</code> has iterated through all of the sights in the current sight list, meaning that the whole column has been processed.
The <code>x</code> value is incremented to move onto the next column, while <code>s</code> is reset to <code>None</code>.</p>
<p>The final <code>else</code> block under that is when every column of the octant has been processed.
The iterator moves onto the next octant by incrementing the <code>octant</code> field and resetting <code>x</code> to <code>None</code>.
When the <code>octant</code> field takes on the <code>Some(8)</code> value, shadow casting is complete and the field of view has been fully calculated!</p>
<h2 id="conclusion-2"><a class="header" href="#conclusion-2">Conclusion</a></h2>
<p>The field of view code is some of the earliest code I ever wrote for RuggRogue.
Indeed, RuggRogue started as a fake terminal demo, and spent a lot of its early life as a proof-of-concept for shadow casting.
There's no doubt in my mind that I would write this differently if I were to revisit this today: make better use of Rust's iterator API, define slopes as a proper type instead of an integer tuple so I could define ordering and use normal inequality operators, and so on.
However, if I stayed and continually refined this field of view code, I would never have moved onto finishing the rest of the game.</p>
<p>Despite its issues, I'm still quite happy with how field of view calculation turned out: it runs well, the results are good and I can be confident that I understand shadow casting well enough to implement it from scratch.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pathfinding"><a class="header" href="#pathfinding">Pathfinding</a></h1>
<p>As the player explores the dungeon in RuggRogue they'll encounter monsters.
When a monster sees the player they will move towards the player to attack them.
The path taken by that monster is determined by <em>pathfinding</em>, which makes up the most important part of their AI.
This chapter touches on the algorithm used for pathfinding, then covers the details needed to make it work in the context of the game.</p>
<h2 id="the-a-search-algorithm"><a class="header" href="#the-a-search-algorithm">The A* Search Algorithm</a></h2>
<p>Getting a monster to approach the player is about finding a path between their positions on the map.
The traditional approach to calculating a path in this context is the <em>A* search algorithm</em> (pronounced &quot;a-star&quot;).
Unlike shadow casting approaches in the <a href="field-of-view.html">Field of View chapter</a>, all A* search implementations have a similar structure.
Instead of painstakingly describing it here, I'll link to Red Blob Games instead:</p>
<blockquote>
<p><a href="https://www.redblobgames.com/pathfinding/a-star/introduction.html">Introduction to the A* Algorithm at Red Blob Games</a></p>
</blockquote>
<p><strong>The A* search algorithm is an enhancement to breadth-first search that prioritizes fringe nodes by the sum of the distance travelled plus estimated distance to the destination based on a heuristic function.</strong>
If any part of that sentence did not make sense, you should read the Red Blob Games link first and come back here later.
The rest of this chapter will address implementation details surrounding the use of the A* search algorithm in RuggRogue and less the algorithm itself.</p>
<h2 id="overview-of-pathfinding-in-ruggrogue"><a class="header" href="#overview-of-pathfinding-in-ruggrogue">Overview of Pathfinding in RuggRogue</a></h2>
<p>Pathfinding in RuggRogue can be broken down into several parts:</p>
<ul>
<li>The monster AI that uses pathfinding.</li>
<li>Deciding which map tiles are blocked and which are walkable for the purposes of pathfinding.</li>
<li>The front-end pathfinding function and the iterator it prepares and returns.</li>
<li>The back-end function that forms the core of the pathfinding implementation.</li>
</ul>
<p>The monster AI lives in the <code>do_turn_for_one_monster</code> function in the <code>src/monster.rs</code> file.
It calls the <code>ruggrogue::find_path</code> function to find a path to the player and takes a single step towards them.</p>
<p>The map informs the pathfinding system about which of its tiles are blocked and which are walkable by implementing the <code>ruggrogue::PathableMap</code> trait defined in the <code>src/lib/path_find.rs</code> file.
The map defines a single <code>is_blocked</code> function for this trait in the <code>src/map.rs</code> file to do this, the result of which is based on the type of tile at that position, along with any entities there.</p>
<p>The <code>ruggrogue::find_path</code> function is the front-end function for pathfinding, defined in the <code>src/lib/path_find.rs</code> file.
It calls the back-end <code>a_star</code> function in the same file to calculate the raw path data, then prepares the path it finds into an <code>AStarIter</code> struct, which is an iterator describing that path.</p>
<h2 id="pathfinding-in-monster-ai"><a class="header" href="#pathfinding-in-monster-ai">Pathfinding in Monster AI</a></h2>
<p>The <code>do_turn_for_one_monster</code> function in the <code>src/monster.rs</code> file handles the AI for a single monster turn.
The following code runs when the monster can see the player:</p>
<pre><code class="language-rust ignore">if let Some(step) = ruggrogue::find_path(&amp;*map, pos, player_pos, 4, true).nth(1) {
    if step == player_pos {
        damage::melee_attack(world, monster, player_id.0);
    } else {
        let blocks = world.borrow::&lt;View&lt;BlocksTile&gt;&gt;();
        let mut coords = world.borrow::&lt;ViewMut&lt;Coord&gt;&gt;();
        let mut fovs = world.borrow::&lt;ViewMut&lt;FieldOfView&gt;&gt;();

        map.move_entity(monster, pos, step, blocks.contains(monster));
        (&amp;mut coords).get(monster).0 = step.into();
        (&amp;mut fovs).get(monster).dirty = true;
    }
}
</code></pre>
<p>The call to the <code>ruggrogue::find_path</code> function retrieves the path from the monster to the player as an <code>AStarIter</code> instance, which is an iterator that returns the position of each step in that path.
Since this handles only single turn, we want the monster to only take the next step towards the player.
The first step of the <code>AStarIter</code> iterator is the starting position of the monster, so we need to use <code>nth(1)</code> for the next step.
This whole thing is wrapped in an <code>if let</code> block, so if the monster cannot find a path to the player it will simply do nothing.</p>
<p>Assuming that the monster finds a path, if that next step is the player's position, the monster performs a melee attack, otherwise it takes a step.
When the monster moves, its position is updated for the map by the <code>Map::move_entity</code> function defined in the <code>src/map.rs</code> file.
The <code>Coord</code> component of the monster entity needs to be similarly updated.
Finally, the monster's field of view needs to be recalculated based on its new position, so its <code>FieldOfView</code> component is marked dirty.</p>
<h2 id="blocked-map-tiles"><a class="header" href="#blocked-map-tiles">Blocked Map Tiles</a></h2>
<p>RuggRogue uses the A* search algorithm to find a path from a monster to the player.
This path has two main concerns:</p>
<ol>
<li>Don't walk through walls.</li>
<li>Don't walk through other monsters.</li>
</ol>
<p>The <code>Map</code> struct (defined in <code>src/map.rs</code>) implements the <code>ruggrogue::PathableMap</code> trait (defined in <code>src/lib/path_find.rs</code>) to tell the pathfinding code about these two things.
The implementation itself can be found in the lower half of the <code>src/map.rs</code> file, and looks like this:</p>
<pre><code class="language-rust ignore">impl ruggrogue::PathableMap for Map {
    fn is_blocked(&amp;self, x: i32, y: i32) -&gt; bool {
        matches!(self.get_tile(x, y), &amp;Tile::Wall)
            || self
                .tile_entities
                .get(&amp;(x, y))
                .map_or(false, |(block_count, _)| *block_count &gt; 0)
    }
}
</code></pre>
<p>The wall check should be self-explanatory, but the part concerning entities warrants some explanation.
The position of all entities placed on the map is stored in their <code>Coord</code> component, but it's also redundantly stored in the <code>tile_entities</code> field of the <code>Map</code> struct, which is the <em>spatial entity cache</em>:</p>
<pre><code class="language-rust ignore">pub struct Map {
    // ...

    // (x, y) -&gt; (blocking_entity_count, entities_here)
    #[serde(skip)]
    tile_entities: HashMap&lt;(i32, i32), (i32, Vec&lt;EntityId&gt;)&gt;,

    // ...
}
</code></pre>
<p>The keys of the <code>tile_entities</code> hash map are map positions.
The value is made up of two parts: a count and a list of entities present at that map position.
As you might have guessed from the comment in the code above, the count tracks the number of entities in the list that block pathfinding.
All entities that block pathfinding are marked with a <code>BlocksTile</code> component, and every monster is spawned with this component in the <code>spawn_monster</code> function in the <code>src/spawn.rs</code> file.</p>
<p>The maintenance of the spatial entity cache is managed by three functions associated with the <code>Map</code> struct:</p>
<ul>
<li><code>Map::place_entity</code></li>
<li><code>Map::remove_entity</code></li>
<li><code>Map::move_entity</code></li>
</ul>
<p>These functions are called in numerous places for all entities, such as when starting or loading a game, player movement, and picking up and dropping of items.
They are especially important when called for monsters in order to update the blocking entity count of tile positions in the spatial entity cache when they move or are spawned or despawned.</p>
<p>Based on all of this, the <code>is_blocked</code> function from earlier can therefore determine if a tile contains a blocking entity by simply checking the spatial entity cache for a non-zero blocking entity count, saving it from having to scan the whole entity list for entities with a <code>BlocksTile</code> component.</p>
<h2 id="the-ruggroguefind_path-function-and-astariter-struct"><a class="header" href="#the-ruggroguefind_path-function-and-astariter-struct">The <code>ruggrogue::find_path</code> Function and <code>AStarIter</code> Struct</a></h2>
<p>When the monster AI wants to find a path to the player, it requests it by calling the <code>ruggrogue::find_path</code> function defined in the <code>src/lib/path_find.rs</code> file.
This function returns its result as an instance of the <code>AStarIter</code> struct, which is an iterator that yields each step in the path that it finds from the starting position to the destination.</p>
<p>The first thing the <code>ruggrogue::find_path</code> function does is prepare a hash map for the back-end <code>a_star</code> function to fill in with raw pathfinding data:</p>
<pre><code class="language-rust ignore">let mut came_from: HashMap&lt;(i32, i32), (i32, i32)&gt; = HashMap::new();
</code></pre>
<p>The key of this hash map is a tile position, while the value is the position of the pathfinding step taken to get to this tile.
Following this linkage of steps from any keyed position will eventually lead back to the starting position.
In other words, the path data that will be stored in here will be backwards; that will be dealt with later.</p>
<p>The <code>ruggrogue::find_path</code> function calls the <code>a_star</code> function defined above it to perform the pathfinding itself:</p>
<pre><code class="language-rust ignore">let closest = a_star(map, start, dest, bound_pad, &amp;mut came_from);
</code></pre>
<p>The first thing to note is the <code>bound_pad</code> argument.
In order to avoid excessive path exploration when no path exists between a monster and the player, pathfinding in RuggRogue is not typically performed over the entire map.
Instead, pathfinding is bounded by a rectangle of tiles that includes the monster and player positions as corners.
If the <code>bound_pad</code> argument is non-zero, this rectangle is expanded to include <code>bound_pad</code>-worth of extra tiles on all sides; a zero <code>bound_pad</code> causes pathfinding to explore the whole map if needed.</p>
<p>The call to the <code>a_star</code> function populates the <code>came_from</code> hash map, but it also returns the position of the tile closest to the destination out of all the tiles that it explored.
If a path is found to the destination, this <code>closest</code> tile will be the destination itself.
If there is no such path, the caller of <code>ruggrogue::find_path</code> can opt into receiving a path to this closest tile instead by setting the <code>fallback_closest</code> argument to true; monster AI uses this to allow multiple monsters to pursue the player down a single-tile-wide corridor for example.</p>
<p>As mentioned earlier, the raw path data in the <code>came_from</code> hash map has each tile point <em>backwards</em> to the tile it was reached via and is thus backwards from how the caller of <code>ruggrogue::find_path</code> needs it.
The links of the path need to be reversed so that each tile on the path points forwards and not backwards.
The code looks like this:</p>
<pre><code class="language-rust ignore">// Reverse the path from closest to start.
let mut current = came_from.get(&amp;closest).copied();
let mut prev = closest;

came_from.remove(&amp;closest);

while let Some(c) = current {
    let next = came_from.get(&amp;c).copied();

    came_from.insert(c, prev);
    prev = c;
    current = next;
}
</code></pre>
<p>This is the same kind of logic used to reverse a linked list.</p>
<p>If you're clever, you might be wondering why the <code>ruggrogue::find_path</code> function doesn't just reverse the start and destination positions to avoid having to manually reverse path data.
Doing that would only save work if a path is definitely found between a monster and the player.
If no path exists, the closest tile position is useless since it's only reachable from the destination and not the starting position; a second pathfinding run starting from the starting position would be needed anyway in that case.</p>
<h2 id="the-a_star-function"><a class="header" href="#the-a_star-function">The <code>a_star</code> Function</a></h2>
<p>The <code>a_star</code> function lives just above the <code>ruggrogue::find_path</code> function in the <code>src/lib/path_find.rs</code> file; this is where the A* search algorithm is implemented in the game code.
Its main job is to populate the <code>came_from</code> hash map passed into it with path data that hopefully connects the start and destination positions; to do this it needs some supporting data:</p>
<pre><code class="language-rust ignore">// (priority, (x, y))
let mut frontier: BinaryHeap&lt;(Reverse&lt;i32&gt;, (i32, i32))&gt; = BinaryHeap::new();
// ((x, y), cost)
let mut cost_so_far: HashMap&lt;(i32, i32), i32&gt; = HashMap::new();
</code></pre>
<p>The <code>frontier</code> holds the set of tiles that the A* search algorithm will want to explore next; this is sometimes referred to as the <em>open set</em>.
To minimize the number of explored tiles, tiles need to be popped out of the frontier based on how long the algorithm <em>thinks</em> the final path will be if it were to go through those tiles.
Tiles therefore need to be popped out of the frontier in priority order: the <code>BinaryHeap</code> collection from Rust's standard library is perfect for this purpose.
The data held in the <code>frontier</code> binary heap is a priority paired with a tile position.
Rust's <code>BinaryHeap</code> type pops values out with highest numeric priority first, but we want the <em>shortest</em> path, not the longest, hence the <code>Reverse&lt;i32&gt;</code> type that reverses comparison order of numbers held within it.</p>
<p>There's one more piece of data that needs to be remembered for each tile explored by the path finding algorithm: the path cost from the starting position to that tile.
This is held in the <code>cost_so_far</code> hash map whose keys are tile positions and values are the distance from the starting position.</p>
<p>As part of the A* search algorithm, the priority of a tile in the frontier is the sum of the distance so far and the estimated distance to the destination.
This estimate is calculated using a <em>heuristic function</em>; the one used by the <code>a_star</code> function looks like this:</p>
<pre><code class="language-rust ignore">let dist100 = |(x1, y1), (x2, y2)| {
    let x_diff = if x1 &lt; x2 { x2 - x1 } else { x1 - x2 };
    let y_diff = if y1 &lt; y2 { y2 - y1 } else { y1 - y2 };
    let (low_diff, high_diff) = if x_diff &lt; y_diff {
        (x_diff, y_diff)
    } else {
        (y_diff, x_diff)
    };

    // Prefer axis-aligning with (x2, y2).
    low_diff * 141 + (high_diff - low_diff) * 99
};
</code></pre>
<p>This function calculates the approximate distance between two points, times 100 to avoid having to convert between integers and floating point values.
This estimates the path cost where every diagonal step costs 141 (i.e. the square root of 2, multiplied by 100) and every cardinal step thereafter costs 100...</p>
<p>Wait, why is there a multiplication by &quot;99&quot; and not &quot;100&quot;?</p>
<p>To understand why this is, we need to go all the way back to monster AI.
A monster will only pursue the player if they can see the player; if the monster loses sight of the player it will no longer give chase.
If the player retreats down a corridor, a monster's best chance of keeping the player in its sights involves lining up with the player directly on either the horizontal or vertical axes.
In other words, a monster wants to maximize the number of cardinal moves left in its path to the player while minimizing the number of diagonal moves left.
By making cardinal moves cost 99 instead of 100 in the heuristic function, the monster's path will &quot;hoard&quot; cardinal steps by taking diagonal steps as early as possible.
Take a moment to think through why this works: it definitely took me some time to wrap my head around at first.
Just remember that <code>dist100</code> is only a heuristic function; it doesn't actually affect the real path cost, just the priority of tiles explored in the frontier.</p>
<p>There's another oddity about this heuristic function that, unlike the quirk above, is also reflected in the real path cost.
Diagonal steps have an extra cost compared to cardinal moves in all of this pathfinding code, but steps in all eight directions cost a single turn during actual gameplay; why the discrepancy?
Using Euclidean distance for pathfinding like this leads to paths that look more like what a human would choose.
Using the exact distance calculations used by the gameplay instead leads to many intermediate frontier tiles with equal priority values, and the tie-breaking involved often leads to technically correct shortest paths that look ugly or bizarre.</p>
<p>The big <code>while</code> loop in the <code>a_star</code> function performs the main part of the A* search algorithm: pop a tile from the frontier, terminate if it's the destination and add surrounding tiles to the frontier based on path cost priority.
However, there's a little bit of extra tracking data:</p>
<pre><code class="language-rust ignore">let mut closest = start;
let mut closest_cost = 0;
let mut closest_dist = dist100(start, dest);
</code></pre>
<p>Each tile popped from the frontier is additionally checked to see if it's the closest to the destination.
The big <code>while</code> loop updates this so that there's a fallback destination to take a path towards if the real destination cannot be reached.</p>
<h2 id="conclusion-3"><a class="header" href="#conclusion-3">Conclusion</a></h2>
<p>The pathfinding code in RuggRogue was written fairly early in its life cycle, so it does things a bit strangely compared to how I would author the code nowadays.</p>
<p>Astute readers may notice that the code calculates the whole path for a monster, takes just a single step and recalculates the path again on its next turn.
This is less wasteful than it seems: the book-keeping data for the A* search algorithm has to be allocated anyway even for a single step, so discarding it immediately doesn't differ much from creating an iterator, taking a single step and throwing away the iterator.</p>
<p>The tweak to the heuristic function to get monsters to line up with the player to chase them down corridors works pretty well.
It's still possible to juke monsters by leaving their fields of view, but it makes it more likely that monsters in a room that see a player in a corridor will chase the player down that corridor.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="randomness"><a class="header" href="#randomness">Randomness</a></h1>
<p>RuggRogue is a roguelike, and the signature feature of roguelikes is the use of procedural content generation: levels, items and enemy placement differ from play to play.
This is typically achieved through the use of a <em>random number generator</em> (or <em>RNG</em>).
This chapter will cover generation, usage and considerations of random numbers by RuggRogue.</p>
<h2 id="generating-random-numbers"><a class="header" href="#generating-random-numbers">Generating Random Numbers</a></h2>
<p>Roguelikes typically get their random numbers from what's called a <em>pseudo-random number generator</em> (or <em>PRNG</em>).
&quot;Pseudo&quot; means &quot;fake&quot;, so a PRNG produces a <em>deterministic</em> series of numbers that just happen to look random enough for the purposes of a computer game.
RuggRogue takes advantage of this determinism.
Most roguelikes just initialize a single PRNG, hang onto it and share it across the whole game logic.
RuggRogue instead creates <em>temporary</em> PRNGs whenever some code needs random numbers and discards those PRNGs afterwards.
By carefully controlling how these PRNGs are initialized we can achieve <em>seeded games</em>, where two games with the same seed produce the same dungeon and spawns.
Seeded games are useful for debugging and play-testing, and can be fun for players to mess around with.</p>
<p>The nuts and bolts of generating random numbers is handled via external crates: <a href="https://crates.io/crates/rand">rand</a>, <a href="https://crates.io/crates/rand_xoshiro">rand_xoshiro</a> and <a href="https://crates.io/crates/wyhash">wyhash</a>.
rand provides a convenient interface to make use of random numbers generated from a backend source crate.
rand_xoshiro is a fast PRNG that provides the actual random numbers.
wyhash is a hasher that takes input values and produces seed values to initialize PRNGs.
These three crates serve as the foundation of all of the randomness in RuggRogue.</p>
<p>A PRNG is initialized with a seed value that determines the sequence of random numbers that will be produced, so the first step in generating random numbers is to create this seed value.
These seed values are created by combining the following input values using wyhash:</p>
<ol>
<li>A unique magic number.</li>
<li>The game seed.</li>
<li>Any other relevant differentiating input values.</li>
</ol>
<p>Each place in the code that needs random numbers starts by feeding a magic number into a wyhash hasher.
Each magic number is an arbitrary number that is used in only one place in the code, the values of which can be found in the <code>src/magicnum.rs</code> file:</p>
<pre><code class="language-rust ignore">///! Arbitrary constants to seed hashers whose output is in turn used to seed RNGs.

pub const GENERATE_ROOMS_AND_CORRIDORS: u64 = 0x3fdc77fb4d7f5d2f;
pub const SPAWN_GUARANTEED_WEAPON: u64 = 0x67caf3e7b16e9df2;
pub const SPAWN_GUARANTEED_ARMOR: u64 = 0x74e90549dbcadfd0;
pub const FILL_ROOM_WITH_SPAWNS: u64 = 0xd85af3d2cf6dcbc5;
pub const MELEE_ATTACK: u64 = 0x258890651a33d5d;
</code></pre>
<p>Since there are five magic number constants, there are five unique places in the code where PRNGs are created.
The fact that the magic numbers have different values helps to avoid the same seed being used by different PRNGs, which would otherwise produce the same random number sequence.</p>
<p>The game seed is a unique number associated with a game that is the sole reason that different games have different dungeon layouts and outcomes.
The initial game seed value can be provided as a command line argument or randomly generated as needed; this is one of the first things done in the <code>main</code> entry point function in the <code>src/main.rs</code> file.
Starting a new game causes that game to adopt that initial value as that game's seed; this value is preserved across saves and loads.
If the player returns to the title screen for whatever reason, the initial game seed value is changed into another random value to avoid accidentally playing the same dungeon again.</p>
<p>With the magic number and game seed fed into the hasher, the final thing the hasher needs is some relevant differentiating input values.
For example, the PRNG associated with <code>GENERATE_ROOMS_AND_CORRIDORS</code> provides the dungeon depth so that depth 2 has a different layout to depth 1.</p>
<p>The final hash value is then used as the seed for that particular PRNG.
Here's a code excerpt for <code>GENERATE_ROOMS_AND_CORRIDORS</code> from the <code>src/map.rs</code> file that demonstrates initializing a PRNG from hashed input values:</p>
<pre><code class="language-rust ignore">use rand::SeedableRng;
use rand_xoshiro::Xoshiro128PlusPlus as GameRng;
use std::hash::Hasher;
use wyhash::WyHash;

use crate::{magicnum, GameSeed};

pub fn generate_rooms_and_corridors(/* ... */) {
    // ...

    let mut rng = {
        let mut hasher = WyHash::with_seed(magicnum::GENERATE_ROOMS_AND_CORRIDORS);
        hasher.write_u64(game_seed.0);
        hasher.write_i32(map.depth);
        GameRng::seed_from_u64(hasher.finish())
    };

    // Use rng to get random numbers...
}
</code></pre>
<h2 id="uses-of-random-numbers"><a class="header" href="#uses-of-random-numbers">Uses of Random Numbers</a></h2>
<p>RuggRogue uses random numbers to control map generation, monster and item spawns and combat outcomes.</p>
<h3 id="map-generation"><a class="header" href="#map-generation">Map Generation</a></h3>
<p>The PRNG for map generation is initialized in the <code>generate_rooms_and_corridors</code> function in the <code>src/map.rs</code> file with the help of:</p>
<ul>
<li><code>magicnum::GENERATE_ROOMS_AND_CORRIDORS</code></li>
<li>The game seed.</li>
<li>The dungeon depth for that map.</li>
</ul>
<p>This PRNG determines:</p>
<ul>
<li>the position and size of rooms,</li>
<li>whether to connect rooms with a horizontal corridor followed by a vertical corridor or vice versa, and</li>
<li>which pairs of rooms are connected with additional corridors beyond the minimum required to connect all of the rooms together.</li>
</ul>
<h3 id="monster-and-item-spawns"><a class="header" href="#monster-and-item-spawns">Monster and Item Spawns</a></h3>
<p>The main PRNG for determining monster and item spawns is initialized in the <code>fill_rooms_with_spawns</code> function in the <code>src/spawn.rs</code> file with the help of:</p>
<ul>
<li><code>magicnum::FILL_ROOM_WITH_SPAWNS</code></li>
<li>The game seed.</li>
<li>The dungeon depth of the map being filled with spawns.</li>
</ul>
<p>This PRNG determines:</p>
<ul>
<li>the placement of the starting weapon and armor in the room that the player starts in,</li>
<li>the placement of the guaranteed ration on each level,</li>
<li>whether a room should spawn items and where they should be placed,</li>
<li>whether a spawned item should be equipment or consumable,</li>
<li>whether spawned equipment should be a weapon or armor,</li>
<li>the exact type of a spawned consumable item,</li>
<li>the random extra bonus for spawned weapons and armors, and whether to round fractional power values up or down,</li>
<li>whether a room should spawn monsters and where they should be placed, and</li>
<li>the power levels of spawned monsters, and whether to round fractional power values up or down.</li>
</ul>
<p>The game makes use of two additional PRNGs to periodically spawn guaranteed weapons and armors beyond the first level.
Both of these PRNGs exist in the <code>spawn_guaranteed_equipment</code> function in the <code>src/spawn.rs</code> file.
The PRNG for spawning guaranteed weapons is initialized with:</p>
<ul>
<li><code>magicnum::SPAWN_GUARANTEED_WEAPON</code></li>
<li>The game seed.</li>
<li>The sum of the dungeon depth and the numeric value of the low four bytes of the game seed, all divided by four.</li>
</ul>
<p>The division by four in the last value causes each sequence of four adjacent levels to seed the guaranteed weapon PRNG with the same value and thus produce the same random number sequence.
This allows those levels to effectively share the same PRNG sequence so that only one of those levels will spawn a guaranteed weapon.
The four bytes of game seed adjusts the offset of the levels so the depth sequences aren't just 1-4, 5-8, etc. for every single game.</p>
<p>The initialization of the PRNG to determine guaranteed armor spawning is identical to that of the guaranteed weapon, except for the use of <code>magicnum::SPAWN_GUARANTEED_ARMOR</code> and the use of the high four bytes of the game seed instead of the low four bytes.</p>
<h3 id="combat-outcomes"><a class="header" href="#combat-outcomes">Combat Outcomes</a></h3>
<p>The combat PRNG exists in the <code>melee_attack</code> function in the <code>src/damage.rs</code> file, and is initialized with the help of:</p>
<ul>
<li><code>magicnum::MELEE_ATTACK</code></li>
<li>The game seed.</li>
<li>The current turn count.</li>
<li>The x and y coordinates of the attacker.</li>
<li>The x and y coordinates of the defender.</li>
</ul>
<p>The combat PRNG determines:</p>
<ul>
<li>whether the melee attack hits or misses, assuming the defender is not asleep,</li>
<li>whether to fluctuate damage, and if so, whether to modify it plus or minus 50%, and</li>
<li>whether to round fractional damage values up or down to the nearest whole number.</li>
</ul>
<h2 id="ensuring-identical-randomness-with-native-and-web-builds"><a class="header" href="#ensuring-identical-randomness-with-native-and-web-builds">Ensuring Identical Randomness with Native and Web Builds</a></h2>
<p>In the course of testing, I noticed that there were differences between the native and web versions of the game with the presence and placement of monsters and items, given the same game seed.
This meant that the same game seed was causing different random numbers to be produced by the same PRNG across the two builds!</p>
<p>After a lot of debugging, I discovered that this was due to the native and web builds pulling out different amounts of data from the PRNGs.
This divergence comes from pulling a <code>usize</code> from a PRNG; this is 64 bits on the <code>x86_64</code> architecture of the native build, but only 32 bits on the <code>wasm32</code> architecture of the web build.
Replacing the <code>usize</code> with a <code>u32</code> fixes the issue, but where this fix is needed can be pretty subtle.
For example, can you spot the problem here?</p>
<pre><code class="language-rust ignore">let num = rng.gen_range(1..2);

for pos in room.iter_xy().choose_multiple(rng, num) {
    spawn_random_item_at(world, rng, pos);
}
</code></pre>
<p>In the above code, the <code>num</code> variable is inferred by Rust to be of the <code>usize</code> type due to the lack of type annotations and the fact that it's the type of the second argument of the <code>choose_multiple</code> function.
This causes <code>rng.gen_range(1..2)</code> to produce different values for the native and web versions of the game.
Annotating the <code>1..2</code> input with an integer type of a fixed size resolves the issue:</p>
<pre><code class="language-rust ignore">let num = rng.gen_range(1i32..2i32);

for pos in room.iter_xy().choose_multiple(rng, num as usize) {
    spawn_random_item_at(world, rng, pos);
}
</code></pre>
<p>The use of <code>rng.gen_range(1i32..2i32)</code> extracts a 32-bit <code>i32</code> value on both the <code>x86_64</code> and <code>wasm32</code> architectures.
Note that the <code>num</code> variable above is now also of type <code>i32</code>, so it needs to be cast into <code>usize</code> when being passed into the <code>choose_multiple</code> function.</p>
<h2 id="conclusion-4"><a class="header" href="#conclusion-4">Conclusion</a></h2>
<p>This chapter serves as a high-level overview of RuggRogue's approach to generating and using random numbers.
The biggest thing to take away from all of this is the focus on determinism by seeding PRNGs with the hashed combination of carefully selected input values.
I've deliberately glossed over the nitty gritty details of exactly how each random number is used to produce random outcomes, which are better covered by other chapters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="map-generation-1"><a class="header" href="#map-generation-1">Map Generation</a></h1>
<p>As the player descends the dungeon, the game procedurally generates new levels that are unique to the game seed and dungeon depth.
Levels are created in two phases: laying out the map and placing interesting things in it like monsters and items.
This chapter is about map layout: deciding where rooms and corridors should appear, then drawing them out with wall and floor tiles.</p>
<h2 id="map-data"><a class="header" href="#map-data">Map Data</a></h2>
<p>Before diving into the logic, it helps to be familiar with how the map is represented in terms of data.
The main data structure involved is the <code>Map</code> struct that can be found in the <code>src/map.rs</code> file.
The relevant parts of it are reproduced below:</p>
<pre><code class="language-rust ignore">pub struct Map {
    pub depth: i32,
    pub width: i32,
    pub height: i32,
    tiles: Vec&lt;Tile&gt;,
    pub rooms: Vec&lt;Rect&gt;,
    // ...
}
</code></pre>
<p>The <code>depth</code> field is the dungeon depth of the map; this is <code>1</code> for the first level.
The <code>width</code> and <code>height</code> fields hold the dimensions of the map in terms of tiles.
The <code>tiles</code> field contains the tiles themselves, stored in <em>row-major</em> order, i.e. store a full row of tiles, then the next row, then the next and so on.
The <code>Tile</code> enum is defined higher up in the <code>src/map.rs</code> file:</p>
<pre><code class="language-rust ignore">pub enum Tile {
    Floor,
    Wall,
    DownStairs,
}
</code></pre>
<p>The final relevant field of the <code>Map</code> struct is the <code>rooms</code> field.
This is a list of <code>Rect</code> structs, one for each room:</p>
<pre><code class="language-rust ignore">pub struct Rect {
    pub x1: i32,
    pub y1: i32,
    pub x2: i32,
    pub y2: i32,
}
</code></pre>
<p>Here, <code>(x1, y1)</code> is the top-left corner of the room, while <code>(x2, y2)</code> is the bottom-right corner.
Even though rooms are drawn out as wall and floor tiles, the game needs to keep track of room positions like this in order to place other things in the level such as monsters and items later on, hence this list.</p>
<p>A single <code>Map</code> struct is allocated and added as unique data at game launch in the <code>main</code> function in the <code>src/main.rs</code> file, like so:</p>
<pre><code class="language-rust ignore">world.add_unique(Map::new(80, 50));
</code></pre>
<p>Every time a new level is needed, this <code>Map</code> struct is cleared and reused.
There's no special reason for this except that it just happens to be the easiest way to do this for how unique game data is handled.
Since this map is initialized here to be 80 tiles wide and 50 tiles high, all maps in the game share these dimensions.</p>
<h2 id="when-levels-are-generated"><a class="header" href="#when-levels-are-generated">When Levels are Generated</a></h2>
<p>Levels are generated by calling the <code>map::generate_rooms_and_corridors</code> function, which happens in two places:</p>
<ol>
<li>When starting a new game in the <code>new_game_setup</code> function in the <code>src/modes/title.rs</code> file.</li>
<li>When the player descends a dungeon level in the <code>player_do_descend</code> function in the <code>src/player.rs</code> file.</li>
</ol>
<h2 id="rooms-and-corridors"><a class="header" href="#rooms-and-corridors">Rooms and Corridors</a></h2>
<p>Map generation takes place in the <code>map::generate_rooms_and_corridors</code> function in the <code>src/map.rs</code> file.
As the name suggests, its job is to draw rooms and corridors in terms of map tiles, and produce a list of rooms for later use.</p>
<p>The very first thing this function does is fill the map with wall tiles.</p>
<p>Rooms and corridors are placed randomly about the map, so a random number generator is created for this purpose.
This is seeded with the game seed and the dungeon depth for the map as described in the <a href="randomness.html">Randomness chapter</a>, so each map is effectively unique across game seeds and dungeon depths.</p>
<h3 id="placing-rooms"><a class="header" href="#placing-rooms">Placing Rooms</a></h3>
<p>Rooms are placed onto the map as follows:</p>
<ol>
<li>Make a rectangle with a random width and height.</li>
<li>Pick a random position on the map.</li>
<li>If the rectangle doesn't intersect any existing room, draw floor tiles and add it to the room list.</li>
</ol>
<p>This process is repeated thirty times, so the code looks like this:</p>
<pre><code class="language-rust ignore">for _ in 0..30 {
    let w: i32 = rng.gen_range(6i32..15i32);
    let h: i32 = rng.gen_range(6i32..11i32);
    let x: i32 = rng.gen_range(1i32..map.width - w - 1);
    let y: i32 = rng.gen_range(1i32..map.height - h - 1);
    let new_room = Rect::new(x, y, w, h);

    if !map.rooms.iter().any(|r| new_room.intersects(r, 1)) {
        map.set_rect(&amp;new_room, Tile::Floor);
        map.rooms.push(new_room);
    }
}
</code></pre>
<p>This typically results in about a dozen rooms per level.</p>
<p>Rooms look better when they're surrounded by wall tiles, so the <code>x</code> and <code>y</code> values are chosen to avoid placing the room flush with the edges of the map.</p>
<p>The <code>new_room.intersects(r, 1)</code> part checks if <code>new_room</code> intersects with a room <code>r</code> that cycles through all of the existing rooms.
The <code>Rect::intersects</code> function higher up in the <code>src/map.rs</code> file takes a <code>margin</code> argument that's set to <code>1</code> tile here, so the <code>new_room</code> is 'inflated' by one tile in all directions when checking to avoid placing it flush against another room.</p>
<h3 id="connecting-rooms-with-corridors"><a class="header" href="#connecting-rooms-with-corridors">Connecting Rooms with Corridors</a></h3>
<p>Once the rooms have been placed they need to be connected in a way that guarantees that all of the rooms can be reached.
Rooms are connected with corridors as follows:</p>
<ol>
<li>Add the first room to a <code>connected</code> list and the rest to a <code>disconnected</code> list.</li>
<li>While the <code>disconnected</code> list still has rooms:
<ul>
<li>Pick the <code>disconnected</code> room that is closest to a room in the <code>connected</code> list.</li>
<li>Join those rooms with a corridor drawn out of floor tiles.</li>
<li>Move the room from the <code>disconnected</code> list to the <code>connected</code> list.</li>
</ul>
</li>
</ol>
<p>Once every room is in the <code>connected</code> list, they can all be reached via corridors.
The code itself looks like this:</p>
<pre><code class="language-rust ignore">let mut connected: Vec&lt;usize&gt; = Vec::new();
let mut disconnected: Vec&lt;usize&gt; = Vec::new();

// Consider the first room as the start of connectedness.
connected.push(0);

// All other rooms start disconnected.
for i in 1..map.rooms.len() {
    disconnected.push(i);
}

// Connect all the disconnected rooms to the connected rooms based on closeness.
while !disconnected.is_empty() {
    // Find the closest match between connected and disconnected.
    let (closest_connected, closest_disconnected) = connected
        .iter()
        .enumerate()
        .flat_map(|c| std::iter::repeat(c).zip(disconnected.iter().enumerate()))
        .min_by_key(|&amp;((_, &amp;croom), (_, &amp;droom))| {
            let ccenter = map.rooms[croom].center();
            let dcenter = map.rooms[droom].center();
            (ccenter.0 - dcenter.0).abs() + (ccenter.1 - dcenter.1).abs()
        })
        .map(|((ci, _), (di, _))| (ci, di))
        .unwrap();

    // Connect the closest connected and disconnected rooms together.
    connect_rooms(
        &amp;mut map,
        connected[closest_connected],
        disconnected[closest_disconnected],
        rng.gen::&lt;bool&gt;(),
    );

    // Transfer newly-connected room index from disconnected to connected.
    connected.push(disconnected.remove(closest_disconnected));
}
</code></pre>
<p>The <code>connected</code> and <code>disconnected</code> lists above store indices into the map's rooms list.</p>
<p>The code for finding the closest disconnected room to a connected room can be a bit tricky to read.
The <code>connected</code>/<code>iter</code>/<code>enumerate</code>/<code>flat_map</code> lines create an iterator that pairs up each connected room index with a disconnected room index.
For example, if <code>connected</code> contains <code>[0, 1]</code> and <code>disconnected</code> contains <code>[2, 3, 4]</code>, this iterator produces these pairs in order:</p>
<ul>
<li><code>(0, 2)</code></li>
<li><code>(0, 3)</code></li>
<li><code>(0, 4)</code></li>
<li><code>(1, 2)</code></li>
<li><code>(1, 3)</code></li>
<li><code>(1, 4)</code></li>
</ul>
<p>The <code>min_by_key</code> code block calculates the approximate corridor length between the center tiles of the connected and disconnected rooms and returns the pair that would need the shortest corridor to connect.
In the example above, if the <code>(1, 3)</code> pair had the shortest estimated corridor length, connected room <code>1</code> and disconnected room <code>3</code> would be joined with a corridor, and <code>3</code> would be moved from the <code>disconnected</code> list to the <code>connected</code> list.</p>
<p>The task of drawing a corridor out of floor tiles is done by <code>connect_rooms</code>:</p>
<pre><code class="language-rust ignore">let connect_rooms = |map: &amp;mut UniqueViewMut&lt;Map&gt;, r1: usize, r2: usize, h_then_v: bool| {
    let (r1x, r1y) = map.rooms[r1].center();
    let (r2x, r2y) = map.rooms[r2].center();
    if h_then_v {
        map.set_hline(r2x, r1x, r2y, Tile::Floor);
        map.set_vline(r2y, r1y, r1x, Tile::Floor);
    } else {
        map.set_vline(r2y, r1y, r2x, Tile::Floor);
        map.set_hline(r2x, r1x, r1y, Tile::Floor);
    }
};
</code></pre>
<p>The <code>h_then_v</code> argument is a flag to draw horizontal floor tiles, then vertical floor tiles; this is decided with a random coin flip by the map generation random number generator.
Corridors can freely overlap rooms and each other.</p>
<p>Savvy readers may notice that joining rooms with corridors this way is like using <em>Prim's algorithm</em> for finding the minimum spanning tree of a graph, i.e. the least cost edges to join every node.
A tree of a graph contains no loops, so what we have so far is a map with a lot of dead end rooms, which in gameplay terms means a lot of backtracking that we don't want.
To reduce the number of dead ends and backtracking needed, several extra pairs of rooms are picked at random and joined with corridors as well.</p>
<h3 id="finishing-touches"><a class="header" href="#finishing-touches">Finishing Touches</a></h3>
<p>If the player hasn't descended deep enough into the dungeon, a downstairs tile is placed in the center of the last room in the room list.
If they have, the coordinates of that same tile is passed back to the calling code so that the victory item can be placed there instead.</p>
<p>With the map tiles drawn out and the room list prepared, the map is ready to be populated with things like monsters and items.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="map-population"><a class="header" href="#map-population">Map Population</a></h1>
<p>Once a map has been generated, the next task at hand is to place interesting things in it, such as monsters and items.</p>
<h2 id="when-map-population-takes-place"><a class="header" href="#when-map-population-takes-place">When Map Population Takes Place</a></h2>
<p>Maps are populated right after they're generated with the <code>map::generate_rooms_and_corridors</code> function, in two places:</p>
<ol>
<li>When starting a new game in the <code>new_game_setup</code> function in the <code>src/modes/title.rs</code> file.</li>
<li>When the player descends a dungeon level in the <code>player_do_descend</code> function in the <code>src/player.rs</code> file.</li>
</ol>
<h2 id="placing-the-victory-item"><a class="header" href="#placing-the-victory-item">Placing the Victory Item</a></h2>
<p>If the <code>map::generate_rooms_and_corridors</code> function doesn't place stairs, it will instead return a position where the victory item should be placed; this is the center of the last room in the room list.
The code looks like this in both places it occurs:</p>
<pre><code class="language-rust ignore">if let Some(victory_pos) = world.run(map::generate_rooms_and_corridors) {
    spawn::spawn_present(world, victory_pos);
}
</code></pre>
<p>The <code>spawn::spawn_present</code> function creates the victory item and places it in the given position on the map.
The function can be found in the <code>src/spawn.rs</code> file.</p>
<h2 id="placing-the-player"><a class="header" href="#placing-the-player">Placing the Player</a></h2>
<p>The player entity exists beyond the life of any one map, so whenever a map isn't ready, the player entity lacks a <code>Coord</code> component.
To place the player, this component is added again by calling the <code>player::add_coords_to_players</code> function defined in the <code>src/player.rs</code> file.
The player can then be moved to their starting position on the map using the <code>map::place_player_in_first_room</code> function defined in the <code>src/map.rs</code> file.</p>
<p>The player is guaranteed to start the map in a different room than the downstairs (or victory item), so long as the map has more than one room (which is almost always true).</p>
<h2 id="placing-monsters-and-items"><a class="header" href="#placing-monsters-and-items">Placing Monsters and Items</a></h2>
<p>With the player and possibly the victory item out of the way, all that's left is to fill the map with monsters and items.
The function responsible for this is <code>spawn::fill_rooms_with_spawns</code>, defined in the <code>src/spawn.rs</code> file.
This in turn kicks off three main tasks:</p>
<ol>
<li>Spawn any weapons or armor that should be guaranteed based on the map's dungeon depth.</li>
<li>Spawn monsters and items in random rooms.</li>
<li>Spawn a guaranteed ration somewhere on the level.</li>
</ol>
<p>A random number generator is created to decide how most, but not all, of this should play out; consult the <a href="randomness.html">Randomness chapter</a> for details.</p>
<p>The exact order of these tasks doesn't matter, and they're simplest to talk about in reverse order, so we'll start with the ration.</p>
<h2 id="guaranteed-ration"><a class="header" href="#guaranteed-ration">Guaranteed Ration</a></h2>
<p>Every map is guaranteed to contain a single ration; this is the job of the <code>spawn_guaranteed_ration</code> function in the <code>src/spawn.rs</code> file.
It uses the <code>pick_random_pos_in_room</code> function to pick a random spot in a random room, and spawns a ration there with the <code>spawn_ration</code> function; both of these helper functions are in the same file.</p>
<h2 id="filling-the-rooms"><a class="header" href="#filling-the-rooms">Filling the Rooms</a></h2>
<p>The <code>spawn::fill_rooms_with_spawns</code> function goes through every room and randomly decides to place monsters and items in it, except for the first room where the player starts.
It calls the <code>fill_room_with_spawns</code> helper function (note the singular &quot;room&quot;) to do this.</p>
<p>There is a 1-in-4 chance for an item to be spawned in each room.
The <code>spawn_random_item_at</code> helper function chooses, creates and places items.
The exact item selection is covered in a different chapter, but generally consists of consumable scrolls and potions, with the occasional weapon or armor.</p>
<p>Each room also has a 1-in-2 chance of spawning between one to three monsters.
Early levels limit the number of monsters that can spawn per room:</p>
<ul>
<li>Depths 1 and 2: one monster per room only.</li>
<li>Depths 3 and 4: up to two monsters per room.</li>
<li>Depth 5 and deeper: up to three monsters per room.</li>
</ul>
<p>Like item spawning, there's a <code>spawn_random_monster_at</code> helper function that chooses, creates and places monsters.
Monster selection is a topic of a different chapter.</p>
<p>Finally, the limit for the number of items and monsters that can be spawned per room increases by one every time the player beats the game and picks New Game Plus.</p>
<h2 id="guaranteed-weapons-and-armor"><a class="header" href="#guaranteed-weapons-and-armor">Guaranteed Weapons and Armor</a></h2>
<p>The <code>spawn_guaranteed_equipment</code> function in the <code>src/spawn.rs</code> file is responsible for creating and placing weapons and armor beyond those from random room filling.
Unlike their random counterparts, guaranteed weapons and armor are always created at a power level appropriate for the current difficulty of the level.</p>
<p>The first kind of guaranteed equipment is the starting weapon and armor.
The game picks two random spots in the starting room and spawns and places the weapon and armor in them.</p>
<p>The second kind of guaranteed equipment needs some explanation.
As the player descends the dungeon, the monsters get stronger.
The player's base attack and defense power rises as they gain levels, but it rises slower than the power of the monsters.
To keep up, the player must pick up weapons and armor.
If weapons and armor were only created at random, it would be possible for the player to be left far less powerful than the monsters they face for a very long time.</p>
<p>To counter this issue, the game creates weapons and armors periodically according to the dungeon depth.
The simplest approach would be to spawn such equipment once every, say, four levels.
RuggRogue does essentially that, with a couple of twists to make the pattern less predictable:</p>
<ol>
<li>The <em>period offset</em> is adjusted per game, e.g. one run groups levels 1-4, 5-8, 9-12, etc. while another groups them 1-2, 3-6, 7-10, etc.</li>
<li>The <em>chosen level</em> differs per group, e.g. pick level 2 out of levels 1-4, then level 7 out of levels 5-8, etc.</li>
</ol>
<p>There's no data carried between different levels to affect their generation.
Instead, new random number generators are created that are seeded such that each level in a group gets the same seed; this is accomplished by integer dividing the map depth by the <code>EQUIPMENT_SPAWN_PERIOD</code> constant whose value is <code>4</code>.</p>
<p>The <code>periodic_weapon_rng</code> uses the low bits of the game seed to adjust the period offset.
A single random number from <code>0</code> to <code>2</code> is extracted from this random number generator (<code>3</code> is never chosen to avoid guaranteed equipment spawning in adjacent levels).
This number is checked against the depth of the level within its group; a successful match spawns a weapon in a random room and position.</p>
<p>This process is repeated for armor using <code>periodic_armor_rng</code>, except offsetting with the high game seed bits.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="auto-run"><a class="header" href="#auto-run">Auto-Run</a></h1>
<p>Most of the time playing RuggRogue is spent moving around the dungeon.
Instead of repeatedly pressing the movement keys, the player can tell the game to move in a direction for them until something interesting is seen.
This feature is known as <em>auto-running</em>.</p>
<p>Auto-run is activated by holding the Shift key while pressing a movement key.
There are three types of auto-run:</p>
<ol>
<li><em>Resting in place</em>: Pressing Shift+Space will wait in place until the player is fully healed.</li>
<li><em>Straight auto-run</em>: Pressing Shift+direction in open space or against a wall will move in a straight line until the open space or wall ends.</li>
<li><em>Corridor auto-run</em>: Pressing Shift+direction in a corridor will follow that corridor until it branches or opens up.</li>
</ol>
<p>Once auto-run starts the game will move the player until it's interrupted by:</p>
<ul>
<li>the player pressing a key</li>
<li>a monster appearing in the player's field of view</li>
<li>the player moving next to an item or the downstairs tile</li>
<li>the player getting hungrier or losing hit points to starvation</li>
</ul>
<h2 id="auto-run-data-structures"><a class="header" href="#auto-run-data-structures">Auto-Run Data Structures</a></h2>
<p>Auto-running requires the game to perform actions across multiple frames.
This means it needs to remember that auto-run was requested, as well as type of auto-run and desired movement direction.
This means that the state of auto-running needs to be stored in data structures.</p>
<p>Everything that auto-run needs to operate is stored in the <code>Player</code> struct in the <code>src/components.rs</code> file:</p>
<pre><code class="language-rust ignore">pub struct Player {
    pub auto_run: Option&lt;AutoRun&gt;,
}
</code></pre>
<p>If the value of the <code>auto_run</code> field here is <code>None</code> it means that auto-run is not happening and the game will wait on the player for input.
On the other hand, a <code>Some(...)</code> value here means that auto-run is active, and the data within keeps track of the state of auto-running.</p>
<p>The rest of the data structures relating to auto-run, as well as most of the logic, live in the <code>src/player.rs</code> file.
The <code>AutoRun</code> struct is what's held in the aforementioned <code>auto_run</code> field, and appears as follows:</p>
<pre><code class="language-rust ignore">pub struct AutoRun {
    limit: i32,
    dir: (i32, i32),
    run_type: AutoRunType,
}
</code></pre>
<p>The <code>limit</code> field is the maximum number of steps that auto-run can proceed by itself, and exists mostly as a fail-safe against the possibility of any bugs that could cause infinite auto-running.</p>
<p>The <code>dir</code> field holds the last direction that the player moved, which determines the direction that auto-running will proceed.
This direction is interpreted as a <code>(dx, dy)</code> pair where the two values are one of <code>-1</code>, <code>0</code> or <code>1</code>.</p>
<p>The <code>run_type</code> field determines the type of auto-running that should occur; it's set when auto-run is requested and doesn't change.
It holds one of the three values of the <code>AutoRunType</code> enum that looks like this:</p>
<pre><code class="language-rust ignore">enum AutoRunType {
    RestInPlace,
    Corridor,
    Straight { expect_wall: AutoRunWallSide },
}
</code></pre>
<p>These enum variants each correspond to the three types of auto-running that were described earlier.</p>
<p>The <code>AutoRunType::Straight</code> variant holds extra data that it needs to remember that the other two <code>AutoRunType</code> variants don't need.
This <code>expect_wall</code> field holds one of the variants of the <code>AutoRunWallSide</code> enum that looks like this:</p>
<pre><code class="language-rust ignore">enum AutoRunWallSide {
    Neither,
    Left,
    Right,
}
</code></pre>
<p>Straight auto-run keeps track of walls and open tiles to the left and right of the direction that the player is auto-running.</p>
<ul>
<li><code>AutoRunWallSide::Neither</code>: Expect neither left nor right walls, i.e. both sides of the player should be fully open.</li>
<li><code>AutoRunWallSide::Left</code>: Expect a solid wall on the left and open space on the right.</li>
<li><code>AutoRunWallSide::Right</code>: Expect a solid wall on the right and open space on the left.</li>
</ul>
<p>Straight auto-run is stopped if the arrangement of tiles falls into a different category than expected, or doesn't fit into any of these categories.</p>
<h2 id="auto-run-control-flow"><a class="header" href="#auto-run-control-flow">Auto-Run Control Flow</a></h2>
<p>Auto-run integrates with the input and control flow logic as follows:</p>
<ol>
<li>The player holds Shift when pressing a movement key, handling the turn as usual but also filling in the <code>auto_run</code> field of the <code>Player</code> struct to start auto-running.</li>
<li>While auto-running, the end of the <code>DungeonMode::update</code> function tells the game loop to run on the next frame instead of waiting for an event as it normally would.</li>
<li>While auto-running, auto-run checks if it should proceed; if so, it automatically moves the player instead of doing the usual input handling logic.</li>
</ol>
<p>The Shift key during normal input handling is picked up in the <code>player::player_input</code> function in the <code>src/player.rs</code> file.
This is handed off as a boolean value to either the <code>try_move_player</code> or <code>wait_player</code> functions, which fills in the <code>auto_run</code> field of the <code>Player</code> struct after doing their usual business.
This kicks off the auto-run process.</p>
<p>The <code>player::player_input</code> function is called from the <code>DungeonMode::update</code> function in the <code>src/modes/dungeon.rs</code> file.
Its return value controls when the next update should happen, and looks roughly like this:</p>
<pre><code class="language-rust ignore">impl DungeonMode {
    fn update(/* ... */) -&gt; (ModeControl, ModeUpdate) {
        if world.run(player::player_is_alive) {
            //
            // A *lot* of stuff skipped here...
            //

            (
                ModeControl::Stay,
                if world.run(player::player_is_alive) &amp;&amp; world.run(player::player_is_auto_running) {
                    ModeUpdate::Update // &lt;-- !!!
                } else {
                    ModeUpdate::WaitForEvent
                },
            )
        } else if player::player_is_dead_input(inputs) {
            // ...
        } else {
            // ...
        }
    }
}
</code></pre>
<p>In the above code, if the player is alive and auto-running, the <code>DungeonMode::update</code> function returns <code>ModeUpdate::Update</code> instead of <code>ModeUpdate::WaitForEvent</code>.
This causes the main loop further up in the call stack to run the <code>DungeonMode::update</code> function again on the next frame, even if the input buffer is empty.</p>
<p>On subsequent updates while auto-run is active, the control flow through the <code>player::player_input</code> function looks different.
Here's a rough outline of that function:</p>
<pre><code class="language-rust ignore">pub fn player_input(/* ... */) -&gt; PlayerInputResult {
    let player_id = world.borrow::&lt;UniqueView&lt;PlayerId&gt;&gt;();

    inputs.prepare_input();

    if item::is_asleep(world, player_id.0) {
        //
        // sleep input handling...
        //
    } else if world.run(player_is_auto_running) {
        //
        // --&gt; AUTO-RUN LOGIC HERE &lt;--
        //
    } else if let Some(InputEvent::AppQuit) = inputs.get_input() {
        PlayerInputResult::AppQuit
    } else if let Some(InputEvent::Press(keycode)) = inputs.get_input() {
        //
        // normal player input handling here...
        //
    } else {
        PlayerInputResult::NoResult
    }
}
</code></pre>
<p>In the above code, the process of auto-running overrides normal player input handling.</p>
<p>The first thing that the auto-run logic in the <code>player::player_input</code> function does is check for reasons to stop, such as:</p>
<ul>
<li>receiving the <code>AppQuit</code> input event</li>
<li>receiving any keyboard input event from the player</li>
<li>the player stepping onto or next to something interesting (checked by the <code>player_check_frontier</code> function)</li>
<li>the player seeing any monsters (checked by the <code>player_sees_foes</code> function)</li>
</ul>
<p>Auto-run is stopped by the <code>player::player_stop_auto_run</code> function, which simply clears the <code>auto_run</code> field of the <code>Player</code> struct to <code>None</code>.</p>
<p>Auto-run logic then decrements the <code>limit_reached</code> field of the <code>AutoRun</code> struct, and when it hits zero also stops auto-run.</p>
<p>At this point, auto-run logic needs to perform final checks that vary based on the different auto-run types: resting in place, straight auto-run and corridor auto-run.
This is the job of the <code>auto_run_next_step</code> function, which works as follows:</p>
<ul>
<li>Resting in place returns <code>Some((0, 0))</code> if the player can still heal by resting (i.e. below maximum hit points and isn't starving) or <code>None</code> otherwise.</li>
<li>Straight auto-run and corridor auto-run check the tiles around the player and return <code>Some((dx, dy))</code> to run in the desired direction or <code>None</code> to stop.</li>
</ul>
<p>In the case that it returns <code>Some(...)</code>, the direction value within is unpacked and causes the auto-run logic to call either the <code>try_move_player</code> or <code>wait_player</code> functions to perform the auto-run step.
Note that these two functions are exactly the same ones called during normal input handling, so auto-run effectively acts like smart automatic input handling.</p>
<h2 id="resting-in-place"><a class="header" href="#resting-in-place">Resting in Place</a></h2>
<p>RuggRogue has a regeneration mechanic based on hunger level.
The hunger levels are &quot;Full&quot;, &quot;Normal&quot;, &quot;Hungry&quot;, &quot;Very Hungry&quot;, &quot;Famished&quot; and &quot;Starving&quot;.
The player will gradually regenerate lost hit points over time as long as the player is &quot;Full&quot;, &quot;Normal&quot; or &quot;Hungry&quot;.</p>
<p>Sometimes the player may wish to simply pass turns in order to recover hit points.
Instead of passing turns manually, the player can press Shift+Space to <em>rest in place</em>.
Resting in place will pass turns automatically until the player can no longer recover (due to maximum hit points or hunger) or is interrupted by a monster.</p>
<p>The choice of the Shift+Space key combination might seem odd, given that the usual key to wait a turn is Period.
However, Shift+Period produces the greater-than sign, which is the ASCII character for the downstairs tile and therefore (one of) the inputs that lets the player move downstairs.
Since Shift+Period is already spoken for, and the Space key is the alternate key for waiting a turn, resting in place is thus triggered by Shift+Space.</p>
<p>In terms of code, resting in place starts when the normal input logic detects the Shift+Space key combination.
The Space key triggers the usual logic for waiting a turn, so the <code>wait_player</code> function is called as usual.
The pressing of the Shift key causes the <code>rest_in_place</code> argument of that function to be set to <code>true</code>.</p>
<p>The first thing that the <code>wait_player</code> function does in this case is check for any reason that resting in place should not start.
If any monsters are present in the player's field of view, the player gets a message and no turns are spent waiting.
The game then calls the <code>hunger::can_regen</code> function (defined in the <code>src/hunger.rs</code> file) to perform hunger-related checks; any hunger-related reason to not rest appears as a message and prevents any waiting from taking place.</p>
<p>Assuming that there is no reason to prevent it, resting in place is started by setting the <code>auto_run</code> field of the <code>Player</code> struct with a <code>run_type</code> of <code>AutoRunType::RestInPlace</code>.
Auto-run then takes over as described earlier in the auto-run control flow section.</p>
<p>For each turn that auto-run is about to spend resting in place, the <code>auto_run_next_step</code> function consults the result of the <code>hunger::can_regen</code> function to determine if it should continue.</p>
<p>The final unique detail of resting in place is that, unlike other forms of auto-run, it ignores the presence of items and downstairs in adjacent tiles.
The <code>player_check_frontier</code> function that normally performs this check contains an early return if the <code>run_type</code> is <code>AutoRunType::RestInPlace</code>.</p>
<h2 id="straight-auto-run"><a class="header" href="#straight-auto-run">Straight Auto-Run</a></h2>
<p>Oftentimes the player will find themselves in a room with no monsters in sight.
By holding Shift while pressing a direction, the player will perform a <em>straight auto-run</em>, moving in a single direction until they're blocked or something interesting appears.
This allows the player to quickly cross empty and cleared-out rooms.</p>
<p>Straight auto-run that starts in the open will advance until the player finds themselves adjacent to any walls.
Straight auto-run that starts with a wall to one side of the player will advance until that wall ends.</p>
<p>The logic for auto-running in a direction starts when normal movement code detects that the Shift key is being held down.
As per usual, the move is handled with a call to the <code>try_move_player</code> function, but the Shift key sets the <code>start_run</code> argument to <code>true</code>.</p>
<p>If the player tries to start auto-running but a monster is in their field of view, the move is cancelled with a corresponding message.</p>
<p>After the usual movement logic, if the player indeed moved, the game must decide between engaging straight auto-run or corridor auto-run.
This decision is made by checking the pattern of walls and open tiles around the player.
Corridor wall patterns are checked for first by the <code>auto_run_corridor_check</code> function; we'll assume that its check fails for the sake of this section.</p>
<p>With the corridor check out of the way, the game decides if straight auto-run should be engaged with the result of the <code>auto_run_straight_check</code> function.
This function wants to check for patterns of walls and open tiles, but the exact tiles to check differ based on the player's movement direction.
The player can move in eight directions, but we don't want to repeat similar code for every direction.
This repetition can be avoided with the help of <em>rotation</em>.</p>
<h3 id="rotating-by-movement-direction"><a class="header" href="#rotating-by-movement-direction">Rotating by Movement Direction</a></h3>
<p>The <code>auto_run_straight_check</code> function needs to check the tile straight ahead of the player, as well as the tiles to either side.
To cut down on repeated code it uses logical dx and dy values such that it only needs to check tiles for the player moving right (cardinally) and up-right (diagonally).
Every other direction can be represented by rotating the logical dx and dy values to match the player's movement direction, resulting in real map coordinates.</p>
<p>To perform the correct rotation, the <code>auto_run_straight_check</code> function feeds the player's movement direction into another function named <code>rotate_view</code>, filling in these variables:</p>
<ul>
<li><code>real_x_from_x</code></li>
<li><code>real_x_from_y</code></li>
<li><code>real_y_from_x</code></li>
<li><code>real_y_from_y</code></li>
</ul>
<p>With the convention of positive y pointing upwards, these variables are filled in based on the player's movement direction (<code>dx</code> and <code>dy</code>) as follows:</p>
<table><thead><tr><th><code>dx</code></th><th><code>dy</code></th><th><code>real_x_from_x</code></th><th><code>real_x_from_y</code></th><th><code>real_y_from_x</code></th><th><code>real_y_from_y</code></th></tr></thead><tbody>
<tr><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>0</td><td>1</td><td>0</td><td>-1</td><td>1</td><td>0</td></tr>
<tr><td>-1</td><td>1</td><td>0</td><td>-1</td><td>1</td><td>0</td></tr>
<tr><td>-1</td><td>0</td><td>-1</td><td>0</td><td>0</td><td>-1</td></tr>
<tr><td>-1</td><td>-1</td><td>-1</td><td>0</td><td>0</td><td>-1</td></tr>
<tr><td>0</td><td>-1</td><td>0</td><td>1</td><td>-1</td><td>0</td></tr>
<tr><td>1</td><td>-1</td><td>0</td><td>1</td><td>-1</td><td>0</td></tr>
</tbody></table>
<p>If <code>player_x</code> and <code>player_y</code> represent the player's map coordinates, the following helper closures can then rotate logical dx and dy values to get real map coordinates:</p>
<pre><code class="language-rust ignore">let real_x = |dx, dy| player_x + dx * real_x_from_x + dy * real_x_from_y;
let real_y = |dx, dy| player_y + dx * real_y_from_x + dy * real_y_from_y;
</code></pre>
<p>The <code>dx</code> and <code>dy</code> values here are the x and y deltas of the tile we want to check relative to the player's position, assuming the player is moving right or up-right.</p>
<p>For example, if the player is moving right or up-right, <code>real_x_from_x</code> and <code>real_y_from_y</code> are both set to 1 by the <code>rotate_view</code> function, leading to results similar to this:</p>
<pre><code class="language-rust ignore">let real_x = |dx, dy| player_x + dx * 1 + dy * 0;
let real_y = |dx, dy| player_y + dx * 0 + dy * 1;

// simplified
let real_x = |dx, _| player_x + dx * 1;
let real_y = |_, dy| player_y + dy * 1;
</code></pre>
<p>Above, changes to <code>dx</code> and <code>dy</code> match one-to-one to the same changes in real map coordinates.</p>
<p>As another example, suppose the player is moving up or up-left.
This requires a 90-degree counter-clockwise rotation for the <code>dx</code> and <code>dy</code> values.
The values returned by the <code>rotate_view</code> function in this case fill <code>real_x_from_y</code> with -1 and <code>real_y_from_x</code> with 1, leading to something like this:</p>
<pre><code class="language-rust ignore">let real_x = |dx, dy| player_x + dx * 0 + dy * -1;
let real_y = |dx, dy| player_y + dx * 1 + dy * 0;

// simplified
let real_x = |_, dy| player_x + dy * -1;
let real_y = |dx, _| player_y + dx * 1;
</code></pre>
<p>Above, you'll notice that changes to the logical <code>dy</code> value lead to <em>reversed</em> changes to real x, e.g. logical upwards steps travel left in reality.
Meanwhile, logical <code>dx</code> value changes lead to non-reversed changes to real y, e.g. logical rightward steps travel up in reality.</p>
<p>Savvy readers will notice that conversions of logical <code>dx</code> and <code>dy</code> values into real map coordinates like this are <em>affine transformations</em>, involving rotating according to player movement direction and translation to the player's real map coordinates.</p>
<h3 id="checking-walls-and-open-space"><a class="header" href="#checking-walls-and-open-space">Checking Walls and Open Space</a></h3>
<p>Armed with the <code>real_x</code> and <code>real_y</code> helper closures, the <code>auto_run_straight_check</code> function can now tie them together into a single helper closure that checks real map coordinates for the presence of walls:</p>
<pre><code class="language-rust ignore">let check_wall = |dx, dy| map.wall_or_oob(real_x(dx, dy), real_y(dx, dy));
</code></pre>
<p>The <code>Map::wall_or_oob</code> function defined in the <code>src/map.rs</code> file is just a little helper function that returns <code>true</code> if the given tile coordinates are a wall or out-of-bounds.</p>
<p><code>check_wall</code> is used like this: If the player is moving cardinally, <code>check_wall(1, 0)</code> checks the tile in front of the player, <code>check_wall(0, 1)</code> checks the tile to their left and <code>check_wall(0, -1)</code> the tile to their right.
For a diagonally moving player, the tile in front is checked using <code>check_wall(1, 1)</code>.</p>
<p>This brings us to the whole purpose of the <code>auto_run_straight_check</code> function: to look at tiles adjacent to the player according to their movement direction to yield one of these possible return values:</p>
<ul>
<li><code>Some(AutoRunWallSide::Left)</code> - A complete wall to the left of the player and completely open tiles on the right.</li>
<li><code>Some(AutoRunWallSide::Right)</code> - A complete wall to the right of the player and completely open tiles on the left.</li>
<li><code>Some(AutoRunWallSide::Neither)</code> - Completely open tiles to the left and right of the player.</li>
<li><code>None</code> - Anything else.</li>
</ul>
<p>If the first call to <code>auto_run_straight_check</code> made in the <code>try_move_player</code> function returns one of the <code>Some(...)</code> values, that value is stored in the <code>expect_wall</code> field of the <code>AutoRunType::Straight</code> enum variant.
Each step of straight auto-run calls <code>auto_run_straight_check</code> again in the <code>auto_run_next_step</code> function and compares the result with the <code>expect_wall</code> field, only continuing if they match.
This is the crux of straight auto-run.</p>
<p>For cardinal movement, the exact tiles that need to be checked are marked below, where <code>@</code> is the player and <code>f</code>/<code>1</code>/<code>2</code> are the tiles to check:</p>
<pre><code class="language-plaintext">.11
.@f
.22
</code></pre>
<p><code>f</code> is the tile in front of the player (<code>check_wall(1, 0)</code>) and must be open for straight auto-run to proceed.</p>
<p>The <code>1</code> tiles are to the left of the player (<code>check_wall(0, 1)</code> and <code>check_wall(1, 1)</code>), as if the player is logically moving right.
These tiles must be either both walls (implying <code>AutoRunWallSide::Left</code>) or both open (implying <code>AutoRunWallSide::Right</code> or <code>AutoRunWallSide::Neither</code>).
Mismatching tiles here means that there is a partial wall to the left, so the <code>auto_run_straight_check</code> function should return <code>None</code> to prevent straight auto-running.</p>
<p>The <code>2</code> tiles are to the right of the player (<code>check_wall(0, -1)</code> and <code>check_wall(1, -1)</code>), and are checked the same way as the tiles to the left.</p>
<p>For diagonal movement, the pattern is different, but otherwise all the checks are the same as for cardinal movement.
Again, <code>@</code> is the player, and <code>f</code>/<code>1</code>/<code>2</code> are the tiles to check:</p>
<pre><code class="language-plaintext">11f
.@2
..2
</code></pre>
<p>That's it for the <code>auto_run_straight_check</code> function.</p>
<h3 id="checking-for-items-and-downstairs"><a class="header" href="#checking-for-items-and-downstairs">Checking for Items and Downstairs</a></h3>
<p>Recall that that the auto-run control flow in the <code>player::player_input</code> function needs to stop auto-running if the player finds themselves on top of or next to an item or the downstairs.
This is the job of the <code>player_check_frontier</code> function, which returns <code>true</code> if either of these things are found or <code>false</code> otherwise.</p>
<p>The <code>player_check_frontier</code> function does pretty much the same rotation trick as the <code>auto_run_straight_check</code> function.
This time the checks are for items and downstairs (or rather, any tile that isn't a wall or floor).</p>
<p>For cardinal movement, the <code>@</code> and <code>!</code> tiles are checked, where the <code>!</code> tiles are newly adjacent:</p>
<pre><code class="language-plaintext">..!
.@!
..!
</code></pre>
<p>Likewise, for diagonal movement:</p>
<pre><code class="language-plaintext">!!!
.@!
..!
</code></pre>
<h2 id="corridor-auto-run"><a class="header" href="#corridor-auto-run">Corridor Auto-Run</a></h2>
<p>The rooms of any given dungeon map are connected with corridors that are single tile wide.
If the player holds Shift while moving in a corridor, <em>corridor auto-run</em> will engage, automatically moving them along the corridor until it opens up or ends.
This allows the player to quickly move between rooms on the current dungeon level.</p>
<p>In order to implement corridor auto-run, the game must check the tiles near and around the player according to their movement direction, much like straight auto-run.
At each step, corridor auto-run checks for a single open tile in the direction of movement for the player to step into, and walls for other surrounding tiles.
This means corridor auto-run <em>changes</em> the player's movement direction at each step; the job of the <code>auto_run_corridor_check</code> function is thus to check for a pattern of corridor-like surrounding walls and produce this direction.
The direction change is dealt with in the <code>auto_run_next_step</code> function under the handling for <code>AutoRunType::Corridor</code>.</p>
<p>The same idea of rotation from straight auto-run carries into the logic for corridor auto-run in the <code>auto_run_corridor_check</code> function.
However, corridor auto-run needs to check for many more patterns of walls and open tiles.
To make this easier, the state of each of these tiles is represented by a single bit in an unsigned 16-bit integer variable named <code>nearby_walls</code>.</p>
<p>The code near the top of the <code>auto_run_corridor_check</code> function populates the bits of the <code>nearby_walls</code> variable using a different helper closure to that used by the straight auto-run logic:</p>
<pre><code class="language-rust ignore">let check_unknown_or_wall = |dx, dy| {
    !player_fov.get((real_x(dx, dy), real_y(dx, dy)))
        || map.wall_or_oob(real_x(dx, dy), real_y(dx, dy))
};
</code></pre>
<p>The <code>check_wall</code> helper closure has transformed into this new <code>check_unknown_or_wall</code> that treats tiles outside the player's field of view like walls for corridor-testing purposes.
This is used to test tiles that are two tiles away from the player, which is needed to test for some of the more unusual corridor wall tile patterns.</p>
<h3 id="single-tile-cases"><a class="header" href="#single-tile-cases">Single-Tile Cases</a></h3>
<p>A lot of the time, corridor auto-run logic is looking for a single tile to advance into that requires no more than a 90-degree turn to the left or right, with walls for all other possible steps.
If the player is moving cardinally, the code exploits rotation so it only has to work as if the player is moving right.
In the ASCII diagrams below, <code>@</code> is the player moving right, <code>#</code> is a wall and the numbers are the direction of the next step to take:</p>
<pre><code class="language-plaintext">#1#  .#2  .##  .##  .##
.@#  .@#  .@3  .@#  .@#
.##  .##  .##  .#4  #5#
</code></pre>
<p>Note the extra wall tile needed for cases 1 and 5 to ensure that the open tile is enclosed by walls and is thus corridor-like.</p>
<p>If the player is moving diagonally, rotation allows the code to treat all diagonals as if the player is moving up-right.
The diagonal cases look like this:</p>
<pre><code class="language-plaintext">1##  #2#  ##3  ###  ###
#@#  .@#  .@#  .@4  .@#
..#  ..#  ..#  ..#  .#5
</code></pre>
<p>Each of these cases can be represented as data as follows:</p>
<ul>
<li><em>Mask bits</em> that confine our wall-or-open tile pattern matching to only the tiles we care about.</li>
<li><em>Open bits</em> for any tiles that must be open.</li>
<li>A <em>direction</em> that corridor auto-run should take the player on their next step.</li>
</ul>
<p>Each of the cases above is stored in a table of mask bits, open bits and directions, with separate tables for cardinal versus diagonal movement.
Each pattern is tested as follows:</p>
<ol>
<li>Obtain a masked version of the nearby tiles by applying the bitwise AND operation to <code>nearby_walls</code> and the pattern's mask bits.</li>
<li>Separately, obtain the desired pattern by applying the bitwise AND operation to the pattern's mask bits and open bits.</li>
<li>If the two values are equal, we have a match, so return with the corresponding direction.</li>
</ol>
<p>The final wrinkle in all of this is that the dx and dy values of the direction are hard-coded in the table for the player moving right or up-right.
They need to be converted to real map directions, which involves the parameters retrieved from the <code>rotate_view</code> function call based on the player's current movement direction.
Thus the returned direction is processed for final consumption like this:</p>
<pre><code class="language-rust ignore">return Some((
    move_dx * real_x_from_x + move_dy * real_x_from_y,
    move_dx * real_y_from_x + move_dy * real_y_from_y,
));
</code></pre>
<h3 id="handling-corridor-corners"><a class="header" href="#handling-corridor-corners">Handling Corridor Corners</a></h3>
<p>Most of the time when the player is auto-running in a corridor, there will be one obvious tile to move into as described in the previous section.
However, what happens when the player encounters the corner of a corridor?
Suppose the player is moving to the right and encounters the corner of a corridor:</p>
<pre><code class="language-plaintext">  #.#
###!#
..@!#
#####
</code></pre>
<p>There are now <em>two</em> adjacent open tiles for the player to step into, marked as <code>!</code> above.
The simple single-tile cases fail to recognize that the player is still in a corridor, so we need more patterns to handle this.
What's more, these patterns need to check tiles that are <em>two</em> steps away from the player, which is why the <code>nearby_walls</code> variable needed them earlier.</p>
<p>If the player is moving cardinally, the corresponding rightward-moving patterns for corridor corners look like this:</p>
<pre><code class="language-plaintext">##
#66  #7   ###   ##
 @#  @7#  @8#   @#
 ##  ###  #8   #99
               ##
</code></pre>
<p>The cases for 7 and 8 are the most common, corresponding to a corridor corner taking a 90 degree turn either left or right respectively.
The more exotic cases for 6 and 9 handle little zig-zags that a corridor might choose to take.</p>
<p>If a corner case is matched, corridor auto-run could choose either of the two numbered open tiles to step into.
RuggRogue prefers to step into the corner, but it could just as easily cut the corner with just minor changes to the pattern tables.</p>
<p>If the player is moving diagonally, the corresponding up-right-moving patterns are as follows:</p>
<pre><code class="language-plaintext"> ##  ##
66#  #77  #8   ###
#@#   @#  @8#  @9#
           ##  #9
</code></pre>
<p>These cases are rather exotic, and are mostly triggered when the player chooses to start auto-running when stepping diagonally into the entrance of a corridor.</p>
<p>The choice of which tiles to check for corners tries to strike a balance of permissiveness to allow corridor auto-run as often as possible, and strictness to prevent it when it isn't wanted.
Settling on these patterns involved some trial-and-error, so improvements and simplifications to them might exist.</p>
<h2 id="interrupting-auto-run-for-hunger"><a class="header" href="#interrupting-auto-run-for-hunger">Interrupting Auto-Run for Hunger</a></h2>
<p>Aside from player input, tile layout, items and monsters, there are two final reasons that the game may interrupt auto-run, both related to hunger:</p>
<ol>
<li>The player drops down a hunger level.</li>
<li>The player loses hit points due to starvation.</li>
</ol>
<p>Both of these cases are handled in the <code>tick_hunger</code> function in the <code>src/hunger.rs</code> file.</p>
<p>The player's current hunger level is shown in the sidebar as one of these labels: &quot;Full&quot;, &quot;Normal&quot;, &quot;Hungry&quot;, &quot;Very Hungry&quot;, &quot;Famished&quot; and &quot;Starving&quot;.
If the hunger level drops and the new hunger level is not &quot;Normal&quot; then auto-run is interrupted by setting the <code>auto_run</code> field of the <code>Player</code> struct to <code>None</code>.</p>
<p>If the player's hunger level is &quot;Starving&quot; then they'll periodically lose hit points (&quot;Player aches with hunger!&quot;).
Each time this happens auto-run will also be interrupted to prevent the player auto-running themselves into a starvation death.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="turn-order-and-combat"><a class="header" href="#turn-order-and-combat">Turn Order and Combat</a></h1>
<p>RuggRogue is a turn-based game, so the game waits until the player finishes their turn, then gives the monsters a turn.
There's no special speed system, so turns just alternate between the player and the monsters.</p>
<p>The most common interaction between the player and the monsters during their turns is performing a <em>melee attack</em>.
These melee attacks inflict damage to their target until they eventually die, and these dead targets need special handling and clean-up.</p>
<h2 id="alternating-turns-between-the-player-and-the-monsters"><a class="header" href="#alternating-turns-between-the-player-and-the-monsters">Alternating Turns Between the Player and the Monsters</a></h2>
<p>Time advances in the game with repeated calls to the <code>DungeonMode::update</code> function in the <code>src/modes/dungeon.rs</code> file.
For the purpose of understanding turns, it looks roughly like this:</p>
<pre><code class="language-rust ignore">impl DungeonMode {
    pub fn update(&amp;mut self, world, inputs, _grids, pop_result) -&gt; (ModeControl, ModeUpdate) {
        if world.run(player::player_is_alive) {
            // ...
            let time_passed: bool = if let Some(result) = pop_result {
                //
                // Dialog and menu result handling here.
                //
            } else {
                match player::player_input(world, inputs) {
                    //
                    // Player input result handling here.
                    //
                }
            };

            if time_passed {
                world.run(damage::handle_dead_entities);
                world.run(experience::gain_levels);
                // field of view stuff...
                world.run(monster::enqueue_monster_turns);

                if world.run(player::player_is_alive) {
                    monster::do_monster_turns(world);
                    world.run(damage::handle_dead_entities);
                    world.run(experience::gain_levels);
                    // field of view stuff...

                    if world.run(player::player_is_alive) {
                        // hunger handling...
                        world.run(damage::handle_dead_entities);
                        world.run(experience::gain_levels);
                        // field of view stuff...

                        if world.run(player::player_is_alive) {
                            world.run(damage::clear_hurt_bys);
                            world.borrow::&lt;UniqueViewMut&lt;TurnCount&gt;&gt;().0 += 1;
                        }
                    }
                }

                // ...
            }

            // ...
        } else if player::player_is_dead_input(inputs) {
            (
                ModeControl::Switch(GameOverMode::new().into()),
                ModeUpdate::Immediate,
            )
        } else {
            // ...
        }
    }
}
</code></pre>
<p>The most important thing to pick up in the above code skeleton is the <code>time_passed</code> variable.
The player's turn consists of everything that they're allowed to do while <code>time_passed</code> is set to <code>false</code>.
Once the player performs a time-consuming action, the <code>time_passed</code> variable is set to <code>true</code>.</p>
<p>The <code>time_passed</code> variable is either set directly after player input handling, or indirectly after handling the result of a dialog or menu.
A return value of <code>PlayerInputResult::TurnDone</code> from the <code>player::player_input</code> function sets <code>time_passed</code> to <code>true</code>, while <code>PlayerInputResult::NoResult</code> sets it to <code>false</code>.
The other variants of <code>PlayerInputResult</code> defined at the top of the <code>src/player.rs</code> file will cause the <code>DungeonMode::update</code> function to create a dialog or menu to show.
Confirming or performing actions in these dialogs and menus usually sets <code>time_passed</code> to <code>true</code>, while cancelling out sets it to <code>false</code>.</p>
<p>Once the <code>time_passed</code> variable is set to <code>true</code>, the <code>if time_passed ...</code> conditional block performs the rest of the turn:</p>
<ol>
<li>Handle dead entities and level gains.</li>
<li>Give monsters their turn, handle dead entities and level gains again.</li>
<li>Tick hunger, handle dead entities and level gains yet again.</li>
<li>Clear damage book-keeping and increment the turn counter.</li>
</ol>
<p>Note that dead entities and experience levels need to be dealt with at each point after damage can occur.</p>
<h2 id="monster-turns"><a class="header" href="#monster-turns">Monster Turns</a></h2>
<p>Once the <code>time_passed</code> variable in the <code>DungeonMode::update</code> function is set to <code>true</code>, the monsters get their turn.
All monsters are given a turn with a call to the <code>monster::enqueue_monster_turns</code> function in the <code>src/monster.rs</code> file.
Its job is to fill in the <code>MonsterTurns</code> queue with the entity ID of each monster.
The <code>monster::do_monster_turns</code> function then pops entity IDs out to give each monster their turn.</p>
<p>Why not just loop through all monsters, handle their turns directly and avoid the need for a queue?
The answer to this is that the <code>MonsterTurns</code> queue grants turns to monsters closest to the player first to minimize blocking when a group of monsters chase the player down a corridor.
At the top of the <code>src/monster.rs</code> file, the <code>MonsterTurns</code> queue is declared as a heap that stores monster entity IDs and their distance from the player.
Since <code>MonsterTurns</code> is a heap, monster IDs are popped out closest-first, giving the desired monster turn order.</p>
<p>Each monster's turn is individually handled by the <code>do_turn_for_one_monster</code> function in the <code>src/monster.rs</code> file.
Monster AI is trivial: if the player can be seen, move towards them as described in the <a href="pathfinding.html">Pathfinding chapter</a> and perform a melee attack if adjacent.</p>
<h2 id="melee-attacks-and-damage"><a class="header" href="#melee-attacks-and-damage">Melee Attacks and Damage</a></h2>
<p>If the player moves into a monster or vice versa, a melee attack is performed.
Melee attacks are handled by the <code>damage::melee_attack</code> function in the <code>src/damage.rs</code> file.
Player melee attacks call this in the <code>try_move_player</code> function in the <code>src/player.rs</code> file.
Monster melee attacks call this in the <code>do_turn_for_one_monster</code> function in the <code>src/monster.rs</code> file.</p>
<p>The first consideration of the <code>damage::melee_attack</code> function is accuracy.
There is a flat 10% miss chance for any attack against a target as long as they aren't asleep.</p>
<p>The <code>damage::melee_attack</code> function deals with two entities that each have a <code>CombatStats</code> component, defined in <code>src/components.rs</code> like so:</p>
<pre><code class="language-rust ignore">pub struct CombatStats {
    pub max_hp: i32,
    pub hp: i32,
    pub attack: f32,
    pub defense: f32,
}
</code></pre>
<p>Notice that the <code>attack</code> and <code>defense</code> fields are typed <code>f32</code>, i.e. 32-bit single precision floating point numbers.
This allows for much finer-grained control of their values compared to if they were integers instead.</p>
<p>The player has an <code>Equipment</code> component that points to any equipped weapon or armor:</p>
<pre><code class="language-rust ignore">pub struct Equipment {
    pub weapon: Option&lt;EntityId&gt;,
    pub armor: Option&lt;EntityId&gt;,
}
</code></pre>
<p>Any such weapon or armor has a <code>CombatBonus</code> component:</p>
<pre><code class="language-rust ignore">pub struct CombatBonus {
    pub attack: f32,
    pub defense: f32,
}
</code></pre>
<p>The <code>damage::melee_attack</code> function thus calculates attack and defense values by starting with their base values in the <code>CombatStats</code> component, and adding bonuses from the <code>CombatBonus</code> components of any equipped weapon and armor.</p>
<p>The base damage calculation considers the attack power of the attacker versus the defense of the target.
The code looks like this:</p>
<pre><code class="language-rust ignore">let mut damage = if attack_value &gt;= defense_value * 2.0 {
    attack_value - defense_value
} else {
    attack_value * (0.25 + (0.125 * attack_value / defense_value.max(1.0)).min(0.25))
};
</code></pre>
<p>There are two key take-aways of the above calculation.
First, if attack is at least twice defense, base damage is just the difference between the two values.
Second, to avoid zero damage when attack is less than defense, damage from lower attack values is varied from 25% to 50% of the attack value, depending on how much lower it is than the defense value.</p>
<p>This approach has some nice properties:</p>
<ol>
<li>High attack values have a simple one-to-one relationship to damage.</li>
<li>Attacks still do a little bit of damage even if defense is higher than the attack value.</li>
<li>Low-damage attacks are still reduced by increases to defense.</li>
</ol>
<p>After base damage has been calculated it has a 25% chance of being multiplied by 1.5 (a critical hit) and 25% chance of being multiplied by 0.5 (a weak hit).</p>
<p>At this point, the damage needs to be converted from a floating point number to an integer.
Fractional values are rounded up with the help of an RNG, e.g. 3.1 damage has a 10% chance of being rounded up to 4.</p>
<p>To inflict damage, the freshly-minted integer damage value is deducted from the <code>hp</code> field of the target's <code>CombatStats</code> component.
This may push the <code>hp</code> field to zero or negative, but entity death is handled elsewhere.
An appropriate hit message is also added to the message log, with suffix punctuation to match normal (exclamation mark), critical (double exclamation mark) and weak hits (period).</p>
<p>A damaged entity is given a <code>HurtBy</code> component that's defined like this in the <code>src/components.rs</code> file:</p>
<pre><code class="language-rust ignore">pub struct HurtBy {
    Someone(EntityId),
    Starvation,
}
</code></pre>
<p>In this case, the target entity is given a <code>HurtBy::Someone(attacker)</code>, where <code>attacker</code> is the entity ID of the attacker.
If the target is a monster, this will be used later on try to grant whoever killed it experience.
If the target is the player, this will point to the monster that killed them so it can be shown on the game over screen.
These <code>HurtBy</code> components are cleared off of all entities at the end of the turn back up in <code>DungeonMode::update</code> with a call to the <code>damage::clear_hurt_bys</code> function.</p>
<p>On the topic of the game over screen, the <code>damage::melee_attack</code> function also modifies any <code>Tally</code> component that it finds attached to the attacker or defender:</p>
<pre><code class="language-rust ignore">pub struct Tally {
    pub damage_dealt: u64,
    pub damage_taken: u64,
    pub kills: u64,
}
</code></pre>
<p>The <code>damage_dealt</code> of the attacker and the <code>damage_taken</code> of the target are incremented by the final damage value if either entity has a <code>Tally</code> component.
This information is also shown on the game over screen, so in practice only the player is given a <code>Tally</code> component.</p>
<h2 id="handling-death"><a class="header" href="#handling-death">Handling Death</a></h2>
<p>If an entity falls below zero hit points, it is now dead and needs to be handled appropriately.
This job falls upon the <code>damage::handle_dead_entities</code> function defined in <code>src/damage.rs</code>.</p>
<p>The <code>damage::handle_dead_entities</code> function goes through all entities with a <code>CombatStats</code> component and checks to see if their hit points are zero or less.
The entity IDs of any such entities are gathered in batches of ten each, then processed before taking up to another ten, etc.</p>
<p>A dead entity grants experience points to whoever hurt it last so long as the following conditions hold:</p>
<ol>
<li>The dead entity is marked with a <code>HurtBy::Someone(...)</code> component.</li>
<li>The dead entity has a <code>GivesExperience</code> component, holding the number of experience points it should grant.</li>
<li>The entity referred to by the <code>HurtBy::Someone(...)</code> component has an <code>Experience</code> component to accept the granted experience points.</li>
</ol>
<p>If the dead entity is a monster, it is removed from the map before the entity is deleted entirely.</p>
<p>If the dead entity is the player, &quot;Press SPACE to continue...&quot; is added to the message log, the <code>PlayerAlive</code> unique flag is set to <code>false</code>, any existing save file is deleted and any remaining dead entity handling is skipped.</p>
<p>The <code>PlayerAlive</code> unique flag is checked by the <code>player::player_is_alive</code> function that is checked all the way back in the <code>DungeonMode::update</code> function.
Once the player is dead, control flow in the <code>DungeonMode::update</code> function flows into the <code>player::player_is_dead_input</code> function defined in the <code>src/player.rs</code> file.
Its only job is to wait for the aforementioned Space key press, to allow the player to see the dungeon at the moment of their untimely passing.</p>
<p>After the Space key is pressed, the player is whisked away to the <code>GameOverMode</code> defined in <code>src/modes/game_over.rs</code> to be shown the game over screen with the cause of death, final stats and tallied damage and kills.
Proceeding from the game over screen takes the player back to the title screen.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="items"><a class="header" href="#items">Items</a></h1>
<p>Items are scattered throughout the dungeon of RuggRogue; they reward the player for exploration.
The player can pick up and drop items to add and remove them from their inventory.
Weapons and armor are items that can be equipped by the player, conferring bonuses during combat.
Other items can be applied (used) for a variety of effects, such as healing the player, hurting monsters and inflicting status effects.</p>
<p>This chapter starts by giving a run-down of the items that exist in RuggRogue, their effects and how often they're found, with source code references sprinkled throughout.
Following this is an overview of the interface used to interact with items, and how items move between the map, the player's inventory and equipment.
Finally, targeting and effects of items that can be applied are described.</p>
<h2 id="list-of-items"><a class="header" href="#list-of-items">List of Items</a></h2>
<p>All items are spawned by calling functions named like <code>spawn_foo</code> in the <code>src/spawn.rs</code> file, where <code>foo</code> is the name of the item.
The list is as follows:</p>
<ul>
<li><strong>Present</strong> (<code>spawn_present</code>) - The player wins the game when this item is used.</li>
<li><strong>Ration</strong> (<code>spawn_ration</code>) - Consumable; restores 750 nutrition to the player.</li>
<li><strong>Health Potion</strong> (<code>spawn_healh_potion</code>) - Consumble; restores 20 hit points if the player is hurt, or increases maximum hit points by 2 otherwise.</li>
<li><strong>Magic Missile Scroll</strong> (<code>spawn_magic_missile_scroll</code>) - Consumable; inflicts 8 damage to a single target up to 6 tiles away.</li>
<li><strong>Fireball Scroll</strong> (<code>spawn_fireball_scroll</code>) - Consumble; inflicts 20 damage to targets in a 3-tile area of effect up to 6 tiles away.</li>
<li><strong>Sleep Scroll</strong> (<code>spawn_sleep_scroll</code>) - Consumable; inflicts the sleep status effect to targets in a 1-tile area of effect up to 6 tiles away.</li>
<li><strong>Weapon</strong> (<code>spawn_weapon</code>) - Equipped in the &quot;Weapon&quot; slot; provides a bonus to attack.</li>
<li><strong>Armor</strong> (<code>spawn_armor</code>) - Equipped in the &quot;Armor&quot; slot; provides a bonus to defense.</li>
</ul>
<p>Note that weapons only vary by appearance and combat bonuses and so are treated as a single item type; likewise for armor.</p>
<h2 id="item-distribution"><a class="header" href="#item-distribution">Item Distribution</a></h2>
<p>Items spawn in one of two broad ways: by room and by level.</p>
<p>When a map is being populated, one in four rooms will spawn items, following the logic in the <code>fill_room_with_spawns</code> function in the <code>src/spawn.rs</code> file.
Each such room generally spawns a single item, but may spawn an additional one for every win the player has accumulated.</p>
<p>The distribution of room items is determined by the <code>spawn_random_item_at</code> function, and looks like this:</p>
<ul>
<li>1 / 11 - a weapon or armor with an extra +1 to +3 power bonus</li>
<li>3 / 11 - Health Potion</li>
<li>3 / 11 - Magic Missile Scroll</li>
<li>2 / 11 - Fireball Scroll</li>
<li>2 / 11 - Sleep Scroll</li>
</ul>
<p>Each level spawns a single Ration with the help of the <code>spawn_guaranteed_ration</code> function.
The <code>spawn_guaranteed_equipment</code> function spawns a starting weapon and armor on the first level, and depth-appropriate weapon and armor at irregular depth intervals.
The exact process for all of this is described in detail in the <a href="map-population.html">Map Population</a> chapter.</p>
<h2 id="inventory-and-equipment"><a class="header" href="#inventory-and-equipment">Inventory and Equipment</a></h2>
<p>For the player to pick up and use items, they need an <em>inventory</em> to serve as space to hold them.
The list of items carried by the player is represented by the <code>Inventory</code> component, defined in the <code>src/components.rs</code> file:</p>
<pre><code class="language-rust ignore">pub struct Inventory {
    pub items: Vec&lt;EntityId&gt;,
}
</code></pre>
<p>The game will only allow entities to be picked up if they are marked with the <code>Item</code> tag component:</p>
<pre><code class="language-rust ignore">pub struct Item;
</code></pre>
<p>The player can equip certain items from their inventory.
The player's equipment slots are represented by the <code>Equipment</code> component:</p>
<pre><code class="language-rust ignore">pub struct Equipment {
    pub weapon: Option&lt;EntityId&gt;,
    pub armor: Option&lt;EntityId&gt;,
}
</code></pre>
<p>Note that equipment slots are separate from the inventory, so for example, equipping a weapon moves it <em>out</em> of the inventory and into the player's &quot;Weapon&quot; slot.
Items that can be equipped are marked with an <code>EquipSlot</code> component:</p>
<pre><code class="language-rust ignore">pub struct EquipSlot {
    Weapon,
    Armor,
}
</code></pre>
<p>The exact value of the <code>EquipSlot</code> component determines which equipment slot the item will be moved into when it is equipped.</p>
<h2 id="item-user-interface"><a class="header" href="#item-user-interface">Item User Interface</a></h2>
<p>Most of the time spent playing the game that isn't moving around the dungeon or fighting monsters is spent dealing with items.
As a result, about half of the interface code is dedicated solely to dealing with items.</p>
<p>Although these item-related menus and dialogs allude to actions, note that they <em>never perform these actions themselves</em>.
For example, if the player chooses to drop an item from the inventory, the inventory returns a <em>result</em> that captures that intent, and the job of dropping the item is handled elsewhere.</p>
<h3 id="pick-up-menu"><a class="header" href="#pick-up-menu">Pick Up Menu</a></h3>
<p>The player presses either the 'g' or the Comma key whenever they want to pick up an item at their position.
This pushes onto the mode stack the <code>PickUpMenuMode</code>, defined in the <code>src/modes/pick_up_menu.rs</code> file.</p>
<p>If the player isn't standing over any items, they're given a message saying as much and no menu appears.</p>
<p>If the player is standing over at least one item, a menu appears, allowing them to select an item on the map to be picked up.
This menu has cursor-based controls, along with most of the menus and dialogs in the game.
The entity ID of the selected item is returned as part of the <code>PickUpMenuModeResult</code>.</p>
<h3 id="inventory-menu"><a class="header" href="#inventory-menu">Inventory Menu</a></h3>
<p>The player presses the 'i' key to bring up the inventory menu.
This is the biggest and most advanced of the menus, represented as the <code>InventoryMode</code> in the <code>src/modes/inventory.rs</code> file.
It shows the player's currently-equipped weapon and armor in a small section at the top, with a larger inventory listing beneath it.
There's also an option to sort the inventory, which sorts inventory items according to hard-coded criteria.</p>
<p>If an inventory item is selected, an <em>inventory action menu</em> is presented for it; a similar <em>equipment action menu</em> is presented if an equipped item is selected.
Any action returned by either of these menus is relayed back as an <code>InventoryModeResult</code> with the item's entity ID, the action and a target location for items usable at range.</p>
<h3 id="inventory-action-menu-and-equipment-action-menu"><a class="header" href="#inventory-action-menu-and-equipment-action-menu">Inventory Action Menu and Equipment Action Menu</a></h3>
<p>Selecting an inventory item presents an inventory action menu, represented by the <code>InventoryActionMode</code> in the <code>src/modes/inventory_action.rs</code> file.
It shows a list of possible actions that can be performed with the item, such as &quot;Equip&quot;, &quot;Apply&quot; and &quot;Drop&quot;.
If one of these actions is chosen, it will be returned in the form of an <code>InventoryActionModeResult</code>.</p>
<p>Selecting an equipped weapon or armor in the inventory menu brings up the equipment action menu, represented by the <code>EquipmentActionMode</code> in the <code>src/modes/equipment_action.rs</code> file.
It presents &quot;Remove&quot; and &quot;Drop&quot; as possible actions, but otherwise works much the same as the <code>InventoryActionMode</code>.
An <code>EquipmentActionModeResult</code> holds the selected action in this case.</p>
<h3 id="ranged-item-targeting-mode"><a class="header" href="#ranged-item-targeting-mode">Ranged Item Targeting Mode</a></h3>
<p>If &quot;Apply&quot; is chosen in the inventory action menu for an item that is usable at range, a targeting mode needs to be brought up to choose a target location.
This is represented by the <code>TargetMode</code>, defined in the <code>src/modes/target.rs</code> file.</p>
<p>Unlike everything listed up to this point, the <code>TargetMode</code> is <em>not</em> a menu!
Instead, it draws the map and interface much like the <code>DungeonMode</code> in which most of the gameplay occurs.
However, instead of performing actions and taking turns, the <code>TargetMode</code> highlights valid target tiles for the ranged item it was invoked for.</p>
<p>The movement keys move around a cursor that allows the player to choose a target location out of the valid target tiles.
This selected target location is returned as part of the <code>TargetModeResult</code>.</p>
<h3 id="shortcut-menus"><a class="header" href="#shortcut-menus">Shortcut Menus</a></h3>
<p>The inventory menu allows interacting with items in the player's possession through a single centralized menu, but players who already know what they want to do may find this cumbersome.
RuggRogue provides shortcut menus to bypass the inventory in this case, brought up with these shortcut keys:</p>
<ul>
<li>'a' to &quot;Apply&quot;</li>
<li>'e' or 'w' to &quot;Equip&quot;</li>
<li>'r' to &quot;Remove&quot;</li>
<li>'d' to &quot;Drop&quot;</li>
</ul>
<p>Shortcut keys and actions are associated in the <code>InventoryAction::from_key</code> function in the <code>src/modes/inventory_action.rs</code> file, separate from the definition of these shortcut menus.</p>
<p>This shortens interaction from &quot;Inventory -&gt; Item -&gt; Action&quot; to just &quot;Action -&gt; Item&quot;.
Pressing one of these keys brings up the <code>InventoryShortcutMode</code>, defined in the <code>src/modes/inventory_shortcut.rs</code>.
This presents a prompt such as &quot;Apply which item?&quot; with a list of inventory items narrowed down to only those with which the action can be performed.
The chosen item is encapsulated in the <code>InventoryShortcutModeResult</code> along with the action that brought the shortcut menu up in the first place.</p>
<p>The &quot;Remove&quot; action brings up a similar <code>EquipmentShortcutMode</code> that returns an <code>EquipmentShortcutModeResult</code>.</p>
<p>Note that the &quot;Drop&quot; shortcut menu only lists inventory items even though equipment can be directly dropped while equipped.
This is a technical limitation due to how this was originally designed.</p>
<p>The shortcut keys are used beyond these shortcut menus.
For example, pressing any of them in the inventory will bring up the inventory action menu with the matching action pre-selected.
Further, pressing them in the inventory action menu will move the cursor to the matching action, or confirm the action if it's already selected.</p>
<h3 id="menu-memory"><a class="header" href="#menu-memory">Menu Memory</a></h3>
<p>When a menu that deals with items is closed, the position of the cursor will be remembered upon reopening the menu.
This makes it easier to perform the same action on a sequence of items in menus.</p>
<p>This menu cursor memory is stored in the <code>MenuMemory</code> unique defined in the <code>src/menu_memory.rs</code> file.
It's simply an array with an entry for a cursor position for each of the different item menus that the player will see:</p>
<ul>
<li><code>InventoryMode</code></li>
<li><code>InventoryShortcutMode</code> for &quot;Equip&quot;</li>
<li><code>InventoryShortcutMode</code> for &quot;Apply&quot;</li>
<li><code>InventoryShortcutMode</code> for &quot;Drop&quot;</li>
<li><code>EquipmentShortcutMode</code> for &quot;Remove&quot;</li>
<li><code>EquipmentShortcutMode</code> for &quot;Drop&quot; (unused as described in the previous section)</li>
<li><code>PickUpMenuMode</code></li>
</ul>
<p>For <code>PickUpMenuMode</code>, the <code>MenuMemory</code> will recall the map coordinates of the last time the <code>PickUpMenuMode</code> appeared.
If the player's coordinates differ from last time, the <code>PickUpMenuMode</code> will reset the cursor memory.</p>
<h2 id="moving-items-around"><a class="header" href="#moving-items-around">Moving Items Around</a></h2>
<p>While the user interface permits the player to choose actions to perform with items, the task of performing the actions themselves falls upon mode result handling logic near the top of the <code>DungeonMode::update</code> function in the <code>src/modes/dungeon.rs</code> file.
The most fundamental of these actions are the ones that simply move items around, such as picking up, dropping and equipping items.</p>
<p>Items exist in one of three places:</p>
<ol>
<li>on the map,</li>
<li>in an inventory, or</li>
<li>equipped as a weapon or armor.</li>
</ol>
<p>An item on the map is like any other entity, and thus must have a <code>Coord</code> component with its map coordinates, as well as be present in the map's spatial cache (the <code>tile_entities</code> field of the <code>Map</code> struct).
For the item to be visible but not over the player or any monsters, it must also have a <code>RenderOnFloor</code> tag component.</p>
<p>An item in an inventory is listed by its entity ID in the <code>items</code> vector of the <code>Inventory</code> component.</p>
<p>An item equipped as a weapon has its entity ID set in the <code>weapon</code> field of the relevant <code>Equipment</code> component.
An equipped armor item is set to the <code>armor</code> field instead.</p>
<p><strong>Picking up</strong> an item moves it from the map to the player's inventory.
The <code>player::player_pick_up_item</code> function in the <code>src/player.rs</code> file encapsulates this action, calling upon the <code>item::remove_item_from_map</code> and <code>item::add_item_to_inventory</code> functions defined in the <code>src/item.rs</code> file to do the heavy lifting.</p>
<p><strong>Dropping</strong> an item moves it from the player's inventory to the map.
The <code>player::player_drop</code> item function in the <code>src/player.rs</code> file handles this with the help of the <code>item::remove_item_from_inventory</code> and <code>item::add_item_to_map</code> functions defined in the <code>src/item.rs</code> file.
Equipment is dropped by the <code>item::drop_equipment</code> function with the help of an <code>unequip_item</code> helper function, both also in the <code>src/item.rs</code> file.</p>
<p><strong>Equipping</strong> an item moves it from the inventory to an equipment slot.
This is the task of the <code>item::equip_item</code> function in the <code>src/item.rs</code> file.
The <code>EquipSlot</code> component of the item is checked here to determine if the item should be equipped as a weapon or as armor.</p>
<p><strong>Unequipping</strong> an item moves it from an equipment slot back to the inventory.
This is handled by the <code>item::remove_equipment</code> function in the <code>src/item.rs</code> file.
This first unequips the item using the aforementioned <code>unequip_item</code> helper function, then moves it to the inventory with the <code>item::add_item_to_inventory</code> function.</p>
<h2 id="using-items"><a class="header" href="#using-items">Using Items</a></h2>
<p>The &quot;Apply&quot; action can be used on an item that is marked with either the <code>Consumable</code> or <code>Victory</code> tag components.
If one of the item-related menus requests that an item be applied, the <code>DungeonMode::update</code> function will handle it by calling the <code>item::use_item</code> function defined in the <code>src/item.rs</code> file.</p>
<h3 id="victory-1"><a class="header" href="#victory-1">Victory</a></h3>
<p>The first thing the <code>item::use_item</code> function checks is if the item in question has a <code>Victory</code> tag component and the user is the player.
If these conditions are true, the player has won the game!</p>
<p>The first step of handling victory is to immediately perform an auto-save.
The victory sequence involves <em>switching</em> from the <code>DungeonMode</code> to the <code>GameOverMode</code>.
If the game window closes for whatever reason, there's no confirmation dialog or any chance to save the game, since those tasks would normally be handled by the <code>DungeonMode</code>.
Auto-saving in advance mitigates this issue.</p>
<p>The victory item is then deleted and the win counter is incremented.
The <code>item::use_item</code> function returns a result that signals to the <code>DungeonMode::update</code> function that it should switch to the <code>GameOverMode</code>.</p>
<p>The <code>GameOverMode</code> defined in the <code>src/modes/game_over.rs</code> file detects that the player is still alive and has thus won the game, showing a congratulatory message in response.
Proceeding from the <code>GameOverMode</code> switches back to the <code>DungeonMode</code> to start a New Game Plus run.</p>
<h3 id="gathering-targets"><a class="header" href="#gathering-targets">Gathering Targets</a></h3>
<p>Back in the <code>item::use_item</code> function, most items won't win the game outright, so they must have some sort of effect.
The first thing to do in this case is to figure out which entities should be affected by the item.</p>
<p>Items with a <code>Ranged</code> component will already have target map coordinates chosen previously.
Items that aren't used at range imply self-use; the coordinates of the entity using the item are used in this case.</p>
<p>Affected entities are gathered by calling the <code>ruggrogue::field_of_view</code> function, centered about the target location.
The radius of this field is either zero for just the target tile, or a non-zero value extracted from the <code>AreaOfEffect</code> component attached to the item.
Using field of view calculation to determine targets like this prevents items with an area of effect from blasting through walls.</p>
<h3 id="applying-item-effects"><a class="header" href="#applying-item-effects">Applying Item Effects</a></h3>
<p>Items can have any number of effects according to the components attached to the item and the targets.</p>
<p><strong>Nutrition</strong> is added to the target if the target entity has a <code>Stomach</code> component to fill.
The <code>fullness</code> field of that <code>Stomach</code> component is filled according to the amount stated in the item's <code>Nutrition</code> component that found only on rations.</p>
<p><strong>Healing</strong> is applied if the item has a <code>ProvidesHealing</code> component and the target has a <code>CombatStats</code> component.
If the target is at less than full health, the hit points of that target are restored by the amount stated in the <code>ProvidesHealing</code> component, up to maximum hit points.
If the target is at full health, their hit points and maximum hit points are increased by two.</p>
<p><strong>Damage</strong> is applied if the item has an <code>InflictsDamage</code> component and the target has a <code>CombatStats</code> component.
This does a few things:</p>
<ol>
<li>The target's hit points are reduced according to the amount stated in the <code>InflictsDamage</code> component.</li>
<li>The target is given a <code>HurtBy::Someone(id)</code> component, where <code>id</code> is the entity ID of the item user so they can be credited if the target dies.</li>
<li>If the user has a <code>Tally</code> component, add the damage amount to the <code>damage_dealt</code> field.</li>
<li>If the target has a <code>Tally</code> component, add the damage amount to the <code>damage_taken</code> field.</li>
</ol>
<p><strong>Sleep</strong> is applied if the item has an <code>InflictsSleep</code> component and the target has a <code>CombatStats</code> component.
It adds the <code>Asleep</code> component to the target with a <code>sleepiness</code> amount determined by the <code>InflictsSleep</code> component.</p>
<p>Once all targets have been processed, if the item is marked with the <code>Consumable</code> tag component it is removed from the inventory of its user and then destroyed.</p>
<h2 id="the-sleep-status-effect"><a class="header" href="#the-sleep-status-effect">The Sleep Status Effect</a></h2>
<p>The sleep status effect renders the target unable to do anything other than pass turns until it wears off.
It affects both the player and monsters.</p>
<p>In the case of a sleeping player, there is sleep-related input handling near the top of the <code>player::player_input</code> function in the <code>src/player.rs</code> file.
In this state, almost every key press will cause the player to automatically pass their turn.
The wearing off of the sleep status is handled by calling the <code>item::handle_sleep_turn</code> function back in the <code>src/item.rs</code> file.</p>
<p>Sleeping monsters are dealt with by the <code>do_turn_for_one_monster</code> function in the <code>src/monster.rs</code> file.
A monster that is asleep simply calls the <code>item::handle_sleep_turn</code> function and bypasses the usual monster AI.</p>
<p>The <code>item::handle_sleep_turn</code> function is responsible for counting down the sleepiness of sleep-afflicted entities and waking them back up.
The sleepiness counter of the entity is decremented according to the following rules:</p>
<ul>
<li>-1 per turn.</li>
<li>-1 if the entity is the player and a monster is in their field of view, or vice versa.</li>
<li>-10 if the entity lost hit points since their last turn; the <code>Asleep</code> component tracks changes to hit points to detect this.</li>
</ul>
<p>Once the sleepiness counter reaches zero, the <code>Asleep</code> component is removed from the entity, waking them up.</p>
<p>The Sleep Scroll inflicts 36 points of sleepiness, by its construction in the <code>spawn_sleep_scroll</code> function back in the <code>src/spawn.rs</code> file.
This renders one sleeping monster vulnerable to three hits before waking up if the player wastes no turns to attack them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hunger-and-regeneration"><a class="header" href="#hunger-and-regeneration">Hunger and Regeneration</a></h1>
<p>RuggRogue features a <em>hunger</em> mechanic: the player has a 'stomach fullness' level that slowly depletes over time.
This fullness can be restored by finding and eating <em>rations</em> that spawn as consumable items on each level.
If the player stays well-fed they will slowly regenerate hit points; conversely, being very hungry stops hit point regeneration.
If fullness drops to zero, the player is considered starving and will <em>lose</em> hit points over time; this can kill the player.</p>
<p>The hunger mechanic serves as a soft timer that urges the player to move forward instead of staying in any one place for too long.
In addition, rations act as an extra incentive to explore unseen areas.</p>
<h2 id="stomach-and-nutrition"><a class="header" href="#stomach-and-nutrition">Stomach and Nutrition</a></h2>
<p>The fullness level of the player is stored in a <code>Stomach</code> component that looks like this in the <code>src/components.rs</code> file:</p>
<pre><code class="language-rust ignore">pub struct Stomach {
    pub fullness: i32,
    pub max_fullness: i32,
    pub sub_hp: i32,
}
</code></pre>
<p>The <code>fullness</code> field is the exact internal fullness level of the player; zero means the player is starving, while the <code>max_fullness</code> field simply caps its value.</p>
<p>The <code>sub_hp</code> field is used to determine when the player should regenerate a hit point (or lose one, in case of starvation).
It can be thought of as a 'fractional hit point', serving as the numerator with the denominator decided elsewhere.
This is explained later in this chapter.</p>
<p>The player is the only entity in the game with a <code>Stomach</code> component and is thus the only entity that can regenerate hit points or starve.
The player is created with a <code>Stomach</code> component with <code>fullness</code> and <code>max_fullness</code> both set to 1500 in the <code>spawn_player</code> function in the <code>src/spawn.rs</code> file.</p>
<p>The player can restore the fullness of their stomach by eating a ration.
The <code>Nutrition</code> component attached to rations is what enables this:</p>
<pre><code class="language-rust ignore">pub struct Nutrition(pub i32);
</code></pre>
<p>A ration provides 750 points of nutrition, as per its creation in the <code>spawn_ration</code> function in the <code>src/spawn.rs</code> file.
Rations work like any other consumable item, restoring nutrition as an effect in the <code>item::use_item</code> function in the <code>src/item.rs</code> file.</p>
<h2 id="hunger-states"><a class="header" href="#hunger-states">Hunger States</a></h2>
<p>Fullness is tracked internally as a continuous value, like hit points, but all of the visible effects of hunger involve first converting that value into a discrete <em>hunger state</em>.
This is represented by the <code>HungerState</code> enum defined in the <code>src/hunger.rs</code> file:</p>
<pre><code class="language-rust ignore">enum HungerState {
    Starving,
    Famished,
    VeryHungry,
    Hungry,
    Normal,
    Full,
}
</code></pre>
<p>Each variant maps to a range of <code>i32</code> values according to the <code>HungerState::from</code> function as follows:</p>
<ul>
<li><code>Starving</code>: 0</li>
<li><code>Famished</code>: 1 to 150</li>
<li><code>VeryHungry</code>: 151 to 300</li>
<li><code>Hungry</code>: 301 to 750</li>
<li><code>Normal</code>: 751 to 1200</li>
<li><code>Full</code>: 1201 and above</li>
</ul>
<p>These values are hard-coded and probably should have been calculated relative to the <code>max_fullness</code> field of the <code>Stomach</code> struct, but since there's only one <code>Stomach</code> component in the whole game, it's been left as-is.</p>
<p>The hunger state is what appears in the sidebar, not the raw value.
The hunger state determines whether the player regenerates or loses hit points, and messages appear in the message log when it changes.</p>
<h2 id="sidebar-hunger-display"><a class="header" href="#sidebar-hunger-display">Sidebar Hunger Display</a></h2>
<p>The hunger state appears in the sidebar in a label that looks like &quot;Hunger: Normal&quot;.
This hunger state label is drawn along with other player status information by the <code>draw_status</code> function in the <code>src/ui.rs</code> file.</p>
<p>The label and its foreground and background colors are determined by consulting the <code>hunger::player_hunger_label</code> function back in the <code>src/hunger.rs</code> file.
Different foreground and background colors are used to draw the player's attention to their hunger state according to urgency.</p>
<h2 id="regeneration-and-starvation"><a class="header" href="#regeneration-and-starvation">Regeneration and Starvation</a></h2>
<p>There are two hunger-related tasks that must be handled on a per-turn basis: decrementing fullness and changing hit points based on hunger state.
These tasks are handled by the <code>hunger::tick_hunger</code> function found at the bottom of the <code>src/hunger.rs</code> file.
This function is called by the <code>DungeonMode::update</code> function in the <code>src/modes/dungeon.rs</code> file after handling of monster turns.</p>
<p>The <code>hunger::tick_hunger</code> function depletes one point of fullness per turn.
If the player's hunger state and hit points allow them to regenerate, an extra point of fullness is deducted from their stomach.</p>
<p>The <code>hunger::tick_hunger</code> function is also responsible for changing hit points, either raising them for regeneration or depleting them for starvation.
However, even though the function is called every turn, we don't want to alter hit points every turn.
Instead, the function deals with what we could consider a 'partial' hit point in the form of the <code>sub_hp</code> field of the <code>Stomach</code> component.
The field is used by the <code>hunger::tick_hunger</code> function to regenerate hit points as follows:</p>
<ol>
<li>The player's fullness level is converted into a <code>HungerState</code>.</li>
<li>The <code>HungerState::turns_to_regen_to_max_hp</code> function is consulted.</li>
<li>If it returned a number, add the maximum hit points of the player to the <code>sub_hp</code> field.</li>
<li>If the <code>sub_hp</code> field is at least the value from step 2, integer divide <code>sub_hp</code> by the step 2 value, add the quotient to the player's hit points and keep the remainder in <code>sub_hp</code>.</li>
</ol>
<p>For example, if the player has 60 maximum hit points, is hurt and full, the <code>HungerState::turns_to_regen_to_max_hp</code> function will return <code>Some(300)</code>.
This adds 60 to the <code>sub_hp</code> field each turn.
When it reaches 300, the player regenerates a single hit point and 300 is subtracted from the <code>sub_hp</code> field.
Since 300 divided by 60 produces 5, this player will regenerate a hit point every five turns, and indeed will be able to regenerate their full 60 hit points in 300 turns.</p>
<p>The hunger states that permit regeneration are decided by whether or not the <code>HungerState::turns_to_regen_to_max_hp</code> function returns a number.
The player can only regenerate when their hunger state is &quot;Full&quot;, &quot;Normal&quot; or &quot;Hungry&quot;.</p>
<p>When the player's hunger state is &quot;Starving&quot;, they will <em>lose</em> hit points instead of regenerating them.
The process plays in reverse: the <code>HungerState::turns_to_starve_from_max_hp</code> function is used instead, while the <code>sub_hp</code> and player's hit points are subtracted from instead of added to.
According to the <code>HungerState::turns_to_starve_from_max_hp</code> function, the player will lose their maximum worth of hit points in 400 turns spent in the &quot;Starving&quot; hunger state.</p>
<p>Since starving causes damage, the <code>hunger::tick_hunger</code> function is responsible for tracking the damage taken in the player's <code>Tally</code> component.
It is possible for starvation to kill the player, so there's a <code>HurtBy::Starvation</code> cause attached to the player entity in case of death to show on the game over screen.</p>
<h2 id="hunger-messages"><a class="header" href="#hunger-messages">Hunger Messages</a></h2>
<p>The <code>hunger::tick_hunger</code> function compares hunger state before and after deducting fullness.
If a change is detected and the new hunger state isn't just &quot;Normal&quot;, a message chosen by the <code>HungerState::reduced_to</code> function is logged, producing something like &quot;Player is getting hungry.&quot;</p>
<p>If the player loses hit points due to starvation, they're informed with a message: &quot;Player aches with hunger!&quot;</p>
<h2 id="hunger-and-auto-run"><a class="header" href="#hunger-and-auto-run">Hunger and Auto-Run</a></h2>
<p>Changes to hunger state and losing hits points to starvation not only produce messages, but also interrupt all forms of auto-run.</p>
<p>Hunger impacts the ability for the player to begin or continue resting in place, in the <code>wait_player</code> and <code>auto_run_next_step</code> functions found in the <code>src/player.rs</code> file respectively.
They both hinge on the value returned by the <code>hunger::can_regen</code> function back in the <code>src/hunger.rs</code> file.
It returns a variant of the <code>hunger::CanRegenResult</code> enum that can be found at the top of the <code>src/hunger.rs</code> file, which looks like this:</p>
<pre><code class="language-rust ignore">pub enum CanRegenResult {
    CanRegen,
    NoRegen,
    FullyRested,
    TooHungry,
}
</code></pre>
<p>The <code>CanRegen</code> variant allows resting in place to begin or continue; the other results represent reasons the player cannot regenerate hit points.
The <code>NoRegen</code> variant means the player has no <code>Stomach</code> component, which shouldn't happen in normal play.
<code>FullyRested</code> means the player's hit points are already at their maximum.
<code>TooHungry</code> means that the <code>HungerState::turns_to_regen_to_max_hp</code> function is producing <code>None</code> because the player's fullness is too low to allow for hit point regeneration.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="experience-and-difficulty"><a class="header" href="#experience-and-difficulty">Experience and Difficulty</a></h1>
<p>Combat between the player and the monsters is at the core of RuggRogue.
Combat is defined by the damage formula described in the <a href="turn-order-and-combat.html">Turn Order and Combat</a> chapter, but that by itself isn't enough; the formula operates on numbers that still need to be decided.
These numbers include the hit points, attack and defense of the player and the monsters, as well as the attack and defense bonuses of weapons and armor.
The values of these numbers need to be able to answer questions such as how many hits are needed for a player to defeat a monster of equal level.</p>
<p>There's another problem.
Like many roguelikes and RPGs, the player in RuggRogue earns experience points when defeating monsters.
When enough experience points are earned, the player gains a level, rewarding them with more power.
How does the game avoid becoming easier over time?</p>
<h2 id="game-balance"><a class="header" href="#game-balance">Game Balance</a></h2>
<p>Questions about picking numbers are really questions about how easy or hard the game should be; in other words, they're questions about game balance.
For game balance to be reasoned about, we need to consider the relationship between the numbers of the player and those that make up the challenges and rewards encountered in the dungeon.</p>
<p>If the player has an experience level, the game must spawn monsters with some concept of a level as well.
Rewards that the player finds in the dungeon, such as weapons and armor, must also consider the concept of a level, if only to avoid being too strong or too weak when found.</p>
<p>Everything that becomes more powerful over time is created with an experience level, but exactly how powerful should each level be?
We definitely don't want level 2 to be twice as powerful as level 1, for example.
RuggRogue defines a <em>level factor</em> to control how powerful each level should be.
It's definition can be found in the <code>src/experience.rs</code> file, and looks like this:</p>
<pre><code class="language-rust ignore">fn level_factor(level: i32) -&gt; f32 {
    (1.0 + (level - 1) as f32 * 0.1).max(0.1)
}
</code></pre>
<p>The level factor is 1.0 at level 1, 1.1 at level 2, 1.2 for level 3, and so on.
In other words, every level is 10% more powerful than level 1.</p>
<p>The level factor is used to derive every other number that grows more powerful over time.
The formulas are described as functions in the <code>src/experience.rs</code> file:</p>
<table><thead><tr><th>Function Name</th><th>Formula (f = level factor)</th><th>Description</th></tr></thead><tbody>
<tr><td><code>calc_player_max_hp</code></td><td>(f * 30.0).round() as i32</td><td>Player maximum hit points</td></tr>
<tr><td><code>calc_player_attack</code></td><td>f * 4.8</td><td>Player base attack</td></tr>
<tr><td><code>calc_player_defense</code></td><td>f * 2.4</td><td>Player base defense</td></tr>
<tr><td><code>calc_monster_max_hp</code></td><td>(f * 14.0).round() as i32</td><td>Monster maximum hit points</td></tr>
<tr><td><code>calc_monster_attack</code></td><td>f * 8.0</td><td>Monster attack</td></tr>
<tr><td><code>calc_monster_defense</code></td><td>f * 4.0</td><td>Monster defense</td></tr>
<tr><td><code>calc_monster_exp</code></td><td>(f * 10.0).ceil() as u64</td><td>Experience points for defeating monster</td></tr>
<tr><td><code>calc_weapon_attack</code></td><td>f * 3.2</td><td>Weapon attack bonus</td></tr>
<tr><td><code>calc_armor_defense</code></td><td>f * 1.6</td><td>Armor defense bonus</td></tr>
</tbody></table>
<p>For example, consider a player at experience level 6.
The level factor at level 6 is <code>(1.0 + (6 - 1) as f32 * 0.1).max(0.1) = 1.5</code>.
Such a player thus has <code>(1.5 * 30.0).round() as i32 = 45</code> maximum hit points, <code>1.5 * 4.8 = 7.2</code> base attack and <code>1.5 * 2.4 = 3.6</code> base defense.
Note that attack and defense values are internally stored and handled as floating point values; the interface rounds them to whole numbers for display purposes.</p>
<p>Defining numbers in terms of the level factor like this allows us to make statements about things when their experience levels are equal:</p>
<ul>
<li>The sum of player attack (4.8) and weapon attack (3.2) is 8.0, which is equal to monster attack (8.0).</li>
<li>Likewise, the sum of player defense (2.4) and armor defense (1.6) is 4.0, which is equal to monster defense (4.0).</li>
</ul>
<p>According to the damage formula described in the <a href="turn-order-and-combat.html">Turn Order and Combat</a> chapter, melee hits cause 50% of the attack value worth of damage when attack is twice defense.
A melee hit of 8.0 attack versus 4.0 defense causes 4.0 damage.
This allows us to talk about how tough the player and monsters are:</p>
<ul>
<li>A player with 30 maximum hit points is defeated by 4.0-damage monster attacks in 7.5 turns.</li>
<li>A monster with 14 maximum hit points is defeated by 4.0-damage player attacks in 3.5 turns.</li>
</ul>
<p>Statements like this establish numeric relationships that form the foundation of game balance in RuggRogue.</p>
<h2 id="player-experience"><a class="header" href="#player-experience">Player Experience</a></h2>
<p>The experience data for the player is stored in an <code>Experience</code> component defined in the <code>src/experience.rs</code> file:</p>
<pre><code class="language-rust ignore">pub struct Experience {
    pub level: i32,
    pub exp: u64,
    pub next: u64,
    pub base: u64,
}
</code></pre>
<p>The <code>level</code> field is the player's experience level.
The <code>exp</code> field is the number of experience points the player has accumulated.
When it reaches the threshold value stored in the <code>next</code> field, the player gains a level, <code>next</code> is deducted from <code>exp</code> and <code>next</code> is increased to a larger value.
The <code>base</code> field stores the total amount of experience points that have been cashed in as levels.
The sum of <code>base</code> and <code>exp</code> is the total number of experience points earned by the player, which is shown in the sidebar while playing the game.
The player is initially spawned with a <code>level</code> of 1 and <code>next</code> set to 50 experience points to gain for their next level, as defined in the <code>spawn::spawn_player</code> function in the <code>src/spawn.rs</code> file.</p>
<p>Meanwhile, the number of experience points awarded for defeating a monster is stored in a <code>GivesExperience</code> component attached to monster entities, defined in the <code>src/components.rs</code> file like so:</p>
<pre><code class="language-rust ignore">pub struct GivesExperience(pub u64);
</code></pre>
<p>When the player attacks a monster, the monster is tagged with a <code>HurtBy</code> component that credits the player for the damage.
This is done within the <code>damage::melee_attack</code> function in the <code>src/damage.rs</code> file.
If the hit kills the monster, the <code>damage::handle_dead_entities</code> function in the same file will award the experience points in the monster's <code>GivesExperience</code> component to the player's <code>Experience</code> component.</p>
<h2 id="gaining-levels"><a class="header" href="#gaining-levels">Gaining Levels</a></h2>
<p>The experience points stored in <code>Experience</code> components are checked when the <code>DungeonMode::update</code> function in the <code>src/modes/dungeon.rs</code> file calls the <code>experience::gain_levels</code> function in the <code>src/experience.rs</code> file.
These calls occur whenever experience could have been awarded, i.e. when time passes.</p>
<p>The <code>experience::gain_levels</code> function checks if the <code>exp</code> value exceeds the <code>next</code> value; if so:</p>
<ul>
<li>The entity's level is increased by 1.</li>
<li><code>next</code> is deducted from <code>exp</code>.</li>
<li><code>next</code> is added to <code>base</code>.</li>
<li><code>next</code> is increased by 10% of its current value.</li>
</ul>
<p>If the entity has a <code>CombatStats</code> component, then their hit points, attack and defense are increased to match their freshly-gained level.
For players, this involves the <code>calc_player_max_hp</code>, <code>calc_player_attack</code> and <code>calc_player_defense</code> functions.
If monsters could gain levels, they would use the <code>calc_monster_max_hp</code>, <code>calc_monster_attack</code> and <code>calc_monster_defense</code> functions instead.
Care is taken to preserve any maximum hit points gained from drinking health potions while fully healed.</p>
<p>Finally, a message is logged if the entity gaining the level happens to be the player.</p>
<h2 id="difficulty-tracker"><a class="header" href="#difficulty-tracker">Difficulty Tracker</a></h2>
<p>The player gains experience levels over time while playing the game and thus becomes more powerful over time.
If the game never increased the levels of spawned monsters, the game would get easier over time!
But how quickly should the level of spawned monsters increase?
Too slowly and game would still get easier over time.
Too quickly and the player would eventually be overwhelmed.</p>
<p>It would be tempting to solve this by simply spawning monsters with the same level as the player.
However, this would lead to <em>rubber banding</em>, which can make players feel like they're being punished for playing too well.</p>
<p>RuggRogue takes a different approach in the form of a <em>difficulty tracker</em>.
The difficulty tracker is associated with an entity that has an <code>Experience</code> component and is thus able to gain experience and levels, but is invisible and has no <code>CombatStats</code> component.
The <code>spawn::spawn_difficulty</code> function in the <code>src/spawn.rs</code> file creates this entity when called from the <code>title::new_game_setup</code> function in the <code>src/modes/title.rs</code> file.</p>
<p>The difficulty tracker itself is a unique <code>Difficulty</code> struct defined in the <code>src/experience.rs</code> file as follows:</p>
<pre><code class="language-rust ignore">pub struct Difficulty {
    pub id: EntityId,
    exp_for_next_depth: u64,
}
</code></pre>
<p>The difficulty tracker gains experience in a different way to the player:
After map population, the <code>experience::calc_exp_for_next_depth</code> function defined in the <code>src/experience.rs</code> file is called.
This sums the experience carried by all monsters on the map and saves it to the <code>exp_for_next_depth</code> field.
When the player descends, the points saved in the <code>exp_for_next_depth</code> field are transferred to the difficulty tracker entity.
From there, the <code>experience::gain_levels</code> function is called so the difficulty tracker entity can gain levels if it needs to.</p>
<p>The level of the difficulty tracker entity determines the maximum level of monsters to spawn.
It also decides the base power level of spawned weapons and armor.</p>
<p>Oftentimes, the difficulty tracker will be part-way towards the next level in experience points.
For example, if the difficulty tracker is at level 4 and has 10% of the experience points needed for level 5, it will effectively be considered level 4.1 for the purpose of spawning monsters, weapons and armor.
If an integer level is needed, the <code>Difficulty::get_round_random</code> function in the <code>src/experience.rs</code> file will return something like &quot;5&quot; 10% of the time and &quot;4&quot; the remaining 90% of the time.
Spawning code will also often want the direct &quot;4.1&quot; value, retrieved via the <code>Difficulty::as_f32</code> function in the same file.
Such code will often use the <code>experience::f32_round_random</code> helper function to turn it into an integer after processing if needed.</p>
<h2 id="monster-selection"><a class="header" href="#monster-selection">Monster Selection</a></h2>
<p>The level of a spawned monster decides its name and appearance.
This data is stored in the <code>MONSTERS</code> array at the top of the <code>src/spawn.rs</code> file, which is consulted by the <code>spawn_random_monster_at</code> function in the same file.</p>
<p>The <code>spawn_random_monster_at</code> function doesn't always spawn a monster matching the level of the difficulty tracker; this would lead to a very monotonous dungeon population.
Instead, it considers the level provided by the difficulty tracker as the <em>highest</em> level to spawn a monster, then picks one of the following outcomes:</p>
<ul>
<li>20% for a level-matching monster</li>
<li>40% for a monster 1 to 3 levels lower</li>
<li>40% for an even lower-level monster</li>
</ul>
<p>The final level chosen decides the name and appearance for the monster.
The correct numbers for such a monster at the chosen level is filled in by the <code>spawn_monster</code> function with the help of the monster-related functions in the <code>src/experience.rs</code> file: <code>calc_monster_max_hp</code>, <code>calc_monster_attack</code>, <code>calc_monster_defense</code> and <code>calc_monster_exp</code>.</p>
<h2 id="weapon-and-armor-selection"><a class="header" href="#weapon-and-armor-selection">Weapon and Armor Selection</a></h2>
<p>The name and appearance of weapons is determined by the <code>WEAPONS</code> array near the top of the <code>src/spawn.rs</code> file.
The <code>spawn_weapon</code> function in the same file accepts the difficulty tracker's level externally at either the <code>spawn_random_item_at</code> or <code>spawn_guaranteed_equipment</code> functions.
The <code>WEAPONS</code> array is shorter than the <code>MONSTERS</code> array, so the <code>rescale_level</code> function in the same file is used to cycle through the <code>WEAPONS</code> array at a slower pace.</p>
<p>The name and appearance of armor works exactly like those of the weapons, except using an <code>ARMORS</code> array consulted by the <code>spawn_armor</code> function.</p>
<p>Weapons and armor spawned by the <code>spawn_random_item_at</code> function are granted a +1 to +3 bonus to their power, but this doesn't affect the name and appearance chosen for them.</p>
<h2 id="picking-the-final-dungeon-level"><a class="header" href="#picking-the-final-dungeon-level">Picking the Final Dungeon Level</a></h2>
<p>The <code>MONSTERS</code> array at the top of the <code>src/spawn.rs</code> file has 25 entries.
Once the difficulty tracker has allowed them all to spawn, there are no new monsters to be seen; the player has effectively seen all of the content the game has to offer.
Since monsters are chosen directly from the level of the difficulty tracker, this point is reached once the difficulty tracker reaches level 25.
If this point has been reached when a new map is spawned by the <code>map::generate_rooms_and_corridors</code> function in the <code>src/map.rs</code> file, the downstairs is replaced by the location for the victory item that ends the game.
Depending on how many monsters spawn over the course of the game, the final dungeon depth usually ends up being between 25 to 30 levels deep.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monsters"><a class="header" href="#monsters">Monsters</a></h1>
<p>This is a mini-chapter that exists mostly for the sake of completeness.
The truth about monsters in RuggRogue is they mostly overlap with the player, with a small handful of differences:</p>
<ul>
<li>Their <code>Monster</code> tag component gives them turns between player turns.</li>
<li>They move towards and fight the player if they can see the player.</li>
<li>They have no <code>Stomach</code> component, so they don't eat or regenerate.</li>
<li>They grant experience when they die to whoever defeated them.</li>
<li>They do not pick up, drop or use items.</li>
</ul>
<p>Monsters differ only in name, appearance and stats; they're treated uniformly in every other way.</p>
<h2 id="monster-list"><a class="header" href="#monster-list">Monster List</a></h2>
<p>The following is a list of monsters and their ASCII representations in the approximate order that they'll be encountered by the player:</p>
<ul>
<li>(<code>b</code>) Blob</li>
<li>(<code>B</code>) Bat</li>
<li>(<code>c</code>) Crab</li>
<li>(<code>S</code>) Snake</li>
<li>(<code>g</code>) Goblin</li>
<li>(<code>k</code>) Kobold</li>
<li>(<code>G</code>) Gnome</li>
<li>(<code>o</code>) Orc</li>
<li>(<code>u</code>) Unicorn</li>
<li>(<code>P</code>) Pirate</li>
<li>(<code>L</code>) Lizardman</li>
<li>(<code>G</code>) Ghost</li>
<li>(<code>Z</code>) Skeleton</li>
<li>(<code>O</code>) Ogre</li>
<li>(<code>N</code>) Naga</li>
<li>(<code>W</code>) Warlock</li>
<li>(<code>&amp;</code>) Demon</li>
<li>(<code>E</code>) Sentinel</li>
<li>(<code>R</code>) Robber</li>
<li>(<code>K</code>) Skateboard Kid</li>
<li>(<code>J</code>) Jellybean</li>
<li>(<code>A</code>) Alien</li>
<li>(<code>D</code>) Dweller</li>
<li>(<code>h</code>) Little Helper</li>
<li>(<code>H</code>) Big Helper</li>
</ul>
<p>The monster list exists in the form of the <code>MONSTERS</code> array near the top of the <code>src/spawn.rs</code> file.
The ASCII symbols are mapped to monsters in the <code>Symbol::text_fallback</code> function that can be found in the <code>src/gamesym.rs</code> file.</p>
<h2 id="monsters-in-other-chapters"><a class="header" href="#monsters-in-other-chapters">Monsters in Other Chapters</a></h2>
<p>The topic of monsters is covered across other chapters in this book:</p>
<ul>
<li><a href="map-population.html">Map Population</a>: Where monsters are spawned and how many appear.</li>
<li><a href="experience-and-difficulty.html">Experience and Difficulty</a>: Choice of appearance and power level of monsters, and granting experience when defeated.</li>
<li><a href="field-of-view.html">Field of View</a>: Monsters have their own fields of view, and will pursue the player on sight.</li>
<li><a href="pathfinding.html">Pathfinding</a>: Monsters step towards the player by first finding a path to follow.</li>
<li><a href="turn-order-and-combat.html">Turn Order and Combat</a>: Monsters get a turn between player turns and fight the player in melee combat.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="new-game-plus"><a class="header" href="#new-game-plus">New Game Plus</a></h1>
<p>RuggRogue allows the player to continue playing the game after they win by way of the <em>New Game Plus</em> mode.
When the player dismisses the victory screen, they're fully healed and are allowed deeper into the dungeon.
The player keeps their level, experience, stats and all of their equipment and items, apart from the victory item.
The game in turn will allow more monsters and items to spawn the more times the player wins.
The power of weapons and armor spawned will continue to increase, but the power of monsters resets.
Thus, New Game Plus is intended to serve as a victory lap for the player to collect ever more powerful equipment, and not so much deliver a proper challenge.</p>
<h2 id="starting-new-game-plus"><a class="header" href="#starting-new-game-plus">Starting New Game Plus</a></h2>
<p>The player wins the game by using the Present item.
The Present item has a <code>Victory</code> tag component that is checked by the <code>item::use_item</code> function in the <code>src/item.rs</code> file.
The game auto-saves itself before consuming the Present item, then increments the <em>win counter</em> before guiding the <code>DungeonMode::update</code> function in the <code>src/modes/dungeon.rs</code> file to bring up the <code>GameOverMode</code>.</p>
<p>Recall that <code>GameOverMode</code> is used both for player victory and defeat, depending on the state of the unique <code>PlayerAlive</code> flag.
When the player presses a key to dismiss the screen, the following code in the <code>GameOverMode::update</code> function in the <code>src/modes/game_over.rs</code> file runs:</p>
<pre><code class="language-rust ignore">let player_alive = world.borrow::&lt;UniqueView&lt;PlayerAlive&gt;&gt;().0;

title::post_game_cleanup(world, !player_alive); // &lt;-- (1)
if player_alive {
    title::new_game_setup(world, true); // &lt;-- (2)
}

inputs.clear_input();
return (
    ModeControl::Switch(if player_alive {
        // Jump straight into new game plus.
        DungeonMode::new().into() // &lt;-- (3)
    } else {
        TitleMode::new().into()
    }),
    ModeUpdate::Immediate,
);
</code></pre>
<p>In the case of victory in the above code, the <code>player_alive</code> boolean flag will be <code>true</code>, so the game does the following:</p>
<ol>
<li>Run the <code>title::post_game_cleanup</code> function.</li>
<li>Run the <code>title::new_game_setup</code> function.</li>
<li>Switch back to the <code>DungeonMode</code>.</li>
</ol>
<p>The <code>title::post_game_cleanup</code> function is defined in the <code>src/modes/title.rs</code> file.
It simply despawns map-local entities such as monsters still alive and any items left behind, and in the case of victory that's all it does.</p>
<p>The <code>title::new_game_setup</code> function in the same file is used to start both new games and the New Game Plus runs.
If New Game Plus is needed, the <code>new_game_plus</code> argument is set to <code>true</code>, causing the function to:</p>
<ul>
<li>Increment the turn count and depth, as if the player had taken a downstairs on the final level.</li>
<li>Restore the player to full health.</li>
<li>Store the level of the difficulty tracker as the <em>base equipment level</em> for the New Game Plus run.</li>
</ul>
<p>Since the difficulty tracker is reset for both new games and New Game Plus runs, the last point ensures that new weapons and armor that spawn will do so with ever-increasing power.</p>
<h2 id="win-counter"><a class="header" href="#win-counter">Win Counter</a></h2>
<p>As mentioned earlier, the <em>win counter</em> tracks the number of times the player beats the game.
It's defined in the form of the <code>Wins</code> unique all the way back in the <code>src/main.rs</code> file, like so:</p>
<pre><code class="language-rust ignore">pub struct Wins(u32);
</code></pre>
<p>The <code>Wins</code> unique is increased by one when the player uses the Present item in the <code>item::use_item</code> function in the <code>src/item.rs</code> file.</p>
<p>The win counter increases the maximum number of randomly-spawned items and monsters per room by one in New Game Plus runs.
The <code>fill_rooms_with_spawns</code> function in the <code>src/spawn.rs</code> file checks the <code>Wins</code> unique to accomplish this.</p>
<h2 id="base-equipment-level"><a class="header" href="#base-equipment-level">Base Equipment Level</a></h2>
<p>Recall that the difficulty tracker is reset by the <code>title::new_game_setup</code> function.
This resets the power of spawned monsters, but would also do the same thing to weapons and armor!
To counteract this, there's a concept of a <em>base equipment level</em>, stored in the form of the <code>BaseEquipmentLevel</code> unique in the <code>src/main.rs</code> file like so:</p>
<pre><code class="language-rust ignore">pub struct BaseEquipmentLevel(i32);
</code></pre>
<p>The <code>title::new_game_setup</code> function stores the level of the difficulty tracker in the <code>BaseEquipmentLevel</code> unique before resetting the difficulty tracker.
The <code>BaseEquipmentLevel</code> is then consulted by the <code>spawn_weapon</code> and <code>spawn_armor</code> functions in the <code>src/spawn.rs</code> file to add to the power of spawned equipment in New Game Plus runs.
This prevents equipment in New Game Plus runs from being useless relative to the equipment that the player was allowed to carry over from the previous run.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
